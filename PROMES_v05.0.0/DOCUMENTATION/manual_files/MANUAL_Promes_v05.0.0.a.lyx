#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass report
\begin_preamble
\usepackage[flushleft]{threeparttable}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{enumitem}

\usepackage{hyperref}
\def\UrlBreaks{\do\/\do-}

%\usepackage[hyphenbreaks]{breakurl}

\usepackage{graphicx}

\usepackage[numbered,framed]{matlab-prettifier}

\usepackage{dirtree}

\tolerance=1
\emergencystretch=\maxdimen
\hyphenpenalty=10000
\hbadness=10000

% new chapter does not start on new page
\usepackage{etoolbox}
\makeatletter
\patchcmd{\chapter}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}{}
\makeatother

\usepackage{arydshln}%for dashed line in matrix

% chapter title in format:
% 1 Chapter_title
\usepackage{titlesec}

\titleformat{\chapter}[block]
  {\normalfont\huge\bfseries}{\thechapter.}{1em}{\Huge}
\titlespacing*{\chapter}{0pt}{19pt plus 6pt minus 3pt}{10pt}

\counterwithout{footnote}{chapter}

\usepackage{caption}
\usepackage{subcaption}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine biblatex-natbib
\cite_engine_type authoryear
\biblio_style plain
\biblatex_bibstyle authoryear
\biblatex_citestyle authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "frame=single,style={Matlab-editor}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage} 	
\end_layout

\begin_layout Plain Layout


\backslash
centering 	
\end_layout

\begin_layout Plain Layout


\backslash
vspace{4cm} 
\end_layout

\begin_layout Plain Layout

{
\backslash
Huge 
\backslash
bfseries 
\backslash
scshape Manual for 
\backslash
par} 
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.5cm}	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[scale=0.25]{FIGURES/LOGO}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.35cm} 	
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

{
\backslash
huge 
\backslash
itshape a projection method solver 
\backslash
par}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.15cm} 
\end_layout

\begin_layout Plain Layout

{
\backslash
huge 
\backslash
itshape for Matlab} 	
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout


\backslash
vspace{2.5cm} 
\end_layout

\begin_layout Plain Layout

{
\backslash
LARGE Sijmen Duineveld}
\end_layout

\begin_layout Plain Layout

%
\backslash
vspace{1.5cm}  
\end_layout

\begin_layout Plain Layout


\backslash
vfill
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

{
\backslash
Large 
\backslash
textsf{Promes, version 05.0.0.a}
\backslash
par
\end_layout

\begin_layout Plain Layout


\backslash
textsf{December 26, 2021}} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
Manual
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
The
\family typewriter
 Promes
\family default
 toolbox solves Dynamic Stochastic General Equilibrium models using projection
 methods.
 
\family typewriter
Promes
\family default
 is an acronym for 
\bar under
Pro
\bar default
jection 
\bar under
me
\bar default
thod 
\bar under
s
\bar default
olver.
 The toolbox is written for Matlab, and tested with Matlab 2016b and 2019a.
 
\end_layout

\begin_layout Standard
The toolbox offers several algorithms to solve a model.
 The policy function can be approximated with either a spline, a complete
 Chebyshev polynomial, a Smolyak polynomial
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The Smolyak algorithm is implemented with the code written by Rafa Valero
 (2021).
 Smolyak Anisotropic Grid (
\begin_inset CommandInset href
LatexCommand href
target "https://www.mathworks.com/matlabcentral/fileexchange/50963-smolyak-anisotropic-grid"

\end_inset

), MATLAB Central File Exchange.
 Retrieved November 5, 2021.
 The algorithm is described in 
\begin_inset CommandInset citation
LatexCommand citet
key "judd2014smolyak"
literal "false"

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "fn:Smolyak-algorithm"

\end_inset


\end_layout

\end_inset

, or a complete polynomial based on monomials.
 The toolbox is both fast
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
All reported computation times are on a Windows 10 PC with Matlab 2019a
 and a Ryzen 2700x processor, and without any parallel computing.
\end_layout

\end_inset

 and accurate.
 For example, for a standard Real Business Cycle (RBC) model a maximum error
 of 
\begin_inset Formula $10^{-6}$
\end_inset

 can be achieved in less than 0.05 seconds with each of the basis functions.
 A maximum error of 
\begin_inset Formula $10^{-13}$
\end_inset

 can be achieved in 0.3 seconds with a complete Chebyshev polynomial.
 Due to the curse of the dimensionality, computation times do increase strongly
 with the number of state variables.
 For example, a model with four continuous state variables and two policy
 variables is solved in 5 seconds with a spline 
\begin_inset CommandInset citation
LatexCommand citep
key "duineveld2021standardized"
literal "false"

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
This manuscript is included in the folder `Documentation'.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Section
Core of the toolbox
\end_layout

\begin_layout Standard
Three functions form the core of the 
\family typewriter
Promes
\family default
 toolbox.
 The first function is 
\family typewriter
prepgrid
\family default
, which constructs a grid taking the grid parameters and the algorithm as
 input.
 The second is 
\family typewriter
get_pol_var
\family default
, which evaluates the policy function taking the state variables as input.
 This function simplifies programming the model file and simulations.
 The third is 
\family typewriter
solve_proj
\family default
, which solves the model, given the algorithm, an initial guess, and the
 grid.
 The initial guess for the policy function should give the policy variable(s)
 at the gridpoints.
 The toolbox will internally construct the appropriate policy function,
 either a spline or a polynomial.
 These three functions are the only functions the modeler has to call directly
 when solving and simulating a model.
 The functions are placed in the main folder `PROMES_v05.0.0', and are explained
 in Part 
\begin_inset CommandInset ref
LatexCommand ref
reference "part:Function-descriptions"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
With these three functions solving a DSGE model with projection methods
 becomes relatively easy.
 The main task of the modeler is to program the model function.
 The model function has to compute the residuals of the objective function,
 given a grid and the policy function.
 The requirements for a model file are explained in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Model-file"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 One has to pay special attention to the formats for evaluating the policy
 function (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Formats-for-evaluation"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Section
Getting started
\end_layout

\begin_layout Standard
To get started with the toolbox it is recommended to go through the examples.
 The code of these examples can be found in the folder `PROMES_v05.0.0
\backslash
Examples'.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Proj_intro"
plural "false"
caps "false"
noprefix "false"

\end_inset

 gives an introduction to projection methods, and explains the basic features
 of the toolbox.
 It describes a very simple non-recursive model, which is solved in the
 program 
\family typewriter
main_exp_proj
\family default
.
 This example plots the exact solution and the projection approximation.
\end_layout

\begin_layout Standard
For those familiar with projection methods it is recommended to start with
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:The-Basics"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which describes a 6-step procedure to solve a model with the 
\family typewriter
Promes
\family default
 toolbox.
 This procedure is explained with a very simple recursive model, the determinist
ic Brock-Mirman model.
 The program 
\family typewriter
main_det_bm_proj 
\family default
solves this model following the six steps.
 This program also plots the policy function, and the errors.
 
\end_layout

\begin_layout Standard
A more detailed step-by-step guide can be found in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:RBC-example"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which is based on a standard Real Business Cycle (RBC) model with stochastic
 shocks.
 The code for this model is the script 
\family typewriter
main_stnd_rbc_proj
\family default
.
 As in the previous example the program will plot the policy function.
 In addition it will plot two stochastic simulations, and compute the errors.
 
\end_layout

\begin_layout Standard
The last example is the program 
\family typewriter
main_housing_proj
\family default
, which shows how to solve a model with multiple policy functions.
 It is an RBC model with housing as an extra asset.
 
\end_layout

\begin_layout Standard
In Part 
\begin_inset CommandInset ref
LatexCommand ref
reference "part:Theoretical-description"
plural "false"
caps "false"
noprefix "false"

\end_inset

 the algorithms are described theoretically.
 In Part 
\begin_inset CommandInset ref
LatexCommand ref
reference "part:Function-descriptions"
plural "false"
caps "false"
noprefix "false"

\end_inset

 the technical and coding details of the toolbox are discussed.
 In Part 
\begin_inset CommandInset ref
LatexCommand ref
reference "part:Example-models"
plural "false"
caps "false"
noprefix "false"

\end_inset

 the equations of the example models are derived.
\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
For the installation download the `Promes_v05.0.0.a.zip' file from 
\begin_inset CommandInset href
LatexCommand href
target "https://www.promestoolbox.com/"

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Older versions are available at 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/saduineveld/Promes_toolbox"

\end_inset

.
 The latest release is also found on 
\begin_inset CommandInset href
LatexCommand href
name "https://www.saduineveld.com/tools"
target "https://www.saduineveld.com/tools"
literal "false"

\end_inset

.
\end_layout

\end_inset

, and unpack the file in a folder.
 This will add the folders `PROMES_v05.0.0' and `TOOLS' to the destination
 folder.
 The folders and files of the 
\family typewriter
Promes
\family default
 toolbox are in the folder `PROMES_v05.0.0' and are shown in Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Promes_struct}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
DTstyle}{
\backslash
textrm
\backslash
expandafter
\backslash
raisebox{-0.7ex}} 
\end_layout

\begin_layout Plain Layout


\backslash
DTsetlength{1em}{1em}{0.2em}{0.4pt}{0.4pt} 
\end_layout

\begin_layout Plain Layout


\backslash
setlength{
\backslash
DTbaselineskip}{1.4
\backslash
baselineskip}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
texttt{PROMES} folders and files} 
\backslash
label{fig:Promes_struct} 
\backslash
dirtree{%  
\end_layout

\begin_layout Plain Layout

.1 Folder: PROMES
\backslash
_v05.0.0.
   
\end_layout

\begin_layout Plain Layout

.2 
\backslash
texttt{get
\backslash
_pol
\backslash
_var.m}.
   
\end_layout

\begin_layout Plain Layout

.2 
\backslash
texttt{prepgrid.m}.
 
\end_layout

\begin_layout Plain Layout

.2 
\backslash
texttt{solve
\backslash
_proj.m}.
    
\end_layout

\begin_layout Plain Layout

.2 Folder: grid
\backslash
_subfun.
    
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{chebnodes.m}.
    
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{constr
\backslash
_grid.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{constr
\backslash
_univar
\backslash
_basis.m}.
   
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{constr
\backslash
_vecs.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{get
\backslash
_poly
\backslash
_ani.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{gridstruct.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{gridstruct
\backslash
_smolyak.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{poly
\backslash
_elem
\backslash
_ani.m}.
   
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{sc
\backslash
_cheb
\backslash
_dw.m}.
   
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{sc
\backslash
_cheb
\backslash
_up.m}.
   
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{sc
\backslash
_mat
\backslash
_dw.m}.
   
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{sc
\backslash
_mat
\backslash
_up.m}.
   
\end_layout

\begin_layout Plain Layout

.2 Folder: smolyak
\backslash
_subfun.
   
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{Smolyak
\backslash
_Elem
\backslash
_Anisotrop.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{Smolyak
\backslash
_Elem
\backslash
_Isotrop.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{Smolyak
\backslash
_Grid.m}.
  
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{Smolyak
\backslash
_Polynomial.m}.
  
\end_layout

\begin_layout Plain Layout

.2 Folder: Examples.
 
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{grid
\backslash
_example.m}.
 
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{main
\backslash
_det
\backslash
_bm
\backslash
_proj.m}.
 
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{main
\backslash
_housing.m}.
 
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{main
\backslash
_exp
\backslash
_proj.m}.
 
\end_layout

\begin_layout Plain Layout

.3 
\backslash
texttt{main
\backslash
_stnd
\backslash
_rbc
\backslash
_proj.m}.
 
\end_layout

\begin_layout Plain Layout

.3 Folder: STND
\backslash
_RBC
\backslash
_mod.
 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to use the 
\family typewriter
Promes
\family default
 toolbox one needs to add the folder `PROMES_v05.0.0' and the subfolders `grid_sub
fun' and `smolyak_subfun' to the search path.
 After unpacking the 
\family typewriter
zip
\family default
 file in the folder `C:
\backslash
Myfolder' one can add `PROMES_v05.0.0' and all its subfolders to the searchpath
 with the Matlab command:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

addpath(genpath('C:
\backslash
Myfolder
\backslash
PROMES_v05.0.0'));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The folder `PROMES_v05.0.0' also has a subfolder `Examples' which contains
 five examples:
\end_layout

\begin_layout Itemize

\family typewriter
main_exp_proj
\family default
 is used to explain the basics of projection methods, and the main features
 of the toolbox in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Proj_intro"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize

\family typewriter
grid_example
\family default
 illustrates the construction of the grid, and is explained in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize

\family typewriter
main_det_bm_proj
\family default
 demonstrates a basic procedure to use to toolbox as described in Chapter
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:The-Basics"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with a very simple model, the deterministic Brock-Mirman model;
\end_layout

\begin_layout Itemize

\family typewriter
main_stand_rbc_proj
\family default
 demonstrates some details of the toolbox as described in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:RBC-example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with a standard RBC model with stochastic shocks.
 The subfolder `STND_RBC_mod' contains additional functions needed to obtain
 the results;
\end_layout

\begin_layout Itemize

\family typewriter
main_housing_proj
\family default
 shows how to solve a model with multiple policy functions as described
 in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Multiple-policy-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with an RBC model that includes housing as an extra asset.
 
\end_layout

\begin_layout Standard
The examples 
\family typewriter
main_stand_rbc_proj
\family default
 and 
\family typewriter
main_housing_proj
\family default
 require the addition of the folder `TOOLS' to the searchpath.
 This folder contains the function 
\family typewriter
hernodes
\family default
, and the perturbation toolbox 
\family typewriter
CSD
\family default
.
 The latter can be used to obtain an initial guess for the policy function.
\end_layout

\begin_layout Section
Algorithms
\begin_inset CommandInset label
LatexCommand label
name "sec:Algorithms"

\end_inset


\end_layout

\begin_layout Standard
This section gives a brief overview of the algorithms.
 More details are described in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Specific-Algorithms"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Projection method algorithms consist of three main choices
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
after "Table 3"
key "gaspar1997solving"
literal "false"

\end_inset

 mention a fourth choice, which is the integration method to compute the
 expected value of future states of the economy.
\end_layout

\end_inset

: the basis functions, the projection condition and the solution method.
 An overview of the implemented algorithms and their three choices is given
 in Table 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{table:algo_overview}
\end_layout

\end_inset

.
 The basis functions are used for the approximation of the policy function.
 The basis functions in this toolbox are splines, complete polynomials,
 and Smolyak-Chebyshev polynomials.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{table}[h] 
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{threeparttable}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Overview of algorithms}                     
\end_layout

\begin_layout Plain Layout


\backslash
label{table:algo_overview}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{llll} 
\end_layout

\begin_layout Plain Layout

Algorithm & Basis function & Proj.
 Cond.
 & Solution Meth.
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'spl_dir'$ & Spline & Collocation & Direct Comp.
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'spl_tmi' $ & Spline & Collocation & Time Iteration
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'cheb_gal'$ & Compl.
 Chebyshev polyn.
 & Galerkin & Newton type 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'cheb_tmi'$ & Compl.
 Chebyshev polyn.
 & Min.
 Sq.
 Err.
  & Time Iteration
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'cheb_mse'$ & Compl.
 Chebyshev polyn.
 &  Min.
 Sq.
 Err.
 & Trust-Region
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'mono_mse'$ & Monomials (compl.
 polyn.) & Min.
 Sq.
 Err.
 & Trust-Region
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'smol_dir'$ & Smolyak-Chebyshev polyn.
 & Collocation & Direct Comp.
 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'smol_tmi'$ & Smolyak-Chebyshev polyn.
 & Collocation & Time Iteration 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tabular} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{threeparttable}  
\end_layout

\begin_layout Plain Layout


\backslash
end{table}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The algorithms starting with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl'}
\end_layout

\end_inset

 use a spline
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Splines are determined by Matlab's 
\family typewriter
griddedInterpolant
\family default
.
\end_layout

\end_inset

 with equidistant nodes.
 A spline is a piece-wise polynomial.
 The algorithm names starting with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 approximate the policy function with complete polynomials.
 The one called 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

 uses equidistant nodes, and monomial basis functions (
\begin_inset Formula $1,x,x^{2},x^{3},\ldots$
\end_inset

), whereas the ones called 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 use complete Chebyshev polynomials with Chebyshev nodes.
 The algorithms starting with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol'}
\end_layout

\end_inset

 use Smolyak's algorithm, which relies on a sparse grid and a sparse Chebyshev
 polynomial
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See Footnote 
\begin_inset CommandInset ref
LatexCommand ref
reference "fn:Smolyak-algorithm"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The second choice is the projection condition.
 This toolbox includes collocation, Galerkin's method, and minimization
 of the squared errors.
 Collocation solves the model at the gridpoints.
 With Galerkin's method the residual function is orthogonal to the basis
 functions, similar to the Method of Moments 
\begin_inset CommandInset citation
LatexCommand citep
key "judd1998numerical"
literal "false"

\end_inset

.
 Minimization of the squared errors is used to obtain the coefficients of
 a polynomial that is overidentified.
\end_layout

\begin_layout Standard
The third choice is the solution method for the objective function.
 The toolbox uses four methods.
 The first is a Newton-type of non-linear equation solver.
 When a Newton-type of solver is used to solve the model at the gridpoints
 we call this Direct Computation.
 The third method is Time Iteration, which is specifically designed to solve
 recursive dynamic optimization problems.
 The fourth method uses a Trust-Region algorithm to solve least squares
 problems.
\end_layout

\begin_layout Standard
The toolbox does not (yet) include the Fixed Point algorithm 
\begin_inset CommandInset citation
LatexCommand citep
key "miranda1988effects"
literal "false"

\end_inset

, because it requires a different format of the model file than the other
 algorithms.
 The current format requires the model file to compute the Euler residuals
 as output.
 This contrasts with the Fixed Point algorithm, which requires the policy
 variables as output 
\begin_inset CommandInset citation
LatexCommand citep
key "gaspar1997solving"
literal "false"

\end_inset

.
 Initial tests showed that performance improvements are possible with Fixed
 Point Iteration compared to Time Iteration, so Fixed Point Iteration is
 planned for the next release
\begin_inset Foot
status open

\begin_layout Plain Layout
Tests with splines for the model with Habits in consumption and Investment
 Adjustment costs (HIA) 
\begin_inset CommandInset citation
LatexCommand citep
key "duineveld2021standardized"
literal "false"

\end_inset

 indicated that Time Iteration is more robust than Fixed Point Iteration.
 Without tweaking the dampening parameter Fixed Point Iteration either performed
 worse, or only slightly better.
 After tweaking the dampening parameter computation times could be reduced
 with 20% to 50%.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The algorithm using a spline with Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_tmi'}
\end_layout

\end_inset

) is the most robust, because splines preserve the shape of the policy function
 well, and Time Iteration is the only solution method that should theoretically
 converge to the saddle path stable solution 
\begin_inset CommandInset citation
LatexCommand citep
key "judd1998numerical"
literal "false"

\end_inset

.
 A spline with Direct Computation should be preferred over Time Iteration
 when the number of gridpoints is relatively low, and convergence is not
 an issue.
\end_layout

\begin_layout Standard
For small, well-behaved models complete Chebyshev polynomials with the Galerkin
 projection condition (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

) might be preferred as this algorithm performs best for the Standard RBC
 model described later.
 For models with a high number of state variables the Smolyak algorithm
 is recommended, because it is very effective at tackling the curse of the
 dimensionality.
 For the Smolyak algorithm the number of gridpoints grows only polynomially
 in the number of state variables, while it grows exponentially for the
 other algorithms.
\end_layout

\begin_layout Standard
The algorithms using Minimization of the Squared Errors (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

) are not recommended for two reasons.
 The first is that Minimization of the Squared Errors can get stuck in a
 local minimum 
\begin_inset CommandInset citation
LatexCommand citep
key "judd1992projection"
literal "false"

\end_inset

.
 The second reason is that the gradients of the residual function can be
 highly correlated, which makes it difficult to get an accurate result 
\begin_inset CommandInset citation
LatexCommand citep
key "judd1992projection"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Monomial basis functions in the algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

 are only included for demonstration purposes, although they might perform
 very well for low order approximations of simple models.
 Monomial basis functions are not recommended for two reasons 
\begin_inset CommandInset citation
LatexCommand citep
key "fernandez2016solution"
literal "false"

\end_inset

.
 The first is that they are highly collinear, especially for high order
 approximations.
 The second reason is that monomials are not scaled to have a similar magnitude.
 
\end_layout

\begin_layout Standard
The algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_tmi'}
\end_layout

\end_inset

 is not recommended either, unless there is a specific reason not to use
 splines.
 It will in general be outperformed by splines with Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_tmi'}
\end_layout

\end_inset

).
 The reason is that complete Chebyshev polynomials are overidentified when
 rectangular grids are used
\begin_inset Foot
status open

\begin_layout Plain Layout
The number of gridpoints grows exponentially but the number of coefficients
 grows polynomially.
\end_layout

\end_inset

.
 This means the polynomial will not go through the solution at the gridpoints,
 while a spline will go through these points.
 In general, for small scale problems 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

 will outperform 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_tmi'}
\end_layout

\end_inset

, but for larger problems 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_tmi'}
\end_layout

\end_inset

 is the better choice.
\end_layout

\begin_layout Standard
For complete polynomials we recommend to set the number of nodes equal to
 the order plus 1 
\begin_inset CommandInset citation
LatexCommand citep
before "see also"
key "fernandez2016solution"
literal "false"

\end_inset

.
 This is the minimum number of gridpoints for the algorithms using complete
 Chebyshev polynomials.
 For splines a low number of nodes usually suffices for reasonable accuracy.
 For example for the Standard RBC model only 3 nodes in each dimension results
 in errors of similar magnitude as the third order perturbation solution.
\end_layout

\begin_layout Standard
The accuracy of the results depends on the stopping criteria, especially
 with Time Iteration.
 For Time Iteration tighter stopping criteria will reduce the errors at
 the gridpoints, and can improve the accuracy significantly.
 This is discussed in more detail in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-5:-Solving"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for the Standard RBC model.
\end_layout

\begin_layout Section
Remarks
\end_layout

\begin_layout Subsection*
Matlab toolboxes
\end_layout

\begin_layout Standard
All methods require Matlab's 
\family typewriter
Optimization
\family default
 
\family typewriter
toolbox
\family default
.
 We use 
\family typewriter
fsolve
\family default
 for the algorithms with Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

), Direct Computation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

), or Galerkin (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'gal'}
\end_layout

\end_inset

).
 We use 
\family typewriter
lsqnonlin
\family default
 for the algorithms using Minimization of Squared Errors (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

).
 Alternatively one could use his/her own equation solver or minimization
 routine.
 This requires replacing the functions 
\family typewriter
fsolve
\family default
 and 
\family typewriter
lsqnonlin
\family default
 in the function 
\family typewriter
solve_proj
\family default
.
\end_layout

\begin_layout Subsection*
Notes on typesetting
\end_layout

\begin_layout Standard
Names in general are referred to by single quotations, like a folder name
 `Myfolder'.
 Variables, cell arrays, structure names, fields of structures, objects,
 and properties of objects in Matlab are referred to in the text with the
 mathematical font of Latex, for example variable 
\begin_inset Formula $x$
\end_inset

, structure 
\begin_inset Formula $par$
\end_inset

 or the field of a structure 
\begin_inset Formula $par.alpha$
\end_inset

.
 In general we use double letters in our code such as 
\begin_inset Formula $xx$
\end_inset

, because this makes it easier to find them.
 In this manual we generally refer to variables by the single letter (
\begin_inset Formula $x$
\end_inset

).
 Strings in Matlab code will be referred to in Matlab typesetting, for example
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'thisstring'}
\end_layout

\end_inset

.
 Names referring to toolboxes, code, functions or scripts are in Typewriter
 font, as in 
\family typewriter
myfunction
\family default
, where the 
\family typewriter
.m
\family default
 extension of functions and scripts will be omitted.
\end_layout

\begin_layout Subsection*
Scripts versus functions
\end_layout

\begin_layout Standard
There are two main differences between a function and a script in Matlab.
 The first is that one cannot define a subfunction in a script.
 The second is that a script will use the current workspace, while a function
 has its own workspace, which is empty unless input arguments are defined
 or global variables are used
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Global variables are not recommended for Matlab.
\end_layout

\end_inset

.
 With a function one can evaluate the variables in the workspace by placing
 a breakpoint.
\end_layout

\begin_layout Standard
The toolbox consists of functions, and most examples are also functions,
 except the files 
\family typewriter
grid_example 
\family default
and
\family typewriter
 main_stnd_rbc_proj
\family default
.
 For the latter example all subfunctions are stored in the subfolder `STND_RBC_m
od'.
 For the other examples all subfunctions are included in the main file.
 
\end_layout

\begin_layout Subsection*
Update to v05.0.0 from v04.3
\end_layout

\begin_layout Standard
The update from 
\family typewriter
Promes v04.3
\family default
 to 
\family typewriter
Promes v05.0.0
\family default
 is not backwards compatible.
 The necessary changes to run code written for 
\family typewriter
Promes v04.3
\family default
 with 
\family typewriter
Promes v5.0.0
\family default
 are however minimal.
 In 
\family typewriter
Promes v05.0.0
\family default
 it is not be possible to evaluate a policy function obtained with 
\family typewriter
Promes v04.3
\family default
.
 Also some default settings changed, which might affect the results.
 The changes are discussed in more detail in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Update-to-v05.0.0"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Section
Acknowledgments, sources, and license
\end_layout

\begin_layout Subsection*
Acknowledgments
\end_layout

\begin_layout Standard
We acknowledge that the Smolyak algorithm is implemented with the code provided
 by Rafa Valero
\begin_inset Foot
status open

\begin_layout Plain Layout
Rafa Valero (2021) Smolyak Anisotropic Grid, MATLAB Central File Exchange,
 Retrieved November 5, 2021 (
\begin_inset CommandInset href
LatexCommand href
target "https://www.mathworks.com/matlabcentral/fileexchange/50963-smolyak-anisotropic-grid"

\end_inset

).
\end_layout

\end_inset

.
 The algorithm of this code is described in 
\begin_inset CommandInset citation
LatexCommand citet
key "judd2014smolyak"
literal "false"

\end_inset

.
 In addition, I thank Wouter den Haan, Joris de Wind and Petr Sedlacek for
 the courses on solving DSGE models at the Tinbergen Institute.
 I would also like to thank Alfred Maussner, Christopher Heiberger, and
 Daniel Fehrle at the University of Augsburg for various discussions on
 solving DSGE models, and writing this toolbox.
 Furthermore, I thank Alfred Maussner and Joris de Wind for providing their
 codes on projection methods.
\end_layout

\begin_layout Subsection*
Sources on projection methods
\end_layout

\begin_layout Standard
Good references on projection methods are 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset

, and 
\begin_inset CommandInset citation
LatexCommand citet
key "fernandez2016solution"
literal "false"

\end_inset

.
 The paper by 
\begin_inset CommandInset citation
LatexCommand citet
key "duineveld2021standardized"
literal "false"

\end_inset

 evaluates the most efficient algorithms of the 
\family typewriter
Promes
\family default
 toolbox for three models.
 For practical guidelines on implementing projection methods 
\begin_inset CommandInset citation
LatexCommand citet
key "heer2009dynamic"
literal "false"

\end_inset

 and Wouter den Haan's material on his website 
\begin_inset CommandInset href
LatexCommand href
target "www.wouterdenhaan.com"
literal "false"

\end_inset

 are useful sources.
\end_layout

\begin_layout Subsection*
Copyright and license
\end_layout

\begin_layout Standard
The Promes toolbox is copyright 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
copyright
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
space
\end_layout

\end_inset

 Sijmen Duineveld, 2019-2021.
 The Promes toolbox is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by the
 Free Software Foundation, either version 3 of the License, or (at your
 option) any later version.
\end_layout

\begin_layout Standard
The Promes toolbox is distributed in the hope that it will be useful, but
 without any warranty; without even the implied warranty of merchantability
 or fitness for a particular purpose.
 See the GNU General Public License for more details.
 You should have received a copy of the GNU General Public License along
 with the Promes toolbox.
 If not, see 
\begin_inset CommandInset href
LatexCommand href
target "https://www.gnu.org/licenses/"

\end_inset

.
 
\end_layout

\begin_layout Subsection*
Feedback & questions
\end_layout

\begin_layout Standard
All feedback and questions are welcome at 
\begin_inset CommandInset href
LatexCommand href
name "s.a.duineveld@outlook.com"
target "s.a.duineveld@outlook.com"
literal "false"

\end_inset

.
\end_layout

\begin_layout Chapter
Introduction to projection methods
\begin_inset CommandInset label
LatexCommand label
name "chap:Proj_intro"

\end_inset


\end_layout

\begin_layout Standard
Projection methods are used to approximate an unknown function.
 We will explain the basic principles with a simple 2-period life-cycle
 model, called the Simple Life Cycle model.
 This simple model has 
\begin_inset Formula $C\left(x\right)=e^{x}$
\end_inset

 as its solution
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset

 also approximates 
\begin_inset Formula $e^{x}$
\end_inset

, but he derives it from a differential equation and imposes an initial
 condition.
 We use a simple discrete time model.
 It should be emphasized that the model does not have the recursive structure
 of infinite horizon problems, which oversimplifies some aspects.
 The other examples in this manual have the recursive structure.
\end_layout

\end_inset

.
 The program that solves this model is the function 
\family typewriter
main_exp_proj
\family default
 in the folder `PROMES_v05.0.0/Examples'.
 
\end_layout

\begin_layout Section
Simple Life Cycle model
\end_layout

\begin_layout Standard
The objective of the agent is to maximize utility derived from consumption
 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $C_{2}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\max_{C,C_{2}} & \:U\left(C\right)+U\left(C_{2}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The optimization is subject to the budget constraint:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{2} & =2e^{x}-C\label{eq:SMPL_budget}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $x$
\end_inset

 is the capital stock at the beginning of the first period.
 
\end_layout

\begin_layout Standard
With the Constant Relative Risk Aversion (CRRA) utility function 
\begin_inset Formula $U\left(C\right)=\frac{C_{t}^{1-\nu}-1}{1-\nu}$
\end_inset

 and restricting 
\begin_inset Formula $C\geq0$
\end_inset

, 
\begin_inset Formula $C_{2}\geq0$
\end_inset

, and 
\begin_inset Formula $\nu>0$
\end_inset

 the First Order Conditions (FOC) are sufficient to define a unique solution
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In most economic problems the model is restricted to be convex such that
 the First Order Conditions are sufficient to obtain a unique solution.
 Note however that dynamic models are usually saddle path stable, which
 means they have both a stable and an unstable solution.
\end_layout

\end_inset

.
 The FOCs yield
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We do not use the standard formulation 
\begin_inset Formula $C^{-\nu}=C_{2}^{-\nu}$
\end_inset

, because in that case the relative errors are larger for higher levels
 of consumption.
 From the perspective of the agent it would be optimal to allow for larger
 errors when consumption is high, due to the risk aversion.
 However, we take the modeler's perspective and prefer more equally distributed
 errors.
 To analyze the effect on the approximation one can change the residual
 function to 
\begin_inset Formula $C^{-\nu}=C_{2}^{-\nu}$
\end_inset

, and use a second order polynomial for the approximation (by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{POL.order = 2}
\end_layout

\end_inset

).
 The plots will show that the errors will be large for high levels of consumptio
n.
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\left(\frac{C}{C_{2}}\right)^{-\nu} & =1\label{eq:SMPL_FOC}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The system of equations consisting of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_FOC"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_budget"
plural "false"
caps "false"
noprefix "false"

\end_inset

 has the explicit solution 
\begin_inset Formula $C\left(x\right)=e^{x}$
\end_inset

.
\end_layout

\begin_layout Section
Projection explained
\end_layout

\begin_layout Standard
In general 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
projection methods approximate a policy variable as a function of the state
 variables.
 The state variables describe the current state of the economy, and are
 sufficient to determine the future behavior of the system
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
See 
\begin_inset CommandInset href
LatexCommand href
target "https://en.wikipedia.org/wiki/State_variable"

\end_inset

.
\end_layout

\end_inset

.
 In this example 
\begin_inset Formula $x$
\end_inset

 is the state variable, and we choose consumption 
\begin_inset Formula $C$
\end_inset

 as the policy or choice variable.
 The objective of projection methods is to approximate the exact policy
 function
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $C\left(x\right)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
with 
\begin_inset Formula $\hat{C}\left(x;\theta\right)$
\end_inset

, where 
\begin_inset Formula $\theta$
\end_inset

 is a vector of parameters that defines a polynomial or a spline.
 
\end_layout

\begin_layout Standard
The objective of projection methods is to find the policy function that
 solves the dynamic optimization problem.
 We need a residual function 
\begin_inset Formula $R\left(x;\theta\right)$
\end_inset

 that computes the errors in the dynamic equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_FOC"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a given approximation of the policy function.
 Given some policy 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\hat{C}\left(x;\theta\right)$
\end_inset

 we can compute 
\begin_inset Formula $C_{2}$
\end_inset

 with the budget restriction 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_budget"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The residuals are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(x;\theta\right) & =\left(\frac{\hat{C}\left(x;\theta\right)}{2e^{x}-\hat{C}\left(x;\theta\right)}\right)^{-\nu}-1\label{eq:SMPL_RES}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The objective of projection methods is to find the approximation that minimizes
 the residual function 
\begin_inset Formula $R$
\end_inset

 by setting 
\begin_inset Formula $\theta$
\end_inset

.
 
\end_layout

\begin_layout Standard
First we have to choose some interval 
\begin_inset Formula $\underline{x}\leq x\leq\overline{x}$
\end_inset

 of the state variable, where we want to approximation to be good
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
.
 We select a set of 
\begin_inset Formula $q$
\end_inset

 gridpoints on this interval:
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\begin{align}
x & =\left[\begin{array}{cccc}
x_{1} & x_{2} & \cdots & x_{q}\end{array}\right]^{\intercal}\label{eq:SMPL_ini_grid}
\end{align}

\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
We call this vector the initial grid, and it will be assigned to 
\begin_inset Formula $GRID.xx$
\end_inset

 by the function 
\family typewriter
prepgrid
\family default
.
 We want to emphasize that the modeler does not have to construct the grid.
 He/she only has to supply the inputs for the grid, consisting of the number
 of state variables 
\begin_inset Formula $n$
\end_inset

, the lower and upper bounds 
\begin_inset Formula $lb$
\end_inset

 (
\begin_inset Formula $\underline{x}$
\end_inset

) and 
\begin_inset Formula $ub$
\end_inset

 (
\begin_inset Formula $\overline{x}$
\end_inset

), and the algorithm 
\begin_inset Formula $algo$
\end_inset

.
 One can specify further options with the optional input argument 
\begin_inset Formula $algo\textrm{\_}spec$
\end_inset

.
 The function 
\family typewriter
prepgrid
\family default
 will construct the required fields in the structure 
\begin_inset Formula $GRID$
\end_inset

 using the default settings with a simple call:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

GRID = prepgrid(nn,lb,ub,algo);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After constructing the grid we need to calculate the residuals for which
 we use the model function 
\family typewriter
res_exp
\family default
.
 This subfunction takes the parameters 
\begin_inset Formula $par$
\end_inset

, the structure 
\begin_inset Formula $GRID$
\end_inset

 and the structure with the policy function 
\begin_inset Formula $POL$
\end_inset

 as inputs, and gives the residuals 
\begin_inset Formula $RES$
\end_inset

 as output:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% Residual function Simple Life Cycle model 
\end_layout

\begin_layout Plain Layout

function [RES]  = res_exp(par,GRID,POL)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Initial grid of state variable:
\end_layout

\begin_layout Plain Layout

xx = GRID.xx;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Evaluate policy function,
\end_layout

\begin_layout Plain Layout

% at the initial grid:
\end_layout

\begin_layout Plain Layout

if ~(strcmp(POL.algo,'spl_tmi') || ...
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'smol_tmi') || ...
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'cheb_tmi'))  
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  % standard: log(C) from policy function      
\end_layout

\begin_layout Plain Layout

  CC     = 	get_pol_var(POL,xx,GRID); 
\end_layout

\begin_layout Plain Layout

else     
\end_layout

\begin_layout Plain Layout

  % time iteration: solver directly sets C_i      
\end_layout

\begin_layout Plain Layout

  % (at gridpoint x_i)      
\end_layout

\begin_layout Plain Layout

  CC    = POL.YY; 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Budget constraint gives C2:
\end_layout

\begin_layout Plain Layout

C2 = 2*exp(xx) - CC;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Euler residuals:
\end_layout

\begin_layout Plain Layout

RES = (CC./C2).^-par.nu - 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To compute the residuals we evaluate the approximation of the policy variable
 
\begin_inset Formula $\hat{C}$
\end_inset


\begin_inset Formula $\left(x\right)$
\end_inset

 at the initial grid 
\begin_inset Formula $GRID.xx$
\end_inset

, for a given policy function in 
\begin_inset Formula $POL$
\end_inset

.
 There are two options for this.
 For all algorithms except those using Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) we call 
\family typewriter
get_pol_var
\family default
 with the state vector 
\begin_inset Formula $x$
\end_inset

 as input (Line 14).
 For the solution method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 we directly evaluate the policy variable at the gridpoints, which is stored
 in 
\begin_inset Formula $POL.YY$
\end_inset

 by the toolbox (Line 18).
 After calculating 
\begin_inset Formula $C_{2}$
\end_inset

 from the budget constraint in Line 19 we can 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
compute the residuals 
\begin_inset Formula $RES$
\end_inset

 as in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_RES"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The function 
\family typewriter
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
solve_proj
\family default
 computes the policy function 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
that minimizes these residuals.
 The function 
\family typewriter
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
solve_proj
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 will assign the policy function to the structure 
\begin_inset Formula $POL$
\end_inset

.
\end_layout

\begin_layout Standard
For all algorithms an initial guess for the policy function needs to be
 supplied to the solver 
\family typewriter
solve_proj
\family default
.
 The initial guess 
\begin_inset Formula $Y0$
\end_inset

 is the policy function at the initial grid.
 For our initial guess we use a third order Taylor series of the exact solution
 
\begin_inset Formula $C\left(x\right)=e^{x}$
\end_inset

 around some point 
\begin_inset Formula $x^{*}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{0}\left(x\right) & =C\left(x^{*}\right)+\left(x-x^{*}\right)e^{x^{*}}+\frac{\left(x-x^{*}\right)^{2}}{2}e^{x^{*}}+\frac{\left(x-x^{*}\right)^{3}}{6}e^{x^{*}}\label{eq:SMPL_Taylor_series}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Note that in general we approximate an unknown function, which prevents
 us from directly computing a Taylor series approximation.
 However, we can obtain a good initial guess for most models using perturbation
 methods, which gives us a Taylor series approximation of a dynamic system
 of equations.
\end_layout

\begin_layout Section
Spline methods
\begin_inset CommandInset label
LatexCommand label
name "sec:SMPL-Spline-methods"

\end_inset


\end_layout

\begin_layout Standard
Two algorithms use a spline, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_dir'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_tmi'}
\end_layout

\end_inset

.
 For both methods we use collocation, which solves the policy variable 
\begin_inset Formula $\hat{C}_{i}=C\left(x_{i}\right)$
\end_inset

 at the initial grid 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_ini_grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Given 
\begin_inset Formula $\hat{C}_{i}$
\end_inset

 the residual 
\begin_inset Formula $R$
\end_inset

 at gridpoint 
\begin_inset Formula $i=1,\ldots,q$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(x_{i},\hat{C}_{i}\right) & =\left(\frac{\hat{C}_{i}}{2e^{x_{i}}-\hat{C}_{i}}\right)^{-\nu}-1\label{eq:SMPL_res_tmidir}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The objective (in vector notation) is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(x,C\right) & =0\label{eq:SMPL_obj_tmidir}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
This is a system of 
\begin_inset Formula $q$
\end_inset

 independent equations for 
\begin_inset Formula $q$
\end_inset

 unknowns 
\begin_inset Formula $\hat{C}_{i}$
\end_inset

.
 We use 
\begin_inset Formula $q=4$
\end_inset

 equidistant nodes in the interval 
\begin_inset Formula $0\leq x\leq3$
\end_inset

.
 This results in gridpoints 
\begin_inset Formula $x=\left[0,1,2,3\right]^{\intercal}$
\end_inset

.
 We fit a spline through the solution at these gridpoints with Matlab's
 
\family typewriter
griddedInterpolant
\family default
, and the interpolation method set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The resulting policy function is plotted in Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:spl_dir_proj}
\end_layout

\end_inset

.
 We used 4 equidistant nodes and a cubic spline.
 The maximum error in 
\begin_inset Formula $\hat{C}\left(x\right)$
\end_inset

 is 0.26.
 The reason for this relatively large error is the small number of grid
 points.
 For comparison we have also included the third order Taylor series approximatio
n (see equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_Taylor_series"
plural "false"
caps "false"
noprefix "false"

\end_inset

) around the point 
\begin_inset Formula $x^{*}=1.5$
\end_inset

, which we used as an initial guess for the policy function.
 It is clear from the figure that the projection solution does well over
 the whole domain, while the Taylor series is inaccurate far away from the
 point 
\begin_inset Formula $x^{*}=1.5$
\end_inset

.
 The maximum error for the third order Taylor series is 3.8.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Spline approximation 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:spl_dir_proj}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename FIGURES/spl_dir.eps
	scale 70

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Monomial basis function
\begin_inset CommandInset label
LatexCommand label
name "sec:Monomial-basis-function"

\end_inset


\end_layout

\begin_layout Standard
The algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

 uses monomial basis functions to approximate the policy function.
 This algorithm is not recommended, but is a stepping stone to explaining
 approximation with Chebyshev polynomials.
 In our example we use the default order 3 monomial.
 The third order monomial basis functions consists of the terms 
\begin_inset Formula $\Phi=\left[\begin{array}{cccc}
1 & x & x^{2} & x^{3}\end{array}\right]$
\end_inset

.
 The third order polynomial approximation of 
\begin_inset Formula $C\left(x\right)$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{C}\left(x;\theta\right) & =\theta_{1}+\theta_{2}x+\theta_{3}x^{2}+\theta_{4}x^{3}\label{eq:SMPL_mono_appr}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
which means 
\begin_inset Formula $\theta$
\end_inset

 consists of 
\begin_inset Formula $p=4$
\end_inset

 coefficients.
 We use 
\begin_inset Formula $q=4$
\end_inset

 equidistant gridpoints on the interval 
\begin_inset Formula $0\leq x\leq3$
\end_inset

.
 As with the spline this results in the initial grid 
\begin_inset Formula $x=\left[0,1,2,3\right]^{\intercal}$
\end_inset

, which the function 
\family typewriter
prepgrid
\family default
 assigns to the field 
\begin_inset Formula $GRID.xx$
\end_inset

.
 
\end_layout

\begin_layout Standard
Having set the gridpoints we can evaluate the residual function 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_RES"
plural "false"
caps "false"
noprefix "false"

\end_inset

 at those points using the approximation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_mono_appr"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The objective of the algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

 is to minimize the sum of the squared residuals at the gridpoints:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\min_{\theta} & \sum_{i=1}^{q}R\left(x_{i};\theta\right)^{2}\label{eq:MSE_obj_mono}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $q$
\end_inset

 is the total number of gridpoints.
 The function 
\family typewriter
solve_proj
\family default
 minimizes the sum of the squared errors by setting 
\begin_inset Formula $\theta$
\end_inset

, which is assigned to 
\begin_inset Formula $POL.theta$
\end_inset

.
 The solver uses Matlab's 
\family typewriter
lsqnonlin
\family default
 of the 
\family typewriter
Optimization Toolbox
\family default
 to find the optimal values of 
\begin_inset Formula $\theta$
\end_inset

.
 As the system is exactly identified the error at the gridpoints will be
 (close to) zero.
\end_layout

\begin_layout Standard
The resulting third order approximation is plotted in Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Mono_proj}
\end_layout

\end_inset

.
 The maximum error in 
\begin_inset Formula $\hat{C}\left(\theta\right)$
\end_inset

 on the interval 
\begin_inset Formula $0\leq x\leq3$
\end_inset

 is 0.26.
 This error is of similar magnitude as the error in the spline approximation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
3rd order monomial approximation
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:Mono_proj}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename FIGURES/mono_mse.eps
	scale 70

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Chebyshev polynomials
\begin_inset CommandInset label
LatexCommand label
name "sec:MSE-with-Chebyshev"

\end_inset


\end_layout

\begin_layout Standard
The algorithms 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_tmi'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_mse'}
\end_layout

\end_inset

 use complete Chebyshev polynomials.
 Chebyshev polynomials differ from monomial basis function in two aspects
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Both aspects are taken care of by the toolbox, so the user does not need
 any knowledge of Chebyshev polynomials.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The first aspect is that for Chebyshev polynomials variables need to be
 scaled to the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 The linear scaling down of variables from the interval 
\begin_inset Formula $\left[\underline{x},\overline{x}\right]$
\end_inset

 (lower and upper bound) to the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\tilde{x}\left(x\right) & =\frac{2x}{\overline{x}-\underline{x},}-\frac{\underline{x},+\overline{x}}{\overline{x}-\underline{x},}\label{eq:Cheb_scal_dw}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\tilde{x}$
\end_inset

 is the scaled down variable.
 
\end_layout

\begin_layout Standard
The second difference is that Chebyshev nodes are used instead of equidistant
 nodes.
 In our example the number of nodes is set at 
\begin_inset Formula $q=4$
\end_inset

.
 The Chebyshev nodes on the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

 are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\tilde{x} & =\left[\begin{array}{cccc}
-0.924 & -0.383 & 0.383 & 0.924\end{array}\right]^{\intercal}\label{eq:Cheb_x_dw}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
This vector is stored in 
\begin_inset Formula $GRID.xx\textrm{\_}dw$
\end_inset

 (see Section 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{sec:Function-sc_cheb_dw}
\end_layout

\end_inset

).
 The scaled up values (see Section 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{sec:Function-sc_cheb_up}
\end_layout

\end_inset

) in the interval 
\begin_inset Formula $\left[0,3\right]$
\end_inset

 are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
x & =\left[\begin{array}{cccc}
0.114 & 0.926 & 2.074 & 2.89\end{array}\right]^{\intercal}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
which is assigned to 
\begin_inset Formula $GRID.xx$
\end_inset

.
 Note that these nodes are not linearly spaced.
\end_layout

\begin_layout Standard
As we use a third order approximation (
\begin_inset Formula $ord\textrm{\_}vec=3$
\end_inset

).
 The third order Chebyshev polynomial with one variable consists of 
\begin_inset Formula $p=4$
\end_inset

 terms:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{C}\left(x;\theta\right) & =\theta_{1}+\theta_{2}\tilde{x}\left(x\right)+\theta_{3}\left(2\tilde{x}\left(x\right)^{2}-1\right)+\theta_{4}\left(4\tilde{x}\left(x\right)^{3}-3\tilde{x}\left(x\right)\right)\label{eq:SMPL_Cheb_approx}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\tilde{x}\left(x\right)$
\end_inset

 is the scaled down variable.
 We can write in short-hand notation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{C}\left(x;\theta\right) & =\sum_{j=1}^{p}\theta_{j}\Omega_{j}\left(\tilde{x}\left(x\right)\right)\label{eq:SMPL_Cheb_appr-short}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Alternatively we can write the polynomial as a matrix of polynomial terms:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\Omega\left(\tilde{x}\left(x\right)\right) & =\left[\begin{array}{cccc}
1 & \tilde{x}\left(x\right) & 2\tilde{x}\left(x\right)^{2}-1 & 4\tilde{x}\left(x\right)^{3}\end{array}-3\tilde{x}\left(x\right)\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
which is a 
\begin_inset Formula $q\times p$
\end_inset

 matrix, where 
\begin_inset Formula $q$
\end_inset

 is the number of datapoints.
 This allows us to formulate 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_Cheb_appr-short"
plural "false"
caps "false"
noprefix "false"

\end_inset

 using matrix multiplication:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{C}\left(x;\theta\right) & =\Omega\left(\tilde{x}\left(x\right)\right)\theta\label{eq:SMPL_Cheb_matrix}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
There are three algorithms with complete Chebyshev polynomials.
 The first is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_mse'}
\end_layout

\end_inset

, which has the same objective 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:MSE_obj_mono"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as with monomials.
 The second algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

 uses Galerkin projection.
 This means each coefficient 
\begin_inset Formula $\theta_{j}$
\end_inset

 for 
\begin_inset Formula $j=1,\ldots,p$
\end_inset

 is set such that the residuals 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_RES"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are orthogonal to the corresponding polynomial term 
\begin_inset Formula $\Omega_{j}\left(\tilde{x}\left(x\right)\right)$
\end_inset

 in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_Cheb_appr-short"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Using matrix notation we have to solve a system of equations:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
0 & =R\left(x;\theta\right)^{\intercal}\Omega\left(\tilde{x}\left(x\right)\right)\label{eq:SMPL_obj_gal_matrix}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $R\left(x;\theta\right)$
\end_inset

 is the 
\begin_inset Formula $q\times1$
\end_inset

 residual vector at the gridpoints.
 This gives us a system of 
\begin_inset Formula $p$
\end_inset

 equations in 
\begin_inset Formula $p$
\end_inset

 unknowns.
 An alternative formulation of the objective for each 
\begin_inset Formula $\theta_{j}$
\end_inset

 is to solve the equation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
0 & =\sum_{i=1}^{q}R\left(x_{i};\theta\right)\Omega_{j}\left(\tilde{x}\left(x_{i}\right)\right)\label{eq:SMPL_obj_gal_sum}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The third algorithm is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_tmi'}
\end_layout

\end_inset

.
 For this algorithm we use Time Iteration, meaning that we first solve the
 policy variable at the gridpoints 
\begin_inset Formula $\hat{C}_{i}=\hat{C}\left(x_{i}\right)$
\end_inset

 for 
\begin_inset Formula $i=1,\ldots,q$
\end_inset

 as we did in for splines in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SMPL-Spline-methods"
plural "false"
caps "false"
noprefix "false"

\end_inset

, using residual function 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_res_tmidir"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and objective 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_obj_tmidir"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
The second step of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_tmi'}
\end_layout

\end_inset

 is to fit the complete polynomial through the solution at the gridpoints.
 This is done by solving the linear system of equations:
\begin_inset Formula 
\begin{align}
\theta & =\Omega\left(\tilde{x}\left(x\right)\right)^{-1}\hat{C}\label{eq:SMPL_coeff_inversion}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The result for the third order approximation with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

 is plotted in Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:cheb_gal_proj}
\end_layout

\end_inset

.
 The maximum error in 
\begin_inset Formula $\hat{C}\left(\theta\right)$
\end_inset

 on the interval 
\begin_inset Formula $0\leq x\leq3$
\end_inset

 is 0.18.
 As before the number of parameters 
\begin_inset Formula $\theta$
\end_inset

 and the number of nodes are the same (
\begin_inset Formula $p=q=4$
\end_inset

) resulting in (close to) zero errors at the gridpoints.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
3rd order Chebyshev approximation
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:cheb_gal_proj}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename FIGURES/cheb_gal.eps
	scale 70

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Smolyak algorithm
\begin_inset CommandInset label
LatexCommand label
name "sec:SMPL-Smolyak"

\end_inset


\end_layout

\begin_layout Standard
The Smolyak algorithm uses a sparse grid and sparse polynomial to approximate
 the policy function.
 The grid is constructed using nested sets with a special format.
 For this reason the only grid parameter than can be set is 
\begin_inset Formula $\mu$
\end_inset

, which determines the total number of gridpoints, which is equal to the
 number of coefficients of the polynomial.
\end_layout

\begin_layout Standard
In the one dimension case the number of nodes is 
\begin_inset Formula $q_{\mu}=2^{\mu}+1$
\end_inset

, and the degree of the Chebyshev polynomial is 
\begin_inset Formula $2^{\mu}$
\end_inset

.
 The nodes correspond to the extrema of a univariate Chebyshev polynomial.
 For given 
\begin_inset Formula $\mu$
\end_inset

 with 
\begin_inset Formula $i=1,\ldots,q_{\mu}$
\end_inset

 the gridpoints are 
\begin_inset CommandInset citation
LatexCommand citep
key "judd2014smolyak"
literal "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
x_{i} & =\begin{cases}
0 & \textrm{for}\:\mu=0\\
-\cos\left(\frac{i-1}{q_{\mu}-1}\pi\right) & \textrm{for}\:\mu>0
\end{cases}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We set 
\begin_inset Formula $\mu=2$
\end_inset

 which results in 
\begin_inset Formula $m=5$
\end_inset

 gridpoints, and an order 4 polynomial (with 
\begin_inset Formula $p=5$
\end_inset

 coefficients).
 The nodes are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
x & =\left[\begin{array}{ccccc}
0 & -1 & 1 & -0.707 & 0.707\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Formula $m\times p$
\end_inset

 matrix with polynomial terms is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\Omega\left(\tilde{x}\left(x\right)\right) & =\left[\begin{array}{ccccc}
\begin{array}{c}
1\end{array} & \tilde{x}\left(x\right) & 2\tilde{x}\left(x\right)^{2}-1 & 4\tilde{x}\left(x\right)^{3}-3\tilde{x}\left(x\right) & 8\tilde{x}\left(x\right)^{4}-8\tilde{x}\left(x\right)^{2}+1\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
With 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_tmi'}
\end_layout

\end_inset

 we use collocation.
 We solve for the policy variable 
\begin_inset Formula $\hat{C}_{i}$
\end_inset

 at the gridpoints 
\begin_inset Formula $i$
\end_inset

 using residual function 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_res_tmidir"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and objective 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_obj_tmidir"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as with the spline algorithms and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_tmi'}
\end_layout

\end_inset

.
 Given the solution 
\begin_inset Formula $\hat{C}$
\end_inset

 at the gridpoints the coefficients 
\begin_inset Formula $\theta$
\end_inset

 can be determined with equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SMPL_coeff_inversion"
plural "false"
caps "false"
noprefix "false"

\end_inset

 using matrix inversion.
 With 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_dir'}
\end_layout

\end_inset

 we directly solve for the coefficients 
\begin_inset Formula $\theta$
\end_inset

 using the objective (in vector notation):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
R\left(x;\theta\right) & =0
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The results are plotted in Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:smol_dir_proj}
\end_layout

\end_inset

.
 The maximum absolute error is 0.04 for an order four polynomial (
\begin_inset Formula $\mu=2$
\end_inset

).
 This error is considerably smaller than with third order polynomials.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Smolyak approximation 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{fig:smol_dir_proj}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename FIGURES/smol_dir.eps
	scale 70

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Basic Procedure
\begin_inset CommandInset label
LatexCommand label
name "chap:The-Basics"

\end_inset


\end_layout

\begin_layout Standard
To set up, solve and evaluate a model with the 
\family typewriter
Promes
\family default
 toolbox one typically needs to take 6 steps:
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Enumerate
Set the parameters and solve the steady state;
\end_layout

\begin_layout Enumerate
Set the grid parameters, choose the algorithm, and construct the grid using
 the function 
\family typewriter
prepgrid
\family default
;
\end_layout

\begin_layout Enumerate
Create the model function, and function handle;
\end_layout

\begin_layout Enumerate
Make an initial guess for the policy function;
\end_layout

\begin_layout Enumerate
Solve the model, using the function 
\family typewriter
solve_proj;
\end_layout

\begin_layout Enumerate
Evaluate the solution using the function 
\family typewriter
get_pol_var
\family default
.
\end_layout

\begin_layout Standard
To explain the above steps we use a very simple deterministic macroeconomic
 model, which we solve with the default settings of each algorithm.
 We describe the model in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:BM_model"
plural "false"
caps "false"
noprefix "false"

\end_inset

, define the approximated solution in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:BM-Approx_solution"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and the program code in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:BM_program"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The program is the function 
\family typewriter
main_det_bm_proj
\family default
, which can be found in the folder `PROMES_v05.0.0/Examples'.
 
\end_layout

\begin_layout Section
Deterministic Brock-Mirman model
\begin_inset CommandInset label
LatexCommand label
name "sec:BM_model"

\end_inset


\end_layout

\begin_layout Standard
The Brock-Mirman model that we use is a special case of the deterministic,
 representative agent growth problem described by 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Example in 16.4 starting on page 549.
\end_layout

\end_inset

.
 The model is discussed in more detail in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Description-det-BM"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The deterministic version of the model has only one state variable, which
 is capital 
\begin_inset Formula $K_{t}$
\end_inset

.
 The advantage of this model is that there exists an analytical solution
 to which we can compare the numerical solution.
 
\end_layout

\begin_layout Standard
The representative agent maximizes his/her discounted utility:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\max & \sum_{t=1}^{\infty}\beta^{t-1}\log\left(C_{t}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
subject to:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
K_{t+1}+C_{t} & =K_{t}^{\alpha}\label{eq:BM-budget}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $C_{t}$
\end_inset

 is consumption in period 
\begin_inset Formula $t$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

 is the discount factor, 
\begin_inset Formula $K_{t}$
\end_inset

 is the capital stock at the beginning of the period, and 
\begin_inset Formula $K_{t}^{\alpha}$
\end_inset

 is the production function.
 Applying the recursive formulation and taking the first order conditions
 with respect to 
\begin_inset Formula $K_{t+1}$
\end_inset

 and 
\begin_inset Formula $C_{t}$
\end_inset

 we obtain the Euler equation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\frac{1}{C_{t}} & =\beta\frac{1}{C_{t+1}}\alpha K_{t+1}^{\alpha-1}\label{eq:Euler_BM}
\end{align}

\end_inset


\end_layout

\begin_layout Section
Approximation of the policy function
\begin_inset CommandInset label
LatexCommand label
name "sec:BM-Approx_solution"

\end_inset


\end_layout

\begin_layout Standard
The objective is to find the policy function for consumption as a function
 of the state variable capital.
 The two equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM-budget"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Euler_BM"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are sufficient to solve the model with projection methods.
 
\end_layout

\begin_layout Standard
We approximate the policy function for consumption as a function of capital
 
\begin_inset Formula $C_{t}=C\left(K_{t}\right)$
\end_inset

.
 We use either a polynomial or a spline 
\begin_inset Formula $\hat{C}_{t}=\hat{C}\left(K_{t};\theta\right)$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In practice we use both consumption and capital in logs 
\begin_inset Formula $\hat{c}_{t}=\hat{c}\left(k_{t};\theta\right)$
\end_inset

, where smaller cases indicate logs.
\end_layout

\end_inset

, where 
\begin_inset Formula $\theta$
\end_inset

 is a vector of coefficients determining the spline or polynomial..
 To indicate the parameterization of the 
\begin_inset Formula $j$
\end_inset

-th iteration we write 
\begin_inset Formula $\theta^{j}$
\end_inset

.
 To obtain the solution we minimize the residuals of the Euler equation
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Euler_BM"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a finite number of gridpoints.
\end_layout

\begin_layout Standard
To calculate the Euler residuals at these gridpoints we first calculate
 next period's capital stock using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM-budget"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{K}_{t+1} & =K_{t}^{\alpha}-\hat{C}\left(K_{t};\theta^{q}\right)\label{eq:BM_alm_k_pol}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where we used policy 
\begin_inset Formula $\theta^{q}$
\end_inset

 for period 
\begin_inset Formula $t$
\end_inset

 choices.
 Next we substitute 
\begin_inset Formula $K_{t+1}$
\end_inset

 into the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Euler_BM"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and compute period 
\begin_inset Formula $t+1$
\end_inset

 consumption 
\begin_inset Formula $\hat{C}\left(\hat{K}_{t+1};\theta^{p}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Finally we multiply both sides of the equation with 
\begin_inset Formula $\hat{C}\left(K_{t};\theta^{q}\right)$
\end_inset

 to normalize the Euler residuals
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This scaling ensures that errors are more equally distributed.
 If we would not normalize the Euler residuals the errors in consumption
 would be larger for high levels of consumption, due to the risk aversion
 of the agent.
\end_layout

\end_inset

.
 The Euler residuals 
\begin_inset Formula $R$
\end_inset

 are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(K_{t};\theta\right) & =\beta\frac{\hat{C}\left(K_{t};\theta^{q}\right)}{\hat{C}\left(\hat{K}_{t+1};\theta^{p}\right)}\alpha\hat{K}_{t+1}^{\alpha-1}-1\label{eq:BM_res_func}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Note that we use parameterization 
\begin_inset Formula $\theta^{q}$
\end_inset

 for period 
\begin_inset Formula $t$
\end_inset

 choices, and 
\begin_inset Formula $\theta^{p}$
\end_inset

 for period 
\begin_inset Formula $t+1$
\end_inset

 choices.
 This distinction is only relevant for algorithms using Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

).
 For the other algorithms these two parameterizations are the same, meaning
 
\begin_inset Formula $\theta^{q}=\theta^{p}$
\end_inset

.
 
\end_layout

\begin_layout Section
Basic Procedure
\begin_inset CommandInset label
LatexCommand label
name "sec:BM_program"

\end_inset


\end_layout

\begin_layout Standard
To solve a model with the toolbox one needs to go through the 6 steps described
 above.
 In this section we describe these steps in the example code 
\family typewriter
main_det_bm_proj
\family default
 in the folder `PROMES_v05.0.0/Examples'.
 This file is a function, which includes all the subfunctions of the model.
 These subfunctions calculate the Euler residual (
\family typewriter
det_bm_res
\family default
), the steady state (
\family typewriter
det_bm_ss
\family default
) and auxiliary variables (
\family typewriter
det_bm_aux
\family default
)
\family typewriter
.

\family default
 Each of the 6 steps of the example program are described in the following
 Subsections.
 
\end_layout

\begin_layout Subsection*
Step 0: Matlab settings
\end_layout

\begin_layout Standard
Before running the example we set some general Matlab settings, and add
 the relevant folders of the toolbox to the searchpath.
\end_layout

\begin_layout Subsection*
Step 1: Initial block
\end_layout

\begin_layout Standard
The initial block consists of two substeps, which are shown in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_step1}
\end_layout

\end_inset

.
 In Step 1.A we set the parameters of the model, and in Step 1.B we solve
 the steady state
\begin_inset Foot
status open

\begin_layout Plain Layout
See Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Description-det-BM"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for the derivation of the steady state.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Step 1 \texttt{ main\_det\_bm\_proj}},label={pl:BM_step1}"
inline false
status open

\begin_layout Plain Layout

function main_det_bm_proj(sol_meth) 
\end_layout

\begin_layout Plain Layout

% Function gives projection solution for 
\end_layout

\begin_layout Plain Layout

% deterministic version of Brock-Mirman model, 
\end_layout

\begin_layout Plain Layout

% using default settings of Promes toolbox
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% STEP 1: INITIAL BLOCK 
\end_layout

\begin_layout Plain Layout

% STEP 1.A: Set parameters of the model 
\end_layout

\begin_layout Plain Layout

par.alpha 	= 0.33;	% production: K^alpha 
\end_layout

\begin_layout Plain Layout

par.beta	= 0.96;	% discount factor
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% STEP 1.B: Solve steady state 
\end_layout

\begin_layout Plain Layout

SS              = det_bm_ss(par);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Step 2: Construct the grid
\end_layout

\begin_layout Standard
The construction of the grid is shown in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_step2}
\end_layout

\end_inset

.
 In this step one needs to set the parameters of the grid, which is explained
 in more detail in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The first three inputs are set as fields in the temporary structure 
\begin_inset Formula $gin$
\end_inset

.
 These are the number of state variables 
\begin_inset Formula $n$
\end_inset

, and the lower bound and upper bound of the state variables, 
\begin_inset Formula $lb$
\end_inset

 and 
\begin_inset Formula $ub$
\end_inset

 respectively.
 When constructing the grid with 
\family typewriter
prepgrid
\family default
 one also needs to set the algorithm in 
\begin_inset Formula $POL.algo$
\end_inset

, because the algorithm determines the type of grid that is constructed.
 We use the default settings for each algorithm, but one can specify algorithm
 specific parameters in the optional field 
\begin_inset Formula $algo\textrm{\_}spec$
\end_inset

 (see for example Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-2:-Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Step 2 \texttt{ main\_det\_bm\_proj}},label={pl:BM_step2}"
inline false
status open

\begin_layout Plain Layout

%% STEP 2: Construct the grid 
\end_layout

\begin_layout Plain Layout

% STEP 2.A: Set parameters & bounds of grid, in log(K) 
\end_layout

\begin_layout Plain Layout

gin.nn 		= 1;% number of state variables 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Boundaries of grid at steady state +/- 20%:
\end_layout

\begin_layout Plain Layout

gin.lb(1)	= -0.2 + log(SS.Kss);% lower bound 
\end_layout

\begin_layout Plain Layout

gin.ub(1)	= 0.2 + log(SS.Kss);% upper bound
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% STEP 2.B: Choose algorithm: 
\end_layout

\begin_layout Plain Layout

% 'cheb_gal','cheb_tmi','cheb_mse' 
\end_layout

\begin_layout Plain Layout

% 'spl_tmi','spl_dir'                       
\end_layout

\begin_layout Plain Layout

% 'smol_tmi','smol_dir' 
\end_layout

\begin_layout Plain Layout

% 'mono_mse' 
\end_layout

\begin_layout Plain Layout

POL.algo    = 'cheb_gal';
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% STEP 2.C: Construct the grid 
\end_layout

\begin_layout Plain Layout

% with default settings
\end_layout

\begin_layout Plain Layout

GRID 	= prepgrid(gin.nn,gin.lb,gin.ub,POL.algo); 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
prepgrid
\family default
 will assign all the necessary properties to the structure 
\begin_inset Formula $GRID$
\end_inset

, given the algorithm.
 The structure 
\begin_inset Formula $GRID$
\end_inset

 includes the initial grid 
\begin_inset Formula $xx$
\end_inset

, which is a 
\begin_inset Formula $m\times n$
\end_inset

 matrix, where every column is a state variable (or dimension), and every
 row a unique gridpoint.
 The explanation of the grid structure is found in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with an example in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Grid_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 It should be emphasized that the structure 
\begin_inset Formula $GRID$
\end_inset

 is specific for each algorithm.
 For example, a spline uses equidistant nodes, while complete Chebyshev
 polynomials use Chebyshev nodes.
 For polynomials the structure 
\begin_inset Formula $GRID$
\end_inset

 also includes the polynomial of the initial grid.
\end_layout

\begin_layout Subsection*
Step 3: Model function
\end_layout

\begin_layout Standard
The model function should calculate the Euler residuals, given the initial
 grid and the policy function.
 The model is shown in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_mod}
\end_layout

\end_inset

.
 The file takes the structure with the parameters 
\begin_inset Formula $par$
\end_inset

, the grid structure 
\begin_inset Formula $GRID$
\end_inset

, and the policy structure 
\begin_inset Formula $POL$
\end_inset

 as input arguments.
 Note that the modeler does not have to specify the policy function in the
 model file, because the function 
\family typewriter
solve_proj
\family default
 will assign the appropriate policy function (a spline or polynomial) to
 the structure 
\begin_inset Formula $POL$
\end_inset

.
 More details on constructing a model file can be found in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Model-file"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
First the model function retrieves the state variable capital in logs 
\begin_inset Formula $k_{t}$
\end_inset

, which is 
\begin_inset Formula $LK$
\end_inset

 in the code.
 Since there is only one state variable, it is the first and only column
 of the initial grid 
\begin_inset Formula $GRID.xx$
\end_inset

, as shown in Line 5.
 Next we evaluate the policy function given the state variable: 
\begin_inset Formula $\hat{c}_{t}=c\left(k_{t};\theta\right)$
\end_inset

.
 For all algorithms except those using Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) the policy function is evaluated by calling the function 
\family typewriter
get_pol_var
\family default
 as shown in Line 13 of Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_mod}
\end_layout

\end_inset

.
 This call takes the policy function 
\begin_inset Formula $POL$
\end_inset

, the state variable in period 
\begin_inset Formula $t$
\end_inset

 (
\begin_inset Formula $LK$
\end_inset

) and the structure 
\begin_inset Formula $GRID$
\end_inset

 as inputs.
 For the solution method
\family typewriter
 
\family default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 the solver directly sets the policy function 
\begin_inset Formula $c_{t}^{i}$
\end_inset

 at all gridpoints 
\begin_inset Formula $i$
\end_inset

.
 These values are assigned to 
\begin_inset Formula $POL.YY$
\end_inset

 as shown in Line 18.
\end_layout

\begin_layout Standard
Next we calculate 
\begin_inset Formula $k_{t+1}$
\end_inset

, given 
\begin_inset Formula $k_{t}$
\end_inset

 and 
\begin_inset Formula $\hat{c}_{t}$
\end_inset

 as in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM_alm_k_pol"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (Line 22), and finally we need to calculate 
\begin_inset Formula $\hat{c}_{t+1}=c\left(k_{t+1};\theta\right)$
\end_inset

.
 For all algorithms except those with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 we evaluate the policy function using the function 
\family typewriter
get_pol_var
\family default
 with 
\begin_inset Formula $k_{t+1}$
\end_inset

 as input argument (Line 29).
 For the solution method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 we need to use the policy function of the old iteration 
\begin_inset Formula $\theta^{p}$
\end_inset

.
 To ensure the old policy function is used for next period's choices the
 input argument 
\begin_inset Formula $spec\textrm{\_}opt$
\end_inset

 has to be set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'old_pol'}
\end_layout

\end_inset

 (Line 33 and 34).
 With 
\begin_inset Formula $\hat{c}_{t}$
\end_inset

, 
\begin_inset Formula $\hat{c}_{t+1}$
\end_inset

 and 
\begin_inset Formula $\hat{k}_{t+1}$
\end_inset

 known we can compute the vector of Euler residuals as in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM_res_func"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (Lines 38, 41, and 44).
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Model function \texttt{main\_det\_bm\_proj}},label={pl:BM_mod}"
inline false
status open

\begin_layout Plain Layout

%% Deterministic B-M model file, or residual function: 
\end_layout

\begin_layout Plain Layout

function [RES] = det_bm_res(par,GRID,POL)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Initial grid is stored in GRID.xx: 
\end_layout

\begin_layout Plain Layout

LK = GRID.xx;%log(K_t)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Evaluate the policy function log(C):
\end_layout

\begin_layout Plain Layout

if ~(strcmp(POL.algo,'spl_tmi') || ...
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'smol_tmi') || ...
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'cheb_tmi'))   
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  % standard: log(C) from policy function     
\end_layout

\begin_layout Plain Layout

  LC = get_pol_var(POL,LK,GRID); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

else     
\end_layout

\begin_layout Plain Layout

  %tmi: solver directly sets log(C) 
\end_layout

\begin_layout Plain Layout

  % at grid points 
\end_layout

\begin_layout Plain Layout

  LC = POL.YY; 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Capital in next period (log):  
\end_layout

\begin_layout Plain Layout

LK_n = log( exp(par.alpha*LK) - exp(LC) );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% log(C_t+1) from policy function, given log(K_t+1):  
\end_layout

\begin_layout Plain Layout

if ~(strcmp(POL.algo,'spl_tmi') || ...
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'smol_tmi') || ...
     
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'cheb_tmi')) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  LC_n = get_pol_var(POL,LK_n,GRID);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

else% for 'tmi':     	
\end_layout

\begin_layout Plain Layout

  % use old policy function    	
\end_layout

\begin_layout Plain Layout

  spec_opt_next = 'old_pol';  	
\end_layout

\begin_layout Plain Layout

  LC_n = get_pol_var(POL,LK_n,GRID,[],spec_opt_next);  
\end_layout

\begin_layout Plain Layout

end 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% log(RR_t+1): marginal prod.
 of capital (logs) 
\end_layout

\begin_layout Plain Layout

LR_n = log(par.alpha) + (par.alpha-1)*LK_n;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% RHS of Euler equation: 
\end_layout

\begin_layout Plain Layout

RHS         = par.beta * exp(-LC_n) .* exp(LR_n);     
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Euler residual (scaled by C^-1):
\end_layout

\begin_layout Plain Layout

RES         = exp(LC).*RHS - 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, we need to create a function handle to the model function, which
 takes the structure 
\begin_inset Formula $POL$
\end_inset

 as input argument:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Create function handle},label={pl:BM_step3}"
inline false
status open

\begin_layout Plain Layout

%% STEP 3: Handle for objective function  
\end_layout

\begin_layout Plain Layout

% (ie.
 the model file)  
\end_layout

\begin_layout Plain Layout

fun_res     = @(POL)det_bm_res(par,GRID,POL);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
This function handle is used as input for the solver 
\family typewriter
solve_proj
\family default
.
 The function 
\family typewriter
solve_proj
\family default
 will assign the policy function to the structure 
\begin_inset Formula $POL$
\end_inset

.
\end_layout

\begin_layout Subsection*
Step 4: Initial guess
\end_layout

\begin_layout Standard
The initial guess 
\begin_inset Formula $Y0$
\end_inset

 for the policy function should give the value of the policy variable at
 the initial grid.
 This initial guess is an input argument for the solver 
\family typewriter
solve_proj
\family default
.
 For this simple model all algorithms will converge to the correct solution
 from a relatively poor initial guess.
 As the initial guess we use steady state consumption plus a small linear
 term in capital:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% STEP 4: Initial guess policy function of log(c) 
\end_layout

\begin_layout Plain Layout

% steady state consumption +  small linear term in [log(K)-log(Kss)]:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Y0      = log(SS.Css) + 0.01*(GRID.xx-log(SS.Kss));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
For more complex models one could use the perturbation solution as initial
 guess.
 Initial guesses are discussed in more detail in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-4:-Initial"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection*
Step 5: Solve the model
\end_layout

\begin_layout Standard
To solve the model the function 
\family typewriter
solve_proj
\family default
 is called.
 It takes as inputs the grid structure 
\begin_inset Formula $GRID$
\end_inset

, the policy structure 
\begin_inset Formula $POL$
\end_inset

, the function handle to the residual function 
\begin_inset Formula $fun\textrm{\_}res$
\end_inset

, and the initial guess 
\begin_inset Formula $Y0$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%%% STEP 5: Solve the model 
\end_layout

\begin_layout Plain Layout

POL         = solve_proj(GRID,POL,fun_res,Y0); 
\end_layout

\begin_layout Plain Layout

clear Y0;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The structure 
\begin_inset Formula $POL$
\end_inset

 at this points only needs to contains the algorithm in the field 
\begin_inset Formula $POL.algo$
\end_inset

.
 The function 
\family typewriter
solve_proj
\family default
 will assign the appropriate policy function (spline or polynomial) to the
 structure 
\begin_inset Formula $POL$
\end_inset

.
 For the polynomial algorithms this will be the coefficients in the field
 
\begin_inset Formula $POL.theta$
\end_inset

.
 For the spline algorithms the policy function is assigned to the field
 
\begin_inset Formula $POL.pp\textrm{\_}y$
\end_inset

.
 The spline 
\begin_inset Formula $pp\textrm{\_}y$
\end_inset

 is constructed with Matlab's 
\family typewriter
griddedInterpolant
\family default
.
 
\end_layout

\begin_layout Subsection*
Step 6: Evaluate the solution
\end_layout

\begin_layout Standard
To evaluate the solution we call the function 
\family typewriter
get_pol_var
\family default
 with inputs 
\begin_inset Formula $POL$
\end_inset

, the state variables, and the structure 
\begin_inset Formula $GRID$
\end_inset

.
 In the example file we evaluate the policy at the initial grid:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% STEP 6: Evaluate policy function: 
\end_layout

\begin_layout Plain Layout

LK = GRID.xx; % = initial grid 
\end_layout

\begin_layout Plain Layout

LC = get_pol_var(POL,LK,GRID);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-6:-Evaluating"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we give an example of a simulation where 
\family typewriter
get_pol_var
\family default
 is used to evaluate the policy function.
\end_layout

\begin_layout Standard
In our example we also plot the policy function.
 In addition we plot the error, which is the difference between the numerical
 solution 
\begin_inset Formula $\hat{c}\left(k_{t};\theta\right)$
\end_inset

 and analytical solution 
\begin_inset Formula $c\left(k_{t}\right)$
\end_inset

.
 The maximum absolute errors are small, and range between the order 
\begin_inset Formula $10^{-7}$
\end_inset

 to 
\begin_inset Formula $10^{-13}$
\end_inset

 with the default settings.
 Smaller errors can be achieved by changing the stopping criteria as explained
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-5:-Solving"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Chapter
Detailed Procedure
\begin_inset CommandInset label
LatexCommand label
name "chap:RBC-example"

\end_inset


\end_layout

\begin_layout Standard
In this Chapter we discuss the procedure to solve a model in more detail.
 We use the example of a standard RBC model with stochastic shocks in Total
 Factor Productivity, which we call the ‘Standard RBC example’.
 We first briefly describe the model in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:RBC_Model"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The main program is the script 
\family typewriter
main_stnd_rbc_proj
\family default
 in the folder `PROMES_v05.0.0/Examples'.
 That script solves the model, and simulates time series.
 All model specific function are found in the subfolder `STND_RBC_mod'.
 Each step in the process is described in more detail in Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-1:-Initialization"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-6:-Evaluating"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Standard RBC model
\begin_inset CommandInset label
LatexCommand label
name "sec:RBC_Model"

\end_inset


\end_layout

\begin_layout Standard
The model consists of two state variables, capital 
\begin_inset Formula $K_{t}$
\end_inset

 and Total Factor Productivity (TFP) 
\begin_inset Formula $Z_{t}$
\end_inset

.
 Capital is determined endogenously, while TFP follows a stochastic process.
 We choose consumption 
\begin_inset Formula $C_{t}$
\end_inset

 as policy variable, which we approximate as a function of the state variables.
 The model is captured by four equations
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Standard_RBC_model"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details.
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{t}+K_{t+1} & =Z_{t}K_{t}^{\alpha}H_{t}^{1-\alpha}+\left(1-\delta\right)K_{t}\label{eq:ALM_k}\\
\chi H_{t}^{\frac{1}{\eta}} & =C_{t}^{-\nu}Z_{t}\left(1-\alpha\right)K_{t}^{\alpha}H_{t}^{-\alpha}\label{eq:lab_sup}\\
C_{t}^{-\nu} & =\beta E_{t}\left\{ C_{t+1}^{-\nu}\left[Z_{t+1}\alpha K_{t+1}^{\alpha-1}H_{t+1}^{1-\alpha}+1-\delta\right]\right\} \label{eq:RBC_Euler}\\
z_{t} & =\rho_{z}z_{t-1}+\sigma_{z}\epsilon_{t}\label{eq:TFP}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where smaller cases indicate logs, ie.
 
\begin_inset Formula $z_{t}=\log\left(Z_{t}\right)$
\end_inset

.
 The autocorrelation coefficient is 
\begin_inset Formula $\rho_{z}$
\end_inset

 , and the shocks are scaled by 
\begin_inset Formula $\sigma_{z}$
\end_inset

.
 The shocks are standard normally distributed, ie.
 
\begin_inset Formula $\epsilon_{t}\sim\mathcal{N}\left(0,1\right)$
\end_inset

.
\end_layout

\begin_layout Section
Step 0: Matlab Settings
\end_layout

\begin_layout Standard
The only function of Step 0 is to prepare Matlab for running the script.
 It includes clearing all variables in the workspace, and adding folders
 to the searchpath.
\end_layout

\begin_layout Subsubsection*
Clearing and set breakpoint
\end_layout

\begin_layout Standard
When using a script you typically want to clear all variables from the workspace
 using 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{clearvars}
\end_layout

\end_inset

, which is not needed if a function is used.
 In the initial block of our program we close all figures (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{close all}
\end_layout

\end_inset

), clear the command prompt (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{clc}
\end_layout

\end_inset

), and ensure that we can access all local variables at the time an error
 occurs by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{dbstop if error}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Adding folders
\end_layout

\begin_layout Standard
Next, we need to add the folders `PROMES_v05.0.0', and its subfolders `grid_subfun
', and `smolyak_subfun' to the searchpath.
 In addition we add the folder `TOOLS' and its subfolders `CSD_v02.4.0' and
 `CSD_v02.4.0
\backslash
subfun' to the searchpath.
 We need the folder `TOOLS' for the calculation of the Gauss-Hermite nodes
 with the function
\family typewriter
 hernodes
\family default
.
 We need the `CSD_v02.4.0' folders to obtain the perturbation solution with
 the 
\family typewriter
CSD
\family default
 toolbox.
\end_layout

\begin_layout Standard
Our model specific files are stored in the folder `PROMES_v05.0.0
\backslash
Examples
\backslash
STND_RBC_mod'.
 These files include the model function 
\family typewriter
STND_RBC_proj
\family default
.
 The other relevant subfunctions of this model are 
\family typewriter
stnd_rbc_ss
\family default
 which calculates the steady state, 
\family typewriter
stnd_rbc_aux
\family default
 which calculates auxiliary variables of the model, and 
\family typewriter
stnd_rbc_sim
\family default
 which is used to run simulations.
 
\end_layout

\begin_layout Standard
In our main program file 
\family typewriter
main_stnd_rbc_proj
\family default
 Step 0 is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% Solves standard RBC model with projection 
\end_layout

\begin_layout Plain Layout

% for a single variable policy function 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% STEP 0: Matlab settings
\end_layout

\begin_layout Plain Layout

clearvars; 
\end_layout

\begin_layout Plain Layout

close all; %close all figures 
\end_layout

\begin_layout Plain Layout

clc; %clear command prompt 
\end_layout

\begin_layout Plain Layout

dbstop if error;%acces workspace if error
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

restoredefaultpath; 
\end_layout

\begin_layout Plain Layout

clear RESTOREDEFAULTPATH_EXECUTED;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Add relevant folders of Promes toolbox: 
\end_layout

\begin_layout Plain Layout

addpath ('..'); 
\end_layout

\begin_layout Plain Layout

addpath ('..
\backslash
grid_subfun'); 
\end_layout

\begin_layout Plain Layout

addpath ('..
\backslash
smolyak_subfun');
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Add relevant folders of TOOLS 
\end_layout

\begin_layout Plain Layout

addpath ('..
\backslash
..
\backslash
TOOLS'); 
\end_layout

\begin_layout Plain Layout

addpath ('..
\backslash
..
\backslash
TOOLS
\backslash
CSD_v02.4.0'); 
\end_layout

\begin_layout Plain Layout

addpath ('..
\backslash
..
\backslash
TOOLS
\backslash
CSD_v02.4.0
\backslash
subfun');
\end_layout

\end_inset


\end_layout

\begin_layout Section
Step 1: Initial Block
\begin_inset CommandInset label
LatexCommand label
name "sec:Step-1:-Initialization"

\end_inset


\end_layout

\begin_layout Standard
The Initial Block consists of two parts:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{enumerate}[label=
\backslash
Alph*.] 
\end_layout

\begin_layout Plain Layout


\backslash
item Set parameters
\end_layout

\begin_layout Plain Layout


\backslash
item Solve steady state
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
In our function 
\family typewriter
main_stnd_rbc_proj
\family default
 we store all parameters in a structure called 
\begin_inset Formula $par$
\end_inset

.
 The steady state values are stored in a structure 
\begin_inset Formula $SS$
\end_inset

.
 The structure 
\begin_inset Formula $SS$
\end_inset

 is used for the determination of the lower and upper bound of the capital
 stock, the initialization of the policy function, and the function that
 plots the policy function.
\end_layout

\begin_layout Subsection*
Step 1.A: Set parameters
\end_layout

\begin_layout Standard
We assign all the parameters of the model to the structure 
\begin_inset Formula $par$
\end_inset

.
 Using this structure as input argument of a function gives access to all
 parameters of the model.
 In our example we will use Gauss-Hermite quadrature 
\begin_inset CommandInset citation
LatexCommand citep
before "see the chapter on Numerical Integration in"
key "judd1998numerical"
literal "false"

\end_inset

, and we add the Gauss-Hermite nodes (
\begin_inset Formula $par.her.xi$
\end_inset

) and its weights (
\begin_inset Formula $par.her.wi$
\end_inset

) to the parameters.
\end_layout

\begin_layout Standard
In our example script 
\family typewriter
main_stnd_rbc_proj
\family default
 Step 1.A is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% STEP 1.A: Set parameters of the model 
\end_layout

\begin_layout Plain Layout

par.alpha       = 0.36;		%capital share income  
\end_layout

\begin_layout Plain Layout

par.beta        = 0.985;	% discount factor 
\end_layout

\begin_layout Plain Layout

par.delta       = 0.025;	% deprec.
 of capital  
\end_layout

\begin_layout Plain Layout

par.nu          = 2; 		% risk aversion  
\end_layout

\begin_layout Plain Layout

par.eta         = 4; 		% el.
 of lab.
 supply 
\end_layout

\begin_layout Plain Layout

par.chi         = 1; 		% scalar disut.
 work
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

par.rho_z       = 0.95;	% autocorr.
 coeff.
 TFP 
\end_layout

\begin_layout Plain Layout

par.sigma_z     = 0.01;	% standard dev.
 shocks in TFP 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

par.her.gh_nod  = 5;% number of Gauss-Hermite nodes 
\end_layout

\begin_layout Plain Layout

[par.her.xi,par.her.wi] = hernodes(par.her.gh_nod); 
\end_layout

\begin_layout Plain Layout

% xi are roots, wi are weights
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Step 1.B: Solve steady state
\end_layout

\begin_layout Standard
We want a good approximation of the policy function on a particular interval
 of the state variables, which is usually centered around the steady state.
 For this reason we compute the steady state.
 For our Standard RBC example we created the function 
\family typewriter
stnd_rbc_ss
\family default
 that calculates the steady state analytically (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:RBC_steady-state"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 This function takes the parameters and the steady state Total Factor Productivi
ty (
\begin_inset Formula $Z_{ss}=1$
\end_inset

) as inputs.
 In the script 
\family typewriter
main_stnd_rbc_proj 
\family default
our call to the steady state function is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% STEP 1.B: Solve steady state 
\end_layout

\begin_layout Plain Layout

SS              = stnd_rbc_ss(par,1);
\end_layout

\begin_layout Plain Layout

% the 1 is steady state TFP 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Step 2: Construct the grid
\begin_inset CommandInset label
LatexCommand label
name "sec:Step-2:-Grid"

\end_inset


\end_layout

\begin_layout Standard
The construction of the grid is done using the following substeps:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{enumerate}[label=
\backslash
Alph*.] 
\end_layout

\begin_layout Plain Layout


\backslash
item Set basic grid parameters 
\end_layout

\begin_layout Plain Layout


\backslash
item Set algorithm 
\backslash
& algorithm specific parameters
\end_layout

\begin_layout Plain Layout


\backslash
item Construct grid
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The grid parameters, and also the grid itself will be stored in the structure
 
\begin_inset Formula $GRID$
\end_inset

.
 In Step 2.A three basic parameters of the grid need to be set.
 The algorithm has to be assigned to the structure 
\begin_inset Formula $POL$
\end_inset

 in Step 2.B, before constructing the grid.
 In Step 2.B algorithm specific grid parameters can be set, such as the order
 of the polynomial or the number of nodes.
\end_layout

\begin_layout Standard
These inputs are fed into the function 
\family typewriter
prepgrid
\family default
 (Step 2.C).
 This function constructs the structure 
\begin_inset Formula $GRID$
\end_inset

, and assigns all the required fields of the selected algorithm.
 More details on how the grid is constructed can be found in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 That chapter also includes an example code, 
\family typewriter
grid_example
\family default
, that demonstrates the construction of a grid.
\end_layout

\begin_layout Subsection*
Step 2.A: Set basic grid parameters
\end_layout

\begin_layout Standard
The 
\family typewriter
prepgrid
\family default
 function has the following inputs: 
\end_layout

\begin_layout Itemize
\begin_inset Formula $nn$
\end_inset

: number of variables in the grid (scalar);
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

: vector of lower bounds in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

: vector of upper bounds in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $algo$
\end_inset

: the algorithm, which is discussed in Step 2.B.
\end_layout

\begin_layout Itemize
\begin_inset Formula $algo\textrm{\_}spec$
\end_inset

 (optional): algorithm specific grid parameters
\end_layout

\begin_layout Standard
The first four inputs are necessary to create the structure 
\begin_inset Formula $GRID$
\end_inset

.
 In our model we have two state variables, capital (
\begin_inset Formula $K$
\end_inset

) and Total Factor Productivity (
\begin_inset Formula $Z$
\end_inset

).
 For the construction of the grid we use the logarithm of both variables.
 We set the lower and upper bound for each state variable symmetrically
 around this steady state.
 For capital we use the steady state in logs 
\begin_inset Formula $\pm$
\end_inset

0.1275, and for Total Factor Productivity we use 2.6 standard deviations around
 steady state.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% STEP 2: Construct the grid 
\end_layout

\begin_layout Plain Layout

%Step 2.A: Initialize the grid  
\end_layout

\begin_layout Plain Layout

gin.nn      = 2;%number of state variables (K,Z)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Set lower and upper bound for capital: 
\end_layout

\begin_layout Plain Layout

gin.lk_dev  = 0.1275;% deviation from kss 
\end_layout

\begin_layout Plain Layout

gin.lb(1)   = -gin.lk_dev + log(SS.kss);  
\end_layout

\begin_layout Plain Layout

gin.ub(1)   =  gin.lk_dev + log(SS.kss);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Set lower and upper bound for log(z)  
\end_layout

\begin_layout Plain Layout

gin.lz_fac  = 2.6;%in multiple of stnd.
 deviation 
\end_layout

\begin_layout Plain Layout

gin.lb(2)   = -gin.lz_fac*...
\end_layout

\begin_layout Plain Layout

	sqrt( par.sigma_z^2 / (1-par.rho_z^2) );  
\end_layout

\begin_layout Plain Layout

gin.ub(2)   =  gin.lz_fac*...
\end_layout

\begin_layout Plain Layout

	sqrt( par.sigma_z^2 / (1-par.rho_z^2) );
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Step 2.B: Set algorithm
\begin_inset CommandInset label
LatexCommand label
name "subsec:Step-2B-Sol_meth"

\end_inset


\end_layout

\begin_layout Standard
The algorithm 
\begin_inset Formula $algo$
\end_inset

 is set as a field in the structure 
\begin_inset Formula $POL$
\end_inset

.
 One can choose from eight algorithms to approximate the policy function.
 The algorithms are discussed in more detail in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Specific-Algorithms"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The eight algorithms are based on four types of basis functions.
 These are splines, complete Chebyshev polynomials, Smolyak polynomials,
 and complete polynomials based on monomials.
 
\end_layout

\begin_layout Itemize
Splines: splines are used with the collocation projection condition.
 The objective is to set the residuals at each gridpoint to zero.
 The spline is defined by Matlab's 
\family typewriter
griddedInterpolant
\family default
.
 The interpolation method can be specified in the field 
\begin_inset Formula $POL.meth\textrm{\_}spl$
\end_inset

.
 The two available solution methods are Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_tmi'}
\end_layout

\end_inset

) and Direct Computation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_dir'}
\end_layout

\end_inset

);
\end_layout

\begin_layout Itemize
Complete Chebyshev polynomials: three algorithms are available.
 The first uses Galerkin's method (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

), which sets the residuals orthogonal to the polynomial terms.
 The second uses Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_tmi'}
\end_layout

\end_inset

) to solve the policy variable at the gridpoints, and fits a spline to these
 points.
 The third uses Minimization of the Squared Errors (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_mse'}
\end_layout

\end_inset

) to minimize the errors at the gridpoints;
\end_layout

\begin_layout Itemize
Smolyak polynomial: Smolyak's algorithm constructs a sparse grid, and sparse
 Chebyshev polynomial.
 The algorithm ensures that the number of nodes and coefficients grows only
 polynomially in the number of state variables, while the number of nodes
 grows exponentially for the other methods.
 The two available solution methods are Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_tmi'}
\end_layout

\end_inset

) and Direct Computation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_dir'}
\end_layout

\end_inset

);
\end_layout

\begin_layout Itemize
Monomial basis functions (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

): the coefficients of a complete polynomial are determined by Minimization
 of the Squared Errors of the residual function at the gridpoints.
\end_layout

\begin_layout Standard
In general 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_tmi'}
\end_layout

\end_inset

 is a very robust choice.
 For simple, well-behaved models 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

 is a good alternative.
 For a large number of state variables 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_tmi'}
\end_layout

\end_inset

 is advised.
 In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Specific-Algorithms"
plural "false"
caps "false"
noprefix "false"

\end_inset

 under Algorithms more details are discussed.
\end_layout

\begin_layout Standard
The input 
\begin_inset Formula $algo\textrm{\_}spec$
\end_inset

 of the function 
\family typewriter
prepgrid
\family default
 can be used to set algorithm specific grid parameters.
 These parameters are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $qq$
\end_inset

 (for all basis functions except Smolyak's algorithm): number of nodes in
 each dimension (
\begin_inset Formula $1\times nn$
\end_inset

 vector).
 This parameter allows for asymmetric grids with a different amount of gridpoint
s in each dimension;
\end_layout

\begin_layout Itemize
\begin_inset Formula $ord\textrm{\_}vec$
\end_inset

 (Chebyshev & monomials only): the order of the polynomial in each dimension
 (
\begin_inset Formula $1\times nn$
\end_inset

 vector).
 This parameter allows for asymmetric polynomials;
\end_layout

\begin_layout Itemize
\begin_inset Formula $mu\textrm{\_}vec$
\end_inset

 (Smolyak's algorithm only): the accuracy of the approximation in each dimension
 (
\begin_inset Formula $1\times nn$
\end_inset

 vector).
 This parameter allows for asymmetric grids and polynomials.
\end_layout

\begin_layout Subsubsection*
Example Standard RBC model
\end_layout

\begin_layout Standard
In our example we set 
\begin_inset Formula $POL.algo$
\end_inset

 to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

, but this can be set to any of the other algorithms.
 In our example 
\family typewriter
main_stnd_rbc_proj
\family default
 the code of Step 2.B is:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% STEP 2.B: Set algorithm:
\end_layout

\begin_layout Plain Layout

POL.algo    = 'cheb_gal';
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We set the following algorithm specific grid parameters:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% (OPTIONAL) Algorithm specific parameters 
\end_layout

\begin_layout Plain Layout

%CHEYBSHEV:
\end_layout

\begin_layout Plain Layout

if strncmp(POL.algo,'cheb',4)     
\end_layout

\begin_layout Plain Layout

  %order of polyn.
 in each dim.
     
\end_layout

\begin_layout Plain Layout

  algo_spec.ord_vec   = 5*ones(1,gin.nn);     
\end_layout

\begin_layout Plain Layout

  %# nodes in each dim.:     
\end_layout

\begin_layout Plain Layout

  algo_spec.qq        = POL.meth_spec.ord_vec+1; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%SPLINES:
\end_layout

\begin_layout Plain Layout

elseif strncmp(POL.algo,'spl',3)     
\end_layout

\begin_layout Plain Layout

  %# nodes in each dim.:     
\end_layout

\begin_layout Plain Layout

  algo_spec.qq        = 7*ones(1,gin.nn); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%SMOLYAK:
\end_layout

\begin_layout Plain Layout

elseif strncmp(POL.algo,'smol',4)     
\end_layout

\begin_layout Plain Layout

  %accuracy param.
 in each dim.:     
\end_layout

\begin_layout Plain Layout

  algo_spec.mu_vec    = 3*ones(1,gin.nn); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%MONOMIALS:
\end_layout

\begin_layout Plain Layout

elseif strncmp(POL.algo,'mono',4)     
\end_layout

\begin_layout Plain Layout

  %order of polyn.
 in each dim.:     
\end_layout

\begin_layout Plain Layout

  algo_spec.ord_vec   = 3*ones(1,gin.nn);     
\end_layout

\begin_layout Plain Layout

  %# nodes in each dim.:     
\end_layout

\begin_layout Plain Layout

  algo_spec.qq        = POL.meth_spec.ord_vec+1; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

else     
\end_layout

\begin_layout Plain Layout

  error('Invalid algo'); 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Step 2.C: Construct the grid
\end_layout

\begin_layout Standard
The construction of the grid is carried out by the function 
\family typewriter
prepgrid
\family default
, which requires at least four inputs.
 This function and all its subfunctions are explained in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Our call of the function 
\family typewriter
prepgrid
\family default
 is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% STEP 2.C: Construct the grid 
\end_layout

\begin_layout Plain Layout

GRID = prepgrid(gin.nn,gin.lb,gin.ub,POL.algo,algo_spec);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
prepgrid
\family default
 will assign all the necessary fields to the structure 
\begin_inset Formula $GRID$
\end_inset

.
 The most important of these is the initial grid 
\begin_inset Formula $GRID.xx$
\end_inset

, which is an 
\begin_inset Formula $m\times n$
\end_inset

 matrix, where 
\begin_inset Formula $m$
\end_inset

 is the total number of gridpoints, and 
\begin_inset Formula $n$
\end_inset

 the number of state variables.
 Each row is a unique gridpoint, and every column represents a state variable.
 The first column 
\begin_inset Formula $GRID.xx\left(:,1\right)$
\end_inset

 contains capital in logs, and the second 
\begin_inset Formula $GRID.xx\left(:,2\right)$
\end_inset

 Total Factor productivity in logs.
 For the polynomial algorithms also the polynomial of the initial grid will
 be assigned to either 
\begin_inset Formula $XX\textrm{\_}poly$
\end_inset

 (for monomials) or in scaled down variables to 
\begin_inset Formula $XX\textrm{\_}poly\textrm{\_}dw$
\end_inset

 (for Chebyshev and Smolyak algorithms).
\end_layout

\begin_layout Standard
It should be noted that the grid structure is specific to the algorithm.
 If one changes the algorithm a new grid structure should be constructed
 with 
\family typewriter
prepgrid
\family default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
To be more more precise, the grid is specific to the basis function, which
 is either a spline, a Chebyshev polynomial, a Smolyak polynomial, or based
 on monomials.
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Step 3: Model function and handle
\begin_inset CommandInset label
LatexCommand label
name "sec:Model_file"

\end_inset


\end_layout

\begin_layout Standard
Step 3 consists of two parts:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{enumerate}[label=
\backslash
Alph*.] 
\end_layout

\begin_layout Plain Layout


\backslash
item Program model function
\end_layout

\begin_layout Plain Layout


\backslash
item Create handle to model function
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The creation of the model function is the crucial step.
 The model function should return a column vector with residuals as output.
 To solve the model with the solver 
\family typewriter
solve_proj
\family default
 a function handle of this model function has to be created.
 This function handle should take the structure 
\begin_inset Formula $POL$
\end_inset

 as input.
\end_layout

\begin_layout Subsection*
Step 3A: Program model function
\end_layout

\begin_layout Standard
The model function, which has to be programmed by the modeler, should calculate
 the Euler residuals at each gridpoint, given the policy function.
 It should be noted that the modeler does not have to specify the policy
 function.
 The toolbox will assign the policy function to 
\begin_inset Formula $POL$
\end_inset

.
 The model file should at least take the grid structure 
\begin_inset Formula $GRID$
\end_inset

, and the structure with the policy 
\begin_inset Formula $POL$
\end_inset

 as inputs.
 Other inputs are also allowed.
 In our example we use the structure with the parameters 
\begin_inset Formula $par$
\end_inset

 as additional input.
 
\end_layout

\begin_layout Standard
For the Standard RBC model the model function is 
\family typewriter
STND_RBC_proj
\family default
, which is shown in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

.
 This file is found in the subfolder `STND_RBC_mod'.
 The output are the residuals of the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC_Euler"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which are computed for a given policy function and initial grid.
 The code is explained further below.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Model function \texttt{STND\_RBC\_proj}},label={pl:RBC_mod}"
inline false
status open

\begin_layout Plain Layout

function [RES] = STND_RBC_proj(par,GRID,POL) 
\end_layout

\begin_layout Plain Layout

% Calculates Euler residuals for standard RBC model
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

LK = GRID.xx(:,1);%first state variable, log(K_t) 
\end_layout

\begin_layout Plain Layout

LZ = GRID.xx(:,2);%second state variable, log(Z_t)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%policy variable, log(C_t): 
\end_layout

\begin_layout Plain Layout

if ~(strcmp(POL.algo,'spl_tmi') || ...
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'smol_tmi') ||...
     
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'cheb_tmi') )          
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  %use initial grid for polynomials 
\end_layout

\begin_layout Plain Layout

  % (or ignore for spl_dir)   	
\end_layout

\begin_layout Plain Layout

  spec_opt  = 'ini_grid';         
\end_layout

\begin_layout Plain Layout

  LC  = get_pol_var(POL,[LK,LZ],GRID,[],spec_opt);
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

else%for 'spl_tmi','cheb_tmi','smol_tmi': 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  %LC is set directly for Time Iteration
\end_layout

\begin_layout Plain Layout

  LC  = POL.YY; 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Capital in next period: 
\end_layout

\begin_layout Plain Layout

LK_n    = stnd_rbc_aux(par,LK,LZ,LC);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if strcmp(POL.algo,'spl_tmi') || ...
 	
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'smol_tmi') ||...
 	
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'cheb_tmi')      
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  % use old policy function in t+1
\end_layout

\begin_layout Plain Layout

  % for Time Iteration     
\end_layout

\begin_layout Plain Layout

  % (pp_y_old or theta_old)       
\end_layout

\begin_layout Plain Layout

  spec_opt_next = 'old_pol'; 
\end_layout

\begin_layout Plain Layout

else     
\end_layout

\begin_layout Plain Layout

  spec_opt_next = []; 
\end_layout

\begin_layout Plain Layout

end       
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Allocate empty matrix for RHS of Euler equation: 
\end_layout

\begin_layout Plain Layout

rhs_l   = NaN(size(LK,1),par.her.gh_nod); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for ll = 1:par.her.gh_nod     
\end_layout

\begin_layout Plain Layout

  % Shock to TFP (using Gauss-Hermite nodes):     
\end_layout

\begin_layout Plain Layout

  EPS_n       = sqrt(2)*par.her.xi(ll); 
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

  %log(Z_t+1):     
\end_layout

\begin_layout Plain Layout

  LZ_n        = par.rho_z*LZ + par.sigma_z*EPS_n;          
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  %log(C_t+1)     
\end_layout

\begin_layout Plain Layout

  LC_n        = get_pol_var(POL,[LK_n,LZ_n],GRID,[],spec_opt_next);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  %log(MPK_t+1) (marginal prod.
 of capital)     
\end_layout

\begin_layout Plain Layout

  [~,LMPK_n]    = stnd_rbc_aux(par,LK_n,LZ_n,LC_n);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  % RHS of Euler equation,      
\end_layout

\begin_layout Plain Layout

  % weighted by Gauss-Hermite weights     
\end_layout

\begin_layout Plain Layout

  rhs_l(:,ll) = par.her.wi(ll)/sqrt(pi)*par.beta*...
\end_layout

\begin_layout Plain Layout

	exp(-par.nu*LC_n) .* ...
\end_layout

\begin_layout Plain Layout

	(exp(LMPK_n)+1 - par.delta); 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Right hand side of Euler equation: 
\end_layout

\begin_layout Plain Layout

RHS = sum(rhs_l,2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Euler residuals (scaled by C^-nu): 
\end_layout

\begin_layout Plain Layout

RES     =  RHS./exp(-par.nu *LC) - 1;    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Evaluating the policy function 
\end_layout

\begin_layout Standard
In our code the policy and state variables are all defined in logs.
 The policy function is 
\begin_inset Formula $\hat{c}=\hat{c}\left(k,z;\theta\right)$
\end_inset

, where small cases indicate logs.
 For simplicity we ignore the log transformation, and write 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\hat{C}\left(K,Z;\theta\right)=\exp\left[\hat{c}\left(k,z;\theta\right)\right]$
\end_inset

.
 
\end_layout

\begin_layout Standard
To evaluate the policy function we differentiate between the solution method
 Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

) and the other solution methods (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Model-file"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more details).
 In period 
\begin_inset Formula $t$
\end_inset

 the policy variable is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{C}_{t} & =\begin{cases}
\hat{C}_{t}^{j} & \textrm{if sol. meth. is `tmi'}\\
\hat{C}\left(K_{t},Z_{t};\theta\right) & \textrm{else}
\end{cases}\label{eq:RBC_Ct_approx}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\hat{C}_{t}^{j}$
\end_inset

 is the solution at the initial grid 
\begin_inset Formula $GRID.xx$
\end_inset

.
 These values are assigned to 
\begin_inset Formula $POL.YY$
\end_inset

 by the 
\family typewriter
solve_proj
\family default
, and can be evaluated directly (Line 20).
\end_layout

\begin_layout Standard
For the other solution methods we explicitly evaluate the policy using 
\begin_inset Formula $GRID.xx$
\end_inset

, where the column vectors are capital and productivity (in logs) as shown
 in Line 4 and 5.
 For the algorithms using polynomials we save computation time by evaluating
 the period 
\begin_inset Formula $t$
\end_inset

 policy function with the polynomial of the initial grid.
 This is done by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt = 'ini_grid'}
\end_layout

\end_inset

 in Line 14.
 This option is ignored for the algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_dir'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To evaluate the policy function in period 
\begin_inset Formula $t+1$
\end_inset

 we use:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{C}_{t+1} & =\begin{cases}
\hat{C}\left(K_{t+1},Z_{t+1};\theta^{j-1}\right) & \textrm{if sol. meth. is `tmi'}\\
\hat{C}\left(K_{t+1},Z_{t+1};\theta\right) & \textrm{else}
\end{cases}\label{eq:RBC_Cn_approx}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
For Time Iteration we use the policy function of the previous iteration
 
\begin_inset Formula $\theta^{j-1}$
\end_inset

, which we achieve by setting 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt_next = 'old_pol'}
\end_layout

\end_inset

 when calling 
\family typewriter
get_pol_var
\family default
, as shown in Lines 34 and 50.
 For the other solution methods the field 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt_next'}
\end_layout

\end_inset

 is left empty (Line 36).
\end_layout

\begin_layout Standard
In what follows we ignore the differences in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC_Ct_approx"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC_Cn_approx"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and use the more general notation 
\begin_inset Formula $\hat{C}_{t}=\hat{C}\left(K_{t},Z_{t};\theta^{j}\right)$
\end_inset

 and 
\begin_inset Formula $\hat{C}_{t+1}=\hat{C}\left(K_{t+1},Z_{t+1};\theta^{j-1}\right)$
\end_inset

.
\end_layout

\begin_layout Subsection*
Auxiliary variables
\end_layout

\begin_layout Standard
In the model function we need to calculate the capital stock in the next
 period 
\begin_inset Formula $K_{t+1}$
\end_inset

, and the marginal productivity of capital 
\begin_inset Formula $MPK_{t}=\alpha K_{t}^{\alpha-1}H_{t}^{1-\alpha}$
\end_inset

, for a given state 
\begin_inset Formula $\left[K_{t},Z_{t}\right]$
\end_inset

 and consumption 
\begin_inset Formula $C_{t}$
\end_inset

.
 To obtain these variables we compute the labor supply.
 The labor supply 
\begin_inset Formula $H$
\end_inset

 is an explicit function of the state variables 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

, and consumption 
\begin_inset Formula $C$
\end_inset

:
\begin_inset Formula 
\begin{align}
H_{t} & =\left[\frac{1-\alpha}{\chi}C_{t}^{-\nu}Z_{t}K_{t}^{\alpha}\right]^{\frac{\eta}{1+\alpha\eta}}\nonumber \\
 & =H\left(K_{t},Z_{t},C_{t}\right)\label{eq:Lab_expr}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
After substituting out 
\begin_inset Formula $H_{t}$
\end_inset

 the capital stock in 
\begin_inset Formula $t+1$
\end_inset

 is a function of 
\begin_inset Formula $K_{t}$
\end_inset

, 
\begin_inset Formula $Z_{t}$
\end_inset

 and 
\begin_inset Formula $C_{t}$
\end_inset

 as well:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
K_{t+1} & =Z_{t}K_{t}^{\alpha}H\left(K_{t},Z_{t},C_{t}\right)^{1-\alpha}+\left(1-\delta\right)K_{t}-C_{t}\nonumber \\
 & =K\left(K_{t},Z_{t},C_{t}\right)\label{eq:Kn_expr}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
stnd_rbc_aux
\family default
 computes these three variables 
\begin_inset Formula $H_{t}$
\end_inset

, 
\begin_inset Formula $MPK_{t}$
\end_inset

 and 
\begin_inset Formula $K_{t+1}$
\end_inset

 (in logs):
\end_layout

\begin_layout Standard
\noindent
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

function [LK_n,LMPK,LH] = stnd_rbc_aux(par,LK,LZ,LC) 
\end_layout

\begin_layout Plain Layout

% Get log(K_t+1), log(MPK_t) and log(H_t) 
\end_layout

\begin_layout Plain Layout

% for standard RBC model
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Hours worked (in logs):
\end_layout

\begin_layout Plain Layout

LH = par.eta/(1+par.alpha*par.eta) * ...
\end_layout

\begin_layout Plain Layout

	( -log(par.chi) -par.nu*LC + ...
\end_layout

\begin_layout Plain Layout

	log(1-par.alpha) + LZ + par.alpha*LK );
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Marginal productivity of capital (in logs):
\end_layout

\begin_layout Plain Layout

LMPK = log(par.alpha) + LZ + (par.alpha-1)*(LK-LH);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Capital in next period (in logs):
\end_layout

\begin_layout Plain Layout

LK_n = log(exp(LZ + par.alpha*LK + (1-par.alpha)*LH)...
\end_layout

\begin_layout Plain Layout

	- exp(LC) + (1-par.delta)*exp(LK));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
This function is called twice in the model function.
 The first time to calculate 
\begin_inset Formula $K_{t+1}$
\end_inset

 in Line 24 of Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

, and a second time to calculate the marginal productivity in 
\begin_inset Formula $t+1$
\end_inset

 in Line 53.
\end_layout

\begin_layout Standard
Formally the approximation of the labor supply and capital stock in the
 next period are:
\begin_inset Formula 
\begin{align}
\hat{H}_{t} & =H\left(K_{t},Z_{t},\hat{C}\left(K_{t},Z_{t};\theta^{j}\right)\right)\label{eq:RBC_H_approx}\\
\hat{K}_{t+1} & =K\left(K_{t},Z_{t},\hat{C}\left(K_{t},Z_{t};\theta^{j}\right)\right)\label{eq:RBC_Kn_approx}
\end{align}

\end_inset


\end_layout

\begin_layout Subsection*
Expected value and Gauss-Hermite quadrature
\end_layout

\begin_layout Standard
Next we need to evaluate the right-hand side of the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC_Euler"
plural "false"
caps "false"
noprefix "false"

\end_inset

, which consists of time 
\begin_inset Formula $t+1$
\end_inset

 variables.
 Using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Lab_expr"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we define a function 
\begin_inset Formula $G$
\end_inset

 for the right-hand side of the Euler equation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
G\left(K_{t+1},Z_{t+1},C_{t+1}\right) & =\beta C_{t+1}^{-\nu}\left[Z_{t+1}\alpha K_{t+1}^{\alpha-1}H\left(K_{t+1},Z_{t+1},C_{t+1}\right)^{1-\alpha}+1-\delta\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The approximation of 
\begin_inset Formula $G$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{\Phi}\left(K_{t+1},Z_{t+1};\theta^{j-1}\right) & =G\left(K_{t+1},Z_{t+1},\hat{C}\left(K_{t+1},Z_{t+1};\theta^{j-1}\right)\right)\label{eq:RBC-appr_G}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The right-hand side of the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC_Euler"
plural "false"
caps "false"
noprefix "false"

\end_inset

 includes an expectation operator.
 We use Gauss-Hermite quadrature to approximate the expected value.
 Assume we have a function 
\begin_inset Formula $f\left(z_{t+1},x\right)$
\end_inset

 and 
\begin_inset Formula $z_{t+1}$
\end_inset

 is governed by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:TFP"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with standard normally distributed shocks 
\begin_inset Formula $\epsilon_{t+1}$
\end_inset

.
 The Gauss-Hermite approximation is then:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
E_{t}f\left(z_{t+1},x\right) & \approx\sum_{l=1}^{L}\frac{\omega_{l}}{\sqrt{\pi}}f\left(\rho_{z}z_{t}+\sigma_{z}\sqrt{2}\zeta_{l},x\right)\label{eq:GH_formula}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\zeta_{l}$
\end_inset

 are the Gauss-Hermite nodes, and 
\begin_inset Formula $\omega_{l}$
\end_inset

 are the Gauss-Hermite weights (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:RBC_quadrature"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for the derivation).
 
\end_layout

\begin_layout Standard
These nodes and weights were set in Step 1A of our code (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-1:-Initialization"
plural "false"
caps "false"
noprefix "false"

\end_inset

) as 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{par.her.xi(ll)}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{par.her.wi(ll)}
\end_layout

\end_inset

, respectively.
 
\end_layout

\begin_layout Standard
We use the Gauss-Hermite formula 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:GH_formula"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and capital in 
\begin_inset Formula $t+1$
\end_inset

 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC_Kn_approx"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to compute the approximation of the expected value of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC-appr_G"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{multline}
\Psi\left(K_{t},Z_{t};\theta\right)\approx E_{t}\left\{ \hat{\Phi}\left(K\left(K_{t},Z_{t},\hat{C}\left(K_{t},Z_{t};\theta^{j}\right)\right),Z_{t+1};\theta^{j-1}\right)\right\} \\
=\sum_{l=1}^{L}\frac{\omega_{l}}{\sqrt{\pi}}\hat{\Phi}\left(K\left(K_{t},Z_{t},\hat{C}\left(K_{t},Z_{t};\theta^{j}\right)\right),\exp\left(\rho_{z}\log\left(Z_{t}\right)+\sigma_{z}\sqrt{2}\zeta_{l}\right);\theta^{j-1}\right)\label{eq:RBC_Psi}
\end{multline}

\end_inset


\end_layout

\begin_layout Standard
In our code Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

 the Gauss-Hermite quadrature 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC_Psi"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is calculated as follows.
 We loop over the shocks and weights 
\begin_inset Formula $l$
\end_inset

 in Line 42 till 60.
 In Line 63 we sum over the nodes and weights to obtain the right-hand-side
 of the Euler equation.
\end_layout

\begin_layout Subsection*
Euler residuals
\end_layout

\begin_layout Standard
\noindent
After substituting 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC_Psi"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for the right-hand side of the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC_Euler"
plural "false"
caps "false"
noprefix "false"

\end_inset

 the residuals 
\begin_inset Formula $R$
\end_inset

 are a function that depends on 
\begin_inset Formula $K_{t}$
\end_inset

, 
\begin_inset Formula $Z_{t}$
\end_inset

 and the parameters 
\begin_inset Formula $\theta$
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(K_{t},Z_{t};\theta\right) & =\Psi\left(K_{t},Z_{t};\theta\right)/\hat{C}\left(K_{t},Z_{t};\theta^{j}\right)^{-\nu}-1\label{eq:RBC-RES}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
We have divided both sides of the Euler equation by 
\begin_inset Formula $\hat{C}{}_{t}^{-\nu}$
\end_inset

 to ensure that the approximation is good over the whole interval.
 Without this scaling the normalized Euler residuals will be larger for
 high levels of consumption.
 This is due to the risk aversion, which makes the absolute errors in equation
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:RBC_Euler"
plural "false"
caps "false"
noprefix "false"

\end_inset

 smaller for high levels of consumption.
\end_layout

\begin_layout Subsection*
Step 3B: Create function handle
\end_layout

\begin_layout Standard
The function handle of the model file needs to be passed as the argument
 
\begin_inset Formula $fun\textrm{\_}res$
\end_inset

 to the function 
\family typewriter
solve_proj
\family default
, which solves the model (see Step 5 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-5:-Solving"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 In our example we create the handle with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% STEP 3: Handle for objective function  
\end_layout

\begin_layout Plain Layout

% (ie.
 the model file)  
\end_layout

\begin_layout Plain Layout

fun_res     = @(POL)STND_RBC_proj(par,GRID,POL);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It should be noted that after a function handle has been created any changes
 to the inputs arguments (other than the variable 
\begin_inset Formula $POL$
\end_inset

) will 
\shape italic
not
\shape default
 change the function handle when it is called.
 For example in our program we created the function handle 
\begin_inset Formula $fun\textrm{\_}res$
\end_inset

.
 When we change 
\begin_inset Formula $par.alpha$
\end_inset

 to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{par.alpha = 0.5}
\end_layout

\end_inset

 after the handle has been created then the function handle 
\begin_inset Formula $fun\_res$
\end_inset

 will still use the original value 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{par.alpha = 0.36}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Step 4: Initial guess for the policy function
\begin_inset CommandInset label
LatexCommand label
name "sec:Step-4:-Initial"

\end_inset


\end_layout

\begin_layout Standard
The initial guess for the policy function 
\begin_inset Formula $Y0$
\end_inset

 should be the policy variable on the initial grid.
 The values 
\begin_inset Formula $Y0$
\end_inset

 are an input for the solver 
\family typewriter
solve_proj
\family default
:
\end_layout

\begin_layout Itemize
\begin_inset Formula $Y0$
\end_inset

: the initial value of the policy variable on the initial grid in 
\begin_inset Formula $GRID.xx$
\end_inset

.
\end_layout

\begin_layout Standard
Good starting values are valuable for two reasons.
 The first is that most algorithms are not guaranteed to find a solution,
 although Time Iteration should converge to the solution when the shape
 of the policy function is preserved sufficiently
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset

, page 554 and 555).
\end_layout

\end_inset

.
 The second reason is that good starting values will significantly reduce
 computation time.
\end_layout

\begin_layout Standard
There are four methods for the initialization of a policy function which
 usually ensure convergence:
\end_layout

\begin_layout Itemize
Perturbation methods;
\end_layout

\begin_layout Itemize
Gradually changing parameters;
\end_layout

\begin_layout Itemize
Gradually increasing the grid size;
\end_layout

\begin_layout Itemize
Increasing the order of the approximation.
\end_layout

\begin_layout Subsubsection*
Perturbation solution
\end_layout

\begin_layout Standard
For most models an initialization of the policy function using a linear
 perturbation solution will be sufficient for convergence.
 Perturbation solutions can be obtained easily as a wide range of software
 packages are available.
 In addition the computation time is relatively short, so perturbation methods
 are the natural choice for an initial guess.
 It should be noted that models featuring an attracting limit cycle can
 also be solved with perturbation methods 
\begin_inset CommandInset citation
LatexCommand citep
key "galizia2018saddle"
literal "false"

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The 
\family typewriter
CSD
\family default
 toolbox in the folder `TOOLS' can solve saddle cycle models.
 The essential part is the code 
\family typewriter
InvSubGen
\family default
 written by Dana Galizia.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
Gradually changing parameters
\end_layout

\begin_layout Standard
For some models we can easily obtain the solution by shutting a particular
 mechanism down, for example by setting a parameter to 0 or 1.
 A loop has to be added that gradually changes the parameter value.
\end_layout

\begin_layout Subsubsection*
Gradually increasing the size of the grid
\end_layout

\begin_layout Standard
It might be difficult to get a solution when the size of the grid is large.
 We could start with a small grid around the steady state such that a solution
 is found.
 The grid size can then be increased using a loop.
 Note that for Chebyshev polynomials (including Smolyak's algorithm) changing
 the boundaries affects the coefficients 
\begin_inset Formula $POL.theta$
\end_inset

, due to the scaling down of the variables to 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Increasing the accuracy of the approximation
\begin_inset CommandInset label
LatexCommand label
name "par:Increasing-accuracy"

\end_inset


\end_layout

\begin_layout Standard
We can increase the number of nodes or the order of polynomials in a multi-step
 approach.
 This is especially useful for the algorithms that rely on Chebyshev polynomials
, since the Chebyshev basis functions are orthogonal to each other.
 For example, 
\begin_inset CommandInset citation
LatexCommand citet
key "fernandez2016solution"
literal "false"

\end_inset

 use this approach.
\end_layout

\begin_layout Subsubsection*
Example Standard RBC model
\end_layout

\begin_layout Standard
In our example function 
\family typewriter
main_stnd_rbc_proj
\family default
 we initialize the policy function using the first order perturbation solution.
 The (log) linear perturbation solution is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\hat{c}\left(k_{t},z_{t}\right) & =\overline{c}+H_{y,k}\left(k_{t}-\overline{k}\right)+H_{y,z}\left(z_{t}-\overline{z}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The coefficient 
\begin_inset Formula $H_{y,k}$
\end_inset

 and 
\begin_inset Formula $H_{y,z}$
\end_inset

 are the first and second entry in 
\begin_inset Formula $PERT.Hy\textrm{\_}w$
\end_inset

 of our code.
 The initial guess for the policy function is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%Initial policy function (for given grid): 
\end_layout

\begin_layout Plain Layout

Y0 = log(SS.css) + ...
     
\end_layout

\begin_layout Plain Layout

	PERT.Hy_w(1,1)*(GRID.xx(:,1)-log(SS.kss)) + ...
     
\end_layout

\begin_layout Plain Layout

	PERT.Hy_w(1,2)*(GRID.xx(:,2)-log(SS.zss)); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have included two options to determine the coefficient in 
\begin_inset Formula $PERT.Hy\textrm{\_}w$
\end_inset

, which are chosen by setting 
\begin_inset Formula $par.opt.get\textrm{\_}pert\textrm{\_}sol$
\end_inset

 to either 0 or 1.
\end_layout

\begin_layout Standard
If 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{par.opt.get_pert_sol == 0}
\end_layout

\end_inset

 the initial guess is based on a poor estimation of the perturbation solution
 with 
\begin_inset Formula $Hy\textrm{\_}w=\left[0.25,0.25\right]$
\end_inset

, while the first order perturbation solution is 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Hy\textrm{\_}w=\left[0.3456,0.3525\right]$
\end_inset

.
 In our code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if par.opt.get_pert_sol == 0         
\end_layout

\begin_layout Plain Layout

  %Poor estimation:     
\end_layout

\begin_layout Plain Layout

  PERT.Hy_w = [0.25,0.25];
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{par.opt.get_pert_sol == 1}
\end_layout

\end_inset

 the program obtains the coefficients 
\begin_inset Formula $H_{y,k}$
\end_inset

 and 
\begin_inset Formula $H_{y,z}$
\end_inset

 by solving the model with perturbation techniques.
 In our code we obtain the first order perturbation solution using the 
\family typewriter
CSD
\family default
 toolbox, which is included in the folder `TOOLS'.
 One could calculate these coefficients with other software packages, such
 as 
\family typewriter
Dynare
\family default
.
 The model file for the perturbation solution is the function 
\family typewriter
STND_RBC_pert
\family default
 in the folder `Examples
\backslash
STND_RBC_mod'.
 
\end_layout

\begin_layout Standard
When this option is chosen the code executes:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

else% Solve model with perturbation 
\end_layout

\begin_layout Plain Layout

  % Symbolic model file: 
\end_layout

\begin_layout Plain Layout

  MOD = STND_RBC_pert;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  % Vector of parameters:     
\end_layout

\begin_layout Plain Layout

  MOD.par_val = [par.alpha,par.beta,...
         
\end_layout

\begin_layout Plain Layout

		par.delta,par.eta,par.nu,par.chi];     
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

  % Vector of steady states:     
\end_layout

\begin_layout Plain Layout

  MOD.SS_vec  = [log(SS.kss),log(SS.zss),log(SS.css)];     
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

  % Get solution:     
\end_layout

\begin_layout Plain Layout

  PERT = pert_ana_csd(MOD,par.rho_z,1,par.sigma_z); 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

  clear MOD; 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Section
Step 5: Solving the policy function
\begin_inset CommandInset label
LatexCommand label
name "sec:Step-5:-Solving"

\end_inset


\end_layout

\begin_layout Standard
The model is solved in Step 5.
 The function 
\family typewriter
solve_proj
\family default
 minimizes the Euler residuals, and will assign the optimal policy function
 to the structure 
\begin_inset Formula $POL$
\end_inset

.
 The function requires the inputs 
\begin_inset Formula $GRID$
\end_inset

, 
\begin_inset Formula $POL$
\end_inset

, the function handle of the model file 
\begin_inset Formula $fun\textrm{\_}res$
\end_inset

 , and the initial guess for the policy function 
\begin_inset Formula $Y0$
\end_inset

.
 In our example Step 5 is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% STEP 5: Solve the model 
\end_layout

\begin_layout Plain Layout

POL  = solve_proj(GRID,POL,fun_res,Y0);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
solve_proj
\family default
 internally assigns the policy function to 
\begin_inset Formula $POL$
\end_inset

.
 This policy function will be a spline or a polynomial depending on the
 algorithm.
 It uses an iterative scheme to find the policy function that minimizes
 the Euler residuals.
 
\end_layout

\begin_layout Standard
For all solution methods except Time Iteration we solve the objective function
 directly with either 
\family typewriter
fsolve
\family default
 or 
\family typewriter
lsqnonlin
\family default
 of the 
\family typewriter
Optimization Toolbox
\family default
.
 For Time Iteration an updating technique is used that is especially useful
 for recursive dynamic problems.
 More details on the algorithms can be found in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Specific-Algorithms"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection*
Optional: stopping criteria for solvers
\begin_inset CommandInset label
LatexCommand label
name "subsec:Stopping_criteria"

\end_inset


\end_layout

\begin_layout Standard
All algorithms use either 
\family typewriter
fsolve
\family default
 or 
\family typewriter
lsqnonlin
\family default
.
 The toolbox uses the default stopping criteria of these solvers, but they
 can be adjusted by setting the input 
\begin_inset Formula $options$
\end_inset

 of 
\family typewriter
solve_proj
\family default
 as shown below.
 When the solution method Time Iteration is used one can additionally adjust
 the tolerances 
\begin_inset Formula $res\textrm{\_}tol$
\end_inset

 and 
\begin_inset Formula $diff\textrm{\_}tol$
\end_inset

 (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Solving-the-model"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more details).
 In our example code one can choose the default accuracy by setting 
\begin_inset Formula $par.opt\textrm{\_}acc=%0
$
\end_inset

, or choose a higher accuracy by setting 
\begin_inset Formula $par.opt\textrm{\_}acc=%1
$
\end_inset

.
 The latter will reproduce the results in Table 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{table:res_rbc}
\end_layout

\end_inset

 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Performance_RBC"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%  (OPTIONAL) Set stopping criteria : 
\end_layout

\begin_layout Plain Layout

par.options = [];  
\end_layout

\begin_layout Plain Layout

par.opt_acc = 1;%0: default accuracy; 1: higher accuracy 
\end_layout

\begin_layout Plain Layout

if par.opt_acc == 1         
\end_layout

\begin_layout Plain Layout

  if strcmp(POL.algo,'spl_tmi') ||...
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'cheb_tmi') || ...
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'smol_tmi')         
\end_layout

\begin_layout Plain Layout

    % For Time Iteration:         
\end_layout

\begin_layout Plain Layout

    par.tmi_tol     = 1e-12;         
\end_layout

\begin_layout Plain Layout

    POL.res_tol 	= par.tmi_tol;     	
\end_layout

\begin_layout Plain Layout

    POL.diff_tol 	= par.tmi_tol;               
\end_layout

\begin_layout Plain Layout

  else         
\end_layout

\begin_layout Plain Layout

    par.tol = 1e-12;         
\end_layout

\begin_layout Plain Layout

    par.options.OptimalityTolerance = par.tol;  
\end_layout

\begin_layout Plain Layout

    par.options.FunctionTolerance = par.tol; 
\end_layout

\begin_layout Plain Layout

    par.options.StepTolerance = par.tol;   
\end_layout

\begin_layout Plain Layout

  end  
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Section
Step 6: Evaluating the policy function
\begin_inset CommandInset label
LatexCommand label
name "sec:Step-6:-Evaluating"

\end_inset


\end_layout

\begin_layout Standard
The policy function can be evaluated with the function 
\family typewriter
get_pol_var
\family default
, which we also used in the model function in Step 4.
 The input variables are the structure 
\begin_inset Formula $GRID$
\end_inset

, the policy function 
\begin_inset Formula $POL$
\end_inset

, and an 
\begin_inset Formula $m\times n$
\end_inset

 matrix with the state variables (
\begin_inset Formula $xx$
\end_inset

).
 Each of the 
\begin_inset Formula $n$
\end_inset

 column represents a state variable, and is 
\begin_inset Formula $m$
\end_inset

 is the number of data points.
 The output is the policy variable in a column vector (
\begin_inset Formula $m\times1$
\end_inset

).
\end_layout

\begin_layout Standard
In the script 
\family typewriter
main_stnd_rbc_proj
\family default
 we plot the policy function using the model specific plotting function
 
\family typewriter
plot_pol_stnd_rbc
\family default
.
 The graphs show that the approximated policy function is close to log linear,
 also outside the grid.
 
\end_layout

\begin_layout Standard
We also evaluate the policy function in a stochastic simulation.
 The simulation is carried out by the function 
\family typewriter
stnd_rbc_sim
\family default
.
 We call this function in the following block:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%% Step 6: Evaluate policy function (in simulation) 
\end_layout

\begin_layout Plain Layout

opt_sim.TT      = 1500; % # periods in simulation 
\end_layout

\begin_layout Plain Layout

opt_sim.T_ini   = 10;   % ini.
 periods at steady state 
\end_layout

\begin_layout Plain Layout

opt_sim.rws     = 2;   % number of simulated series
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[SIM] = stnd_rbc_sim(par,SS,POL,GRID,opt_sim); 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this code 
\begin_inset Formula $opt\_sim$
\end_inset

 is a structure which sets the number of periods in the simulation (
\begin_inset Formula $TT$
\end_inset

), the number of series to simulate (
\begin_inset Formula $rws$
\end_inset

), and also the initial number of periods at the deterministic steady state
 (
\begin_inset Formula $T\_ini$
\end_inset

).
\end_layout

\begin_layout Standard
The function 
\family typewriter
stnd_rbc_sim
\family default
 loops over time, and evaluates the policy function in each period:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "caption={Simulation in  \texttt{main\_stnd\_rbc\_proj}},label={pl:RBC_sim}"
inline false
status open

\begin_layout Plain Layout

% loop over time :
\end_layout

\begin_layout Plain Layout

for it = T_ini+1:T_ini+TT   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  % Calculate TFP (add shock) 
\end_layout

\begin_layout Plain Layout

  LZ(:,it) = par.rho_z * LZ(:,it-1) + par.sigma_z * epsilon(:,it); 
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

  % Calculate policy variable:     
\end_layout

\begin_layout Plain Layout

  LC(:,it) = get_pol_var(POL,[LK(:,it),LZ(:,it)],GRID);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  % Calculate K_t+1 and H_t:  
\end_layout

\begin_layout Plain Layout

  [LK(:,it+1),~,LH(:,it)] =  stnd_rbc_aux(par,LK(:,it),LZ(:,it),LC(:,it));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The loop first calculates Total Factor Productivity (
\begin_inset Formula $LZ$
\end_inset

), which takes normally distributed shocks 
\begin_inset Formula $epsilon$
\end_inset

 as input.
 Next it evaluates the policy function for consumption (
\begin_inset Formula $LC$
\end_inset

) given the state variables 
\begin_inset Formula $LK(:,it)$
\end_inset

 and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $LZ(:,it)$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 Finally it computes capital in the next period 
\begin_inset Formula $LK(:,it+1)$
\end_inset

, and the auxiliary variable hours worked 
\begin_inset Formula $LH(:,it)$
\end_inset

 using the function 
\family typewriter
stnd_rbc_aux
\family default
, which we discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Model_file"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Performance
\begin_inset CommandInset label
LatexCommand label
name "sec:Performance_RBC"

\end_inset


\end_layout

\begin_layout Standard
In this section we review the computation time and accuracy for 5 algorithms.
 We review splines with Direct Computation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_dir'}
\end_layout

\end_inset

) and Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_tmi'}
\end_layout

\end_inset

), Chebyshev with Galerkin's method (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

), Smolyak's algorithm with Direct Computation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_dir'}
\end_layout

\end_inset

), and monomials with minimization of squared errors (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse}
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
The computation time is the time needed to solve the model, excluding the
 computation of the errors.
 The errors are the normalized Euler Equation Errors calculated in consumption
 equivalent unit as in 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1992projection"
literal "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
EEE\left(K_{t},Z_{t};\theta\right)= & \frac{\Psi\left(K_{t},Z_{t};\theta\right)^{-1/\nu}}{\hat{C}\left(K_{t},Z_{t};\theta\right)}-1\label{eq:RBC_normal_Eul_error}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\Psi\left(K_{t},Z_{t};\theta\right)$
\end_inset

 is defined in equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:RBC_Psi"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We compute the errors on the initial grid (
\shape italic
on grid)
\shape default
, and on a grid with 1,000 equidistant nodes in each dimension (
\shape italic
off grid
\shape default
).
 When 
\shape italic
on grid 
\shape default
and 
\shape italic
off grid
\shape default
 errors are of similar magnitude for splines and Smolyak algorithms then
 the accuracy can be improved by using tighter stopping criteria (see Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Step-5:-Solving"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 For complete polynomials it might not be possible to achieve higher accuracy
 by tighter stopping criteria, because complete polynomials are overidentified
 as the number of gridpoints is higher than the number of parameters
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The exception are policy functions with one state variable and the number
 of nodes set to the order plus 1.
 These are exactly identified.
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The results are shown in Table 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{table:res_rbc}
\end_layout

\end_inset

.
 It should first be noted that computation times are low.
 For all basis functions a maximum (off grid) error of 
\begin_inset Formula $10^{-6}$
\end_inset

 can obtained in less than 0.05 seconds.
 In fact, projection can be faster and more accurate than perturbation when
 we solve a model only once.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{table}[ht!]
\end_layout

\begin_layout Plain Layout


\backslash
vspace{-12pt}
\end_layout

\begin_layout Plain Layout


\backslash
small
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{threeparttable}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Performance for Standard RBC model}                     
\end_layout

\begin_layout Plain Layout


\backslash
label{table:res_rbc}  
\end_layout

\begin_layout Plain Layout


\backslash
centering                                
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{l|ccccccc} 
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

& 
\backslash
multicolumn{7}{c}{Spline, Direct Computation}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Nodes per dim.
 & 3 & 5 & 7 & 10 & 15 
\backslash

\backslash
                     
\end_layout

\begin_layout Plain Layout

Total Nodes & 9 & 25 & 49 & 100 & 225 
\backslash

\backslash
                     
\end_layout

\begin_layout Plain Layout

Comp.
 time    & 0.05 & 0.06 & 0.12 & 0.27 & 0.73 
\backslash

\backslash
             
\end_layout

\begin_layout Plain Layout

EEE, off grid & -6.3 & -8.9 & -9.5 & -10.1 & -10.8 
\backslash

\backslash
        
\end_layout

\begin_layout Plain Layout

EEE, on grid & -15.4 & -15.4 & -14.9 & -14.5 & -14.1 
\backslash

\backslash
   
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

& 
\backslash
multicolumn{7}{c}{Spline, Time Iteration}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

Nodes per dim.
 & 3 & 5 & 7 & 10 & 15 & 25 & 50 
\backslash

\backslash
                                   
\end_layout

\begin_layout Plain Layout

Total Nodes & 9 & 25 & 49 & 100 & 225 & 625 & 2500 
\backslash

\backslash
                                
\end_layout

\begin_layout Plain Layout

Comp.
 time & 0.81 & 0.85 & 0.90 & 0.99 & 1.21 & 2.05 & 5.00 
\backslash

\backslash
                       
\end_layout

\begin_layout Plain Layout

EEE, off grid & -6.3 & -8.9 & -9.5 & -10.1 & -10.8 & -11.7 & -12.3 
\backslash

\backslash
                
\end_layout

\begin_layout Plain Layout

EEE, on grid & -12.3 & -12.3 & -12.3 & -12.3 & -12.3 & -12.3 & -12.3 
\backslash

\backslash
                  
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout


\backslash
hline  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

& 
\backslash
multicolumn{7}{c}{Complete Chebyshev poly., Galerkin}
\backslash

\backslash
              
\end_layout

\begin_layout Plain Layout


\backslash
hline   
\end_layout

\begin_layout Plain Layout

Order & 1 & 2 & 3 & 4 & 5 & 6 & 7 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Total Nodes & 4 & 9 & 16 & 25 & 36 & 49 & 64 
\backslash

\backslash
                                            
\end_layout

\begin_layout Plain Layout

Comp.
 time & 0.04 & 0.02 & 0.04 & 0.07 & 0.11 & 0.18 & 0.28 
\backslash

\backslash
                             
\end_layout

\begin_layout Plain Layout

EEE, off grid & -3.4 & -5.6 & -7.1 & -8.8 & -10.8 & -12.0 & -13.4 
\backslash

\backslash
                       
\end_layout

\begin_layout Plain Layout

EEE, on grid & -3.9 & -6.0 & -7.4 & -9.2 & -10.9 & -12.3 & -13.7 
\backslash

\backslash
                        
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

& 
\backslash
multicolumn{7}{c}{Smolyak, Direct Computation}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 
\backslash
hline  
\end_layout

\begin_layout Plain Layout

Accuracy ($
\backslash
mu$) & 1 & 2 & 3 & 4 
\backslash

\backslash
                 
\end_layout

\begin_layout Plain Layout

Total Nodes & 5 & 13 & 29 & 65 
\backslash

\backslash
                   
\end_layout

\begin_layout Plain Layout

Comp.
 time & 0.04 & 0.04 & 0.15 & 0.64 
\backslash

\backslash
           
\end_layout

\begin_layout Plain Layout

EEE, off grid & -3.7 & -7.5 & -11.1 & -12.8 
\backslash

\backslash
      
\end_layout

\begin_layout Plain Layout

EEE, on grid & -15.6 & -15.5 & -15.1 & -12.8 
\backslash

\backslash
   
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

& 
\backslash
multicolumn{7}{c}{Monomials, min.
 of squared errors}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

 
\backslash
hline  
\end_layout

\begin_layout Plain Layout

Order & 1 & 2 & 3 & 4 & 4 & 5 & 5 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Total Nodes & 4 & 9 & 16 & 25 & 121 & 36 & 121 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Comp.
 time & 0.04 & 0.02 & 0.02 & 0.05 & 0.06 & 0.06 & 0.07 
\backslash

\backslash
                                   
\end_layout

\begin_layout Plain Layout

EEE, off grid & -3.6 & -5.9 & -7.2 & -9.0 & -8.7 & -8.4 & -8.3 
\backslash

\backslash
                                EEE, on grid & -3.6 & -5.9 & -7.2 & -9.0 & -8.7
 & -8.4 & -8.3 
\backslash

\backslash
     
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 
\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
hline   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

& 
\backslash
multicolumn{7}{c}{Perturbation}
\backslash

\backslash
              
\end_layout

\begin_layout Plain Layout


\backslash
hline                                   
\end_layout

\begin_layout Plain Layout

Order & 1 & 2 & 3 &  &  &  & 
\backslash

\backslash
                  
\end_layout

\begin_layout Plain Layout

Comp.
 time & 0.15 & 0.18 & 0.30 &  &  &  & 
\backslash

\backslash
    
\end_layout

\begin_layout Plain Layout

EEE (off grid) & -3.32 & -4.44 & -6.38 &  &  &  & 
\backslash

\backslash
                  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tablenotes}[flushleft] 
\end_layout

\begin_layout Plain Layout


\backslash
item 
\backslash
textit{Computation times in seconds.
 Errors are the maximum Euler Equation Errors, in absolute values and log10.
 `Off grid' refers to the equidistant grid with 1 million nodes, while `on
 grid' refers to the initial grid used to solve the model.}      
\end_layout

\begin_layout Plain Layout


\backslash
end{tablenotes}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{threeparttable}                                        
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
end{table}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A Spline with Direct Computation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_dir'}
\end_layout

\end_inset

) is fast and accurate for a low number of gridpoints, but computation times
 increase rapidly with the number of nodes.
 The reason is that the algorithm has to numerically approximate an 
\begin_inset Formula $m\times m$
\end_inset

 Jacobian matrix, for 
\begin_inset Formula $m$
\end_inset

 total gridpoints.
 Due to the high non-linearity
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Changing the solution at one gridpoint will change the spline.
 This will affect the solution at other gridpoints in a non-linear way.
\end_layout

\end_inset

 of the system no solution is found for 25 and 50 nodes in each dimension.
 For larger grids Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_tmi'}
\end_layout

\end_inset

) is faster.
 With splines the error decay up to 50 nodes
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The error decay will be lower when the inaccuracy of the solution at the
 gridpoints comes into play.
\end_layout

\end_inset

 is 
\begin_inset Formula $\mathcal{O}\left(q^{-4}\right)$
\end_inset

, where 
\begin_inset Formula $q$
\end_inset

 is the number of nodes in each dimension.
 This is an accordance with 
\begin_inset CommandInset citation
LatexCommand citet
key "de1978practical"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
The Chebyshev polynomial with Galerkin's method (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

) is both fast and accurate.
 An maximum error of 
\begin_inset Formula $-7.1$
\end_inset

 (in log10) is achieved in 0.04 seconds, and an error of 
\begin_inset Formula $-13$
\end_inset

 (in log10) in less than 0.3 seconds.
 Smolyak's algorithm with Direct Computation (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_dir'}
\end_layout

\end_inset

) is also fast and accurate.
 To achieve a certain accuracy level Smolyak's algorithm is slower than
 a Chebyshev polynomial with Galerkin's method.
 The main reason is that Smolyak's polynomial is less effective in reducing
 errors.
 For example with 
\begin_inset Formula $\mu=4$
\end_inset

 the polynomial is of degree 16 and there are 65 gridpoints, which achieves
 an error of 
\begin_inset Formula $-12.8$
\end_inset

 (in log10).
 For a complete Chebyshev polynomial of degree 7 we need 64 gridpoints,
 and the error is -13.4 in log10.
\end_layout

\begin_layout Standard
Monomial basis functions with minimization of squared errors (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

) is faster and more accurate than Chebyshev polynomials up to order 4.
 For higher order approximations monomials are inaccurate.
 In fact, the error increases with the order of the approximation above
 order 4.
 This is due to the collinearity of monomials, and scaling issues as discussed
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Monomials"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We increased the number of nodes for the order 4 and 5 monomials, which
 has little effect on the accuracy.
 This will be the case in general, also for complete Chebyshev polynomials
 as 
\begin_inset CommandInset citation
LatexCommand citet
key "fernandez2016solution"
literal "false"

\end_inset

 confirm.
\end_layout

\begin_layout Standard
We plot the errors as a function of the capital stock in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Eul_res_RBC"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The figure shows that the errors within the boundaries are relatively constant
 for projection methods.
 With perturbation methods errors increase further from the steady state.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Euler Equation Errors for RBC model
\begin_inset CommandInset label
LatexCommand label
name "fig:Eul_res_RBC"

\end_inset

 (at 
\begin_inset Formula $Z=1$
\end_inset

)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename FIGURES/Errors_Stnd_RBC.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subcaption*{
\backslash
it{Vertical dotted lines are the bounds of the grid.}}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Sensitivity Gauss-Hermite quadrature
\end_layout

\begin_layout Standard
To investigate the effect of the number of Gauss-Hermite nodes on the policy
 function we plot the policy function for different number of Gauss-Hermite
 nodes.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:GH_analysis"
plural "false"
caps "false"
noprefix "false"

\end_inset

 the difference with the solution for 5 Gauss-Hermite nodes is plotted.
 The other state variable, capital, is set at its non-stochastic steady
 state.
 The differences are of the order 
\begin_inset Formula $10^{-7}$
\end_inset

 for 
\begin_inset Formula $\sigma_{z}=0.01$
\end_inset

.
 We included the most extreme differences (10 and 8 nodes).
 For other numbers of nodes the differences are smaller, for example for
 6, 7, 9, 11, 15, 20, 30 and 40 nodes (not shown).
 Given the small differences we may conclude that the policy function is
 relatively insensitive to the number of Gauss-Hermite nodes as long as
 more than 1 node is chosen.
 With one node the differences are of the order 
\begin_inset Formula $10^{-4}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Difference with 5 Gauss-Hermite nodes (at 
\begin_inset Formula $K=K_{ss}$
\end_inset

)
\begin_inset CommandInset label
LatexCommand label
name "fig:GH_analysis"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename FIGURES/GH_Stnd_RBC.eps
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "90col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.4cm} 
\end_layout

\begin_layout Plain Layout


\backslash
it{Vertical dotted lines are the boundaries of the grid used in the approximatio
n.}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Multiple policy variables
\begin_inset CommandInset label
LatexCommand label
name "chap:Multiple-policy-variables"

\end_inset


\end_layout

\begin_layout Standard
This chapter illustrates how a model with multiple policy variables can
 be solved.
 We use a simple RBC model with an extra asset, housing.
 This `Housing Model' (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Housing-model"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more model details) is solved in the program 
\family typewriter
main_housing_proj
\family default
 in the folder `Examples'.
 This chapter focuses on the two main differences between solving a model
 with one policy variable and multiple policy variables.
 
\end_layout

\begin_layout Standard
The first difference is that each policy variable gets an index.
 The index is determined by the column of the variable in the initial guess.
 For example if we have two policy variables 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

, and the initial guess is 
\begin_inset Formula $Y0=\left[a_{0},b_{0}\right]$
\end_inset

 then variable 
\begin_inset Formula $a$
\end_inset

 gets index 
\begin_inset Formula $i\textrm{\_}pol=1$
\end_inset

 and variable 
\begin_inset Formula $b$
\end_inset

 index 
\begin_inset Formula $i\textrm{\_}pol=2$
\end_inset

.
 The index 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 is used when evaluating the policy function with 
\family typewriter
get_pol_var
\family default
.
 
\end_layout

\begin_layout Standard
The second difference is that the residuals of the model function need to
 be grouped.
 Assume each policy variable can be linked to a specific residual vector,
 
\begin_inset Formula $R_{a}$
\end_inset

 and 
\begin_inset Formula $R_{b}$
\end_inset

, each with length 
\begin_inset Formula $m$
\end_inset

.
 The output of the model function needs to be the vector 
\begin_inset Formula $R=\left[R_{a};R_{b}\right]$
\end_inset

, which has dimensions 
\begin_inset Formula $2m\times1$
\end_inset

.
 Stacking the residual vectors vertically ensures that row 
\begin_inset Formula $i$
\end_inset

 and row 
\begin_inset Formula $i+m$
\end_inset

 in 
\begin_inset Formula $R$
\end_inset

 refer to the same gridpoint.
 In addition, when policy variable 
\begin_inset Formula $a$
\end_inset

 affects 
\begin_inset Formula $R_{a}$
\end_inset

 directly, and 
\begin_inset Formula $b$
\end_inset

 affects 
\begin_inset Formula $R_{b}$
\end_inset

 directly, then 
\begin_inset Formula $R_{a}$
\end_inset

 and 
\begin_inset Formula $R_{b}$
\end_inset

 should be stacked vertically in the same order as 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 were stacked horizontally in 
\begin_inset Formula $Y0$
\end_inset

.
\end_layout

\begin_layout Section
Housing model
\end_layout

\begin_layout Standard
The model consists of three state variables, which are capital 
\begin_inset Formula $K_{t}$
\end_inset

, housing 
\begin_inset Formula $D_{t}$
\end_inset

 and Total Factor Productivity 
\begin_inset Formula $Z_{t}$
\end_inset

.
 We use two policy variables, which are capital in the next period, 
\begin_inset Formula $K_{t+1}$
\end_inset

 and current period consumption 
\begin_inset Formula $C_{t}$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Using 
\begin_inset Formula $D_{t+1}$
\end_inset

 as second policy variable will result in worse convergence for most algorithms,
 since the marginal utility of consumption 
\begin_inset Formula $\lambda$
\end_inset

 will be affected directly by both 
\begin_inset Formula $K_{t+1}$
\end_inset

 and 
\begin_inset Formula $D_{t+1}$
\end_inset

 through the budget constraint.
 With 
\begin_inset Formula $C_{t}$
\end_inset

 (instead of 
\begin_inset Formula $D_{t+1}$
\end_inset

) as policy variable the marginal utility of consumption in 
\begin_inset Formula $t+1$
\end_inset

 will only be affected indirectly by 
\begin_inset Formula $K_{t+1}$
\end_inset

.
 This helps solving the model more effectively.
\end_layout

\end_inset

.
 The model is captured by five equations (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Housing-model"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{t}+K_{t+1}+D_{t+1} & \leq Z_{t}K_{t}^{\alpha}+\left(1-\delta_{k}\right)K_{t}+\left(1-\delta_{d}\right)D_{t}\label{eq:HOUS_budget-1}\\
C_{t}^{-\nu} & =\lambda_{t}\label{eq:HOUS_lambda}\\
\lambda_{t} & =\beta E_{t}\left\{ \lambda_{t+1}\left[Z_{t+1}\alpha K_{t+1}^{\alpha-1}+1-\delta_{k}\right]\right\} \label{eq:HOUS_eul_k-1}\\
\lambda_{t} & =\beta E_{t}\left\{ \varrho D_{t+1}^{-\eta}+\lambda_{t+1}\left(1-\delta_{d}\right)\right\} \label{eq:HOUS_eul_d-1}\\
z_{t} & =\rho_{z}z_{t-1}+\sigma_{z}\epsilon_{t}\label{eq:HOUS_TFP}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where smaller cases indicate logs, ie.
 
\begin_inset Formula $z_{t}=\log\left(Z_{t}\right)$
\end_inset

.
 Housing is 
\begin_inset Formula $D$
\end_inset

, capital is 
\begin_inset Formula $K$
\end_inset

, consumption is 
\begin_inset Formula $C$
\end_inset

, the multiplier on the budget constraint is 
\begin_inset Formula $\lambda$
\end_inset

, productivity is 
\begin_inset Formula $Z$
\end_inset

, the autocorrelation coefficient 
\begin_inset Formula $\rho_{z}$
\end_inset

 , and the shocks are scaled by 
\begin_inset Formula $\sigma_{z}$
\end_inset

.
 The shocks are standard normally distributed, ie.
 
\begin_inset Formula $\epsilon_{t}\sim\mathcal{N}\left(0,1\right)$
\end_inset

.
 Note that equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_eul_k-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is the Euler equation for capital, and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_eul_d-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 the Euler equation for housing.
\end_layout

\begin_layout Section
Policy function
\begin_inset CommandInset label
LatexCommand label
name "sec:HOUS_pol_fun"

\end_inset


\end_layout

\begin_layout Standard
The model consists of three state variables, 
\begin_inset Formula $K_{t}$
\end_inset

, 
\begin_inset Formula $D_{t}$
\end_inset

 and 
\begin_inset Formula $Z_{t}$
\end_inset

.
 We solve the model by approximating the policies for 
\begin_inset Formula $K_{t+1}$
\end_inset

 and 
\begin_inset Formula $C_{t}$
\end_inset

.
 The policy function for capital in the next period is 
\begin_inset Formula $K_{t+1}=\hat{K}\left(K_{t},H_{t},Z_{t};\theta^{1}\right)=\exp\left[\hat{k}\left(k_{t},h_{t},z_{t};\theta^{1}\right)\right]$
\end_inset

.
 The policy function for consumption is 
\begin_inset Formula $C_{t}=\hat{C}\left(K_{t},H_{t},Z_{t};\theta^{2}\right)=\exp\left[\hat{c}\left(k_{t},h_{t},z_{t};\theta^{2}\right)\right]$
\end_inset

.
 The superscript 
\begin_inset Formula $j$
\end_inset

 in 
\begin_inset Formula $\theta^{j}$
\end_inset

 is the index of the policy variable.
 This index is determined by the column index of the initial guess 
\begin_inset Formula $Y0$
\end_inset

.
 To ensure capital gets index 
\begin_inset Formula $i\textrm{\_}pol=1$
\end_inset

 we put capital in the first column of 
\begin_inset Formula $Y0$
\end_inset

, and housing in the second column.
 The initial guess is based on the first order perturbation solution:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

%pre-allocate dimensions   
\end_layout

\begin_layout Plain Layout

Y0 = NaN(GRID.mm,2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%Initial guess for capital:    
\end_layout

\begin_layout Plain Layout

Y0(:,1) = log(SS.Kss) + ...
         
\end_layout

\begin_layout Plain Layout

  0.9608*(GRID.xx(:,1)-log(SS.Kss)) +...
\end_layout

\begin_layout Plain Layout

  0.0540*(GRID.xx(:,2)-log(SS.Dss)) +...
\end_layout

\begin_layout Plain Layout

  0.0829*(GRID.xx(:,3)-log(SS.Zss));
\end_layout

\begin_layout Plain Layout

                          
\end_layout

\begin_layout Plain Layout

%Initial guess for consumption:     
\end_layout

\begin_layout Plain Layout

Y0(:,2) = log(SS.Css) + ...
\end_layout

\begin_layout Plain Layout

  0.4722*(GRID.xx(:,1)-log(SS.Kss)) +...
\end_layout

\begin_layout Plain Layout

  0.0266*(GRID.xx(:,2)-log(SS.Dss)) +...
\end_layout

\begin_layout Plain Layout

  0.3865*(GRID.xx(:,3)-log(SS.Zss));
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With 
\begin_inset Formula $Y0$
\end_inset

 we have determined the indices 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 of the policy variables.
 When calling 
\family typewriter
get_pol_var
\family default
 the fourth argument has to be set to 
\begin_inset Formula $i\textrm{\_}pol=1$
\end_inset

 to obtain capital 
\begin_inset Formula $K_{t+1}$
\end_inset

 and 
\begin_inset Formula $i\textrm{\_}pol=2$
\end_inset

 to obtain consumption 
\begin_inset Formula $C_{t}$
\end_inset

.
 For Time Iteration the policy variables are the columns in 
\begin_inset Formula $POL.YY$
\end_inset

 in the same order as in 
\begin_inset Formula $Y0$
\end_inset

.
 In our example we evaluate the policy function at the initial grid as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

LK = GRID.xx(:,1);%first state variable,    log(K_t) 
\end_layout

\begin_layout Plain Layout

LD = GRID.xx(:,2);%second state variable,   log(D_t) 
\end_layout

\begin_layout Plain Layout

LZ = GRID.xx(:,3);%third state variable,    log(Z_t)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%policy variables, log(K_t+1) and  log(C_t): 
\end_layout

\begin_layout Plain Layout

if ~(strcmp(POL.algo,'spl_tmi') || ...
           strcmp(POL.algo,'smol_tmi') ||...
 
\end_layout

\begin_layout Plain Layout

  strcmp(POL.algo,'cheb_tmi') )
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

  %use initial grid for polynomials      
\end_layout

\begin_layout Plain Layout

  % (or ignore for spl_dir)     
\end_layout

\begin_layout Plain Layout

  spec_opt    = 'ini_grid';          
\end_layout

\begin_layout Plain Layout

  % fourth entry is index for policy variable (i_pol)     
\end_layout

\begin_layout Plain Layout

  LK_n  	= get_pol_var(POL,[LK,LD,LZ],GRID,1,spec_opt);     
\end_layout

\begin_layout Plain Layout

  LC 	= get_pol_var(POL,[LK,LD,LZ],GRID,2,spec_opt);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

else %for 'spl_tmi','cheb_tmi','smol_tmi':     
\end_layout

\begin_layout Plain Layout

 	
\end_layout

\begin_layout Plain Layout

  %Pol.
 variables in columns of POL.YY for 'tmi':     
\end_layout

\begin_layout Plain Layout

  LK_n    = POL.YY(:,1);    
\end_layout

\begin_layout Plain Layout

  LC      = POL.YY(:,2); 
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Section
Residuals
\begin_inset CommandInset label
LatexCommand label
name "sec:HOUS_residuals"

\end_inset


\end_layout

\begin_layout Standard
The Euler residuals are calculated similarly to the standard RBC example
 discussed in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:RBC-example"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For given policies for 
\begin_inset Formula $K_{t+1}$
\end_inset

 and 
\begin_inset Formula $C_{t}$
\end_inset

 we can determine housing 
\begin_inset Formula $D_{t+1}$
\end_inset

 from the budget constraint:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\hat{D}_{t+1} & =Z_{t}K_{t}^{\alpha}+\left(1-\delta_{k}\right)K_{t}+\left(1-\delta_{d}\right)D_{t}-\hat{K}\left(K_{t},H_{t},Z_{t};\theta^{k}\right)-\hat{C}\left(K_{t},H_{t},Z_{t};\theta^{c}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The multiplier 
\begin_inset Formula $\lambda_{t}$
\end_inset

 is defined by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_lambda"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
As in the other models we need to evaluate next period's policy functions.
 Next period's choice determines 
\begin_inset Formula $\hat{C}_{t+1}$
\end_inset

, and enables us to calculate the two residual functions 
\begin_inset Formula $R^{1}$
\end_inset

 and 
\begin_inset Formula $R^{2}$
\end_inset

, corresponding to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_eul_k-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_eul_d-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

, respectively
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See Step 3A in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Model_file"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for details on how to approximate the expected value using Gauss-Hermite
 quadrature.
 
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
R^{1} & =\beta E_{t}\left\{ \hat{\lambda}_{t+1}\left[Z_{t+1}\alpha\hat{K}_{t+1}^{\alpha-1}+1-\delta_{k}\right]\right\} /\hat{\lambda}_{t}-1\\
R^{2} & =\beta E_{t}\left\{ \varrho\hat{D}_{t+1}^{-\eta}+\hat{\lambda}_{t+1}\left(1-\delta_{d}\right)\right\} /\hat{\lambda}_{t}-1
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where we divided both sides of the Euler equation with 
\begin_inset Formula $\lambda$
\end_inset

 to get more equally distributed normalized errors as explained in Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Model_file"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 In our model function we stack the residual vectors vertically, such that
 
\begin_inset Formula $RES$
\end_inset

 is a 
\begin_inset Formula $2m\times1$
\end_inset

 vector:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% Euler residuals  
\end_layout

\begin_layout Plain Layout

RES1    = sum(rhs_j1,2)/lambda - 1; 
\end_layout

\begin_layout Plain Layout

RES2 	= sum(rhs_j2,2)/lambda - 1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% RES1 and RES2 are mm by 1 vectors
\end_layout

\begin_layout Plain Layout

% concatenated vertically: 
\end_layout

\begin_layout Plain Layout

RES = [RES1;RES2];
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Note that the first residual vector 
\begin_inset Formula $RES1$
\end_inset

 is more directly linked with the first policy variable 
\begin_inset Formula $K_{t+1}$
\end_inset

.
 This requires that the residual vector 
\begin_inset Formula $RES1$
\end_inset

 comes first when stacking the residual vectors vertically, because 
\begin_inset Formula $K_{t+1}$
\end_inset

 was also the first policy variables (
\begin_inset Formula $i\textrm{\_}pol=1$
\end_inset

)
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\noindent
This ordering is required for Galerkin's algorithm, because the coefficients
 of each policy function are set such that the corresponding residuals are
 orthogonal to the polynomial terms.
 
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Part
Theoretical description of algorithms
\begin_inset CommandInset label
LatexCommand label
name "part:Theoretical-description"

\end_inset


\end_layout

\begin_layout Chapter
General Approach
\begin_inset CommandInset label
LatexCommand label
name "chap:General Approach"

\end_inset


\end_layout

\begin_layout Standard
The goal of each of the algorithms is to numerically approximate a policy
 function that solves a recursive dynamic optimization problem.
 A policy function gives the control (or policy) variable 
\begin_inset Formula $Y$
\end_inset

 as a function of the state variables 
\begin_inset Formula $x$
\end_inset

.
 If the exact policy function is 
\begin_inset Formula $Y\left(x\right)$
\end_inset

 the algorithm approximates this function with 
\begin_inset Formula $\hat{Y}\left(x;\theta\right)$
\end_inset

 where 
\begin_inset Formula $\theta$
\end_inset

 is a vector of parameters of the basis function, either a spline or a polynomia
l.
\end_layout

\begin_layout Standard
The objective of projection methods is to find the policy function that
 solves the dynamic optimization problem.
 The algorithms require a function that computes the Euler residuals for
 a given approximation of the policy function.
 In practice the residual function 
\begin_inset Formula $R\left(x;\theta\right)$
\end_inset

 is a function with the model equations, which is discussed in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Model-file"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 These residuals are computed on the initial grid, which consists of gridpoints
 of the 
\begin_inset Formula $n$
\end_inset

 state variables.
 The construction of the grid is discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Defining-a-grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Next we discuss obtaining the Solution at the gridpoints in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Solutaion_at_grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We solve a model at the gridpoints using either Direct Computation or Time
 Iteration, which are the most intuitive solution methods.
 The approaches using Minimization of Squared Error (least squares) and
 Galerkin's method are discussed in the next Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Specific-Algorithms"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
The remainder of this Chapter is mostly copied from 
\begin_inset CommandInset citation
LatexCommand citet
key "duineveld2021standardized"
literal "false"

\end_inset

.
 We explain the general approach with the Deterministic Brock-Mirman model
 used in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:The-Basics"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We use a slightly more formal approach as in that chapter.
 
\end_layout

\begin_layout Standard
The relevant equations are the resource constraint and the First Order Condition
:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
K_{t+1}+C_{t} & =K_{t}^{\alpha}\nonumber \\
C_{t}^{-1} & =\beta C_{t+1}^{-1}\alpha K_{t+1}^{\alpha-1}\label{eq:BM_Euler}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
We choose consumption 
\begin_inset Formula $C_{t}$
\end_inset

 as the policy variable, which is a function of the state variable capital
 
\begin_inset Formula $K_{t}$
\end_inset

.
 There exists a policy function 
\begin_inset Formula $C_{t}=C\left(K_{t}\right)$
\end_inset

, which exactly solves this dynamic optimization problem.
 Instead we numerically approximate the policy function with 
\begin_inset Formula $\hat{C}\left(K_{t};\theta\right)$
\end_inset

.
 The approximation 
\begin_inset Formula $\hat{C}\left(K_{t};\theta\right)$
\end_inset

 will not exactly solve this dynamic system, and we need to compute the
 errors with a residual function.
 
\end_layout

\begin_layout Standard
Given the approximation of consumption we can compute next period's variables:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{K}_{t+1} & =\hat{K}\left(K_{t};\theta^{j}\right)=K_{t}^{\alpha}-\hat{C}\left(K_{t};\theta^{j}\right)\label{eq:BM_K_next}\\
\hat{C}_{t+1} & =\hat{C}\left(\hat{K}_{t+1};\theta^{j-1}\right)\label{eq:BM_C_next}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where superscript 
\begin_inset Formula $j$
\end_inset

 indicates the current period choices, and 
\begin_inset Formula $j-1$
\end_inset

 next period's choices, although this difference is only relevant for Time
 Iteration.
\end_layout

\begin_layout Standard
The residuals in the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM_Euler"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a result of the approximation are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(K_{t};\theta\right) & =\beta\hat{C}\left(\hat{K}\left(K_{t};\theta^{j}\right);\theta^{j-1}\right)^{-1}\alpha\hat{K}\left(K_{t};\theta^{j}\right)^{\alpha-1}-\hat{C}\left(K_{t};\theta^{j}\right)^{-1}\label{eq:BM_RES}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The objective is to find the policy function that minimizes the residuals
 on a specified interval of the state variables.
 This interval is determined by a lower and upper bound of each state variable.
 Within this interval discrete points, or gridpoints, are chosen, where
 we evaluate the Euler residuals.
\end_layout

\begin_layout Section
\noindent
Defining a grid
\begin_inset CommandInset label
LatexCommand label
name "sec:Defining-a-grid"

\end_inset


\end_layout

\begin_layout Standard
The policy function is set such that the residuals on the gridpoints are
 minimized.
 The grid is defined over an interval of each of the 
\begin_inset Formula $n$
\end_inset

 state variables where we want the approximation to be good.
 The intervals are defined by the lower and upper bounds 
\begin_inset Formula $\left[\underline{x}^{i},\overline{x}^{i}\right]$
\end_inset

 for 
\begin_inset Formula $i=\left[1,\ldots,n\right]$
\end_inset

.
 
\end_layout

\begin_layout Standard
For all methods except Smolyak's algorithm
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Smolyak"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for the construction of the grid with Smolyak's algorithm.
\end_layout

\end_inset

 we use a Cartesian product to construct the grid.
 For each state variable 
\begin_inset Formula $i$
\end_inset

 a set of 
\begin_inset Formula $q^{i}$
\end_inset

 nodes 
\begin_inset Formula $X^{i}=\left\{ x_{1}^{i},x_{2}^{i},\ldots,x_{q^{i}}^{i}\right\} $
\end_inset

 are defined on the interval between the lower and upper bound.
 For splines and monomials we use equidistant nodes, and for complete Chebyshev
 polynomials we use the Chebyshev nodes.
 We call the Cartesian product of these sets the initial grid:
\begin_inset Formula 
\begin{align}
\mathcal{X} & =X^{1}\times\ldots\times X^{n}\label{eq:Initial_grid}
\end{align}

\end_inset

This set consists of 
\begin_inset Formula $m=\prod_{i=1}^{n}q^{i}$
\end_inset

 points where the residual function is evaluated.
\end_layout

\begin_layout Standard
The toolbox constructs the grid with the function 
\family typewriter
prepgrid
\family default
.
 The set of nodes 
\begin_inset Formula $X^{i}$
\end_inset

 are assigned to the cell array 
\begin_inset Formula $GRID.gridVecs$
\end_inset

.
 The initial grid 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Initial_grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is the field 
\begin_inset Formula $GRID.xx$
\end_inset

.
 Each column in 
\begin_inset Formula $GRID.xx$
\end_inset

 represents a state variable.
\end_layout

\begin_layout Section
Solution at gridpoints
\begin_inset CommandInset label
LatexCommand label
name "sec:Solutaion_at_grid"

\end_inset


\end_layout

\begin_layout Standard
For several algorithms
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
All algorithms using collocation, and for Chebyshev polynomials with Time
 Iteration.
\end_layout

\end_inset

 we solve the model at the 
\begin_inset Formula $m$
\end_inset

 gridpoints with either Direct Computation or Time Iteration.
 With Direct Computation we solve a system of equations with a non-linear
 equation solver based on a Newton-type of algorithm.
 This methods numerically estimates the 
\begin_inset Formula $m\times m$
\end_inset

 Jacobian matrix of the system equations.
 Time Iteration is specifically designed to solve a recursive dynamic system
 of equations.
 The algorithms chooses the period 
\begin_inset Formula $t$
\end_inset

 policy variable at the gridpoints, while holding the period 
\begin_inset Formula $t+1$
\end_inset

 policy function constant.
 This ensures that the 
\begin_inset Formula $m\times m$
\end_inset

 Jacobian matrix of the system of equations is sparse with only entries
 on the diagonal.
 Each iteration is therefore computationally less intensive, but also less
 effective than with Direct Computation.
 
\end_layout

\begin_layout Standard
For both Direct Computation and Time Iteration the solution at the gridpoints
 uniquely defines the coefficients 
\begin_inset Formula $\theta$
\end_inset

 of the basis function, either a spline or a polynomial.
 Assume the algorithms finds the solution 
\begin_inset Formula $\tilde{Y}$
\end_inset

 at the gridpoints 
\begin_inset Formula $x\in\mathcal{X}$
\end_inset

.
 The coefficients of the basis function 
\begin_inset Formula $\theta$
\end_inset

 can be determined by some function:
\begin_inset Formula 
\begin{align}
\theta & =\varGamma\left(x,\tilde{Y}\right)\label{eq:Coefficient_Function}
\end{align}

\end_inset


\end_layout

\begin_layout Subsection*
Direct Computation
\end_layout

\begin_layout Standard
For Direct Computation the residuals can be written as a function of either
 the coefficients 
\begin_inset Formula $\theta$
\end_inset

 or the choice variable 
\begin_inset Formula $\tilde{C}$
\end_inset

 at the gridpoints.
 In equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM_RES"
plural "false"
caps "false"
noprefix "false"

\end_inset

 the residuals were a function of the coefficients 
\begin_inset Formula $\theta.$
\end_inset

 Using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Coefficient_Function"
plural "false"
caps "false"
noprefix "false"

\end_inset

 the alternative formulation of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM_RES"
plural "false"
caps "false"
noprefix "false"

\end_inset

 in terms of choice variable 
\begin_inset Formula $\tilde{C}$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(K_{t},\tilde{C}_{t}\right) & =R\left(K_{t};\varGamma\left(K_{t},\tilde{C}_{t}\right)\right)\label{eq:SMPL_dir_alt}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The objective is to set the residual equal to 0 at all 
\begin_inset Formula $m$
\end_inset

 gridpoints
\begin_inset Foot
status open

\begin_layout Plain Layout
See equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Initial_grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

.
 In the original formulation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
0 & =R\left(K_{t};\varGamma\left(K_{t},\tilde{C}_{t}\right)\right)\label{eq:DIR_objective}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
This system of equations can be solved with a Newton-type of non-linear
 equation solver
\begin_inset Foot
status open

\begin_layout Plain Layout
By default the toolbox uses Matlab's 
\family typewriter
fsolve
\family default
 with the `trust-region-dogleg' algorithm for Direct Computation.
 
\end_layout

\end_inset

.
 This type of solver will converge at least quadratically close to the solution
 
\begin_inset CommandInset citation
LatexCommand citep
key "judd1998numerical"
literal "false"

\end_inset

.
 Note that a change in 
\begin_inset Formula $\tilde{C}_{i,t}$
\end_inset

 at gridpoint 
\begin_inset Formula $i$
\end_inset

 affects the coefficients 
\begin_inset Formula $\theta$
\end_inset

, which also affects the solution at other gridpoints 
\begin_inset Formula $j\neq i$
\end_inset

.
 This necessitates the numerical approximation of the dense 
\begin_inset Formula $m\times m$
\end_inset

 Jacobian.
 As the Jacobian has 
\begin_inset Formula $m^{2}$
\end_inset

 elements each iteration is computationally expensive for a large number
 of gridpoints 
\begin_inset Formula $m$
\end_inset

.
 This makes the solution method is less efficient than Time Iteration for
 large grids.
 For highly non-linear systems Direct Computation might have convergence
 issues
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The algorithm will locally linearize the system of equations, which might
 be a poor approximation far away from the solution.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection*
Time Iteration 
\end_layout

\begin_layout Standard
The Time Iteration algorithm is described by 
\begin_inset CommandInset citation
LatexCommand citet
key "judd1998numerical"
literal "false"

\end_inset

.
 Compared to Direct Computation it economizes on the iteration step.
 In iteration 
\begin_inset Formula $j$
\end_inset

 the algorithm solves for period 
\begin_inset Formula $t$
\end_inset

 choices 
\begin_inset Formula $\tilde{C_{t}}^{j}$
\end_inset

, while using the coefficients of the previous iteration 
\begin_inset Formula $\theta^{j-1}$
\end_inset

 for period 
\begin_inset Formula $t+1$
\end_inset

 choices.
 For the simple example we replace 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM_K_next"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM_C_next"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with:
\begin_inset Formula 
\begin{align*}
\hat{K}_{t+1} & =K_{t}^{\alpha}-\tilde{C}_{t}^{j}=\hat{K}\left(K_{t},\tilde{C}_{t}^{j}\right)\\
\hat{C}_{t+1} & =\hat{C}\left(\hat{K}_{t+1};\theta^{j-1}\right)\\
 & =\hat{C}\left(\hat{K}\left(K_{t},\tilde{C}_{t}^{j}\right);\theta^{j-1}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
This gives us the residual function:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
R\left(K_{t},\tilde{C}_{t}^{j};\theta^{j-1}\right) & =\beta\hat{C}\left(\hat{K}\left(K_{t},\tilde{C}_{t}^{j}\right);\theta^{j-1}\right)^{-1}\alpha\hat{K}\left(K_{t},\tilde{C}_{t}^{j}\right)^{\alpha-1}-\left(\tilde{C}_{t}^{j}\right){}^{-1}\label{eq:BM_TMI_res}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
Equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM_TMI_res"
plural "false"
caps "false"
noprefix "false"

\end_inset

 defines a system of 
\begin_inset Formula $m$
\end_inset

 non-linear equations in as many unknowns 
\begin_inset Formula $\tilde{C}_{t}^{j}$
\end_inset

.
 We solve the system of equations 
\begin_inset Formula $R\left(K_{t},\tilde{C}_{t}^{j};\theta^{j-1}\right)=0$
\end_inset

 with a Newton-type of algorithm
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
By default the toolbox uses Matlab's 
\family typewriter
fsolve
\family default
 with the `trust-region' algorithm for square problems.
 This algorithm allows the use of a sparse Jacobian.
\end_layout

\end_inset

.
 As the residual at gridpoint 
\begin_inset Formula $i$
\end_inset

 only depends on 
\begin_inset Formula $\tilde{C}_{i,t}^{j}$
\end_inset

 the Jacobian matrix is sparse with entries on the diagonal only
\begin_inset Foot
status open

\begin_layout Plain Layout
With multiple policy functions the Jacobian consists of repeated blocks
 of diagonal matrices.
\end_layout

\end_inset

.
 In addition, we do not have to recompute the spline or polynomial when
 numerically approximating the Jacobian.
 This makes the algorithm efficient for recursive dynamic problems.
 After solving the system of equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM_TMI_res"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for the policy variable 
\begin_inset Formula $\tilde{C}_{t}^{j}$
\end_inset

 we update the coefficients 
\begin_inset Formula $\theta$
\end_inset

 using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Coefficient_Function"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and repeat the process until convergence.
 
\end_layout

\begin_layout Standard
We use two stopping criteria, which both have to be satisfied.
 The first criterion is the maximum absolute difference in the policy variable
 between iterations, which has to satisfy 
\begin_inset Formula $\max\left|\tilde{Y}^{j}-\tilde{Y}^{j-1}\right|\leq\epsilon^{d}$
\end_inset

.
 The second criterion is the maximum Euler residual at the gridpoints 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
when using the updated policy 
\begin_inset Formula $\theta^{j}$
\end_inset

 for both current and next period's policy.
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
Formally this stopping criterion is 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\max\left|R\left(x,\tilde{Y}^{j};\theta^{j}\right)\right|\leq\epsilon^{r}$
\end_inset

 , where 
\begin_inset Formula $x$
\end_inset

 are the state variables.
\end_layout

\begin_layout Chapter
Algorithms
\begin_inset CommandInset label
LatexCommand label
name "chap:Specific-Algorithms"

\end_inset


\end_layout

\begin_layout Standard
In this Chapter we discuss all the algorithms.
 This chapter is also mostly copied from 
\begin_inset CommandInset citation
LatexCommand citet
key "duineveld2021standardized"
literal "false"

\end_inset

.
\end_layout

\begin_layout Section
Splines 
\begin_inset CommandInset label
LatexCommand label
name "sec:Splines"

\end_inset


\end_layout

\begin_layout Standard
Splines are determined by Matlab's 
\family typewriter
griddedInterpolant
\family default
.
 Spline basis functions are best used in combination with collocation.
 The policy variable(s) 
\begin_inset Formula $\tilde{Y}$
\end_inset

 at each gridpoint 
\begin_inset Formula $x\in\mathcal{X}$
\end_inset

 is obtained with either Direct Computation or Time Iteration.
 The solution at the gridpoints determines the parameters 
\begin_inset Formula $\theta$
\end_inset

 of a piece-wise cubic polynomial, or spline as in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Coefficient_Function"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For simplicity we use a grid with equidistant nodes.
\end_layout

\begin_layout Standard
By default the toolbox sets the interpolation method of 
\family typewriter
griddedInterpolant
\family default
 to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The interpolation method can be changed with the field 
\begin_inset Formula $POL.spl\textrm{\_}meth$
\end_inset

.
\end_layout

\end_inset

.
 This interpolation method uses a cubic spline determined with not-a-knot
 end conditions, which results in a twice differentiable spline.
 When such a cubic spline is used to approximate a four times differentiable
 function the convergence is 
\begin_inset Formula $\mathcal{O}\left(q^{-4}\right)$
\end_inset

, where 
\begin_inset Formula $q$
\end_inset

 is the number of nodes per dimension 
\begin_inset CommandInset citation
LatexCommand citep
key "de1978practical"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
For the univariate case with 
\begin_inset Formula $q$
\end_inset

 data points 
\begin_inset Formula $\left(x_{1},y_{1}\right),\ldots,\left(x_{q},y_{q}\right)$
\end_inset

 a cubic spline takes the piece-wise form:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
S_{1}\left(x\right) & =y_{1}+\theta_{1,1}\Delta x_{1}+\theta_{1,2}\Delta x_{1}^{2}+\theta_{1,3}\Delta x_{1}^{3}\quad\textrm{for}\;x\in\left[x_{1},x_{2}\right]\\
S_{2}\left(x\right) & =y_{2}+\theta_{2,1}\Delta x_{2}+\theta_{2,2}\Delta x_{2}^{2}+\theta_{2,3}\Delta x_{2}^{3}\quad\textrm{for}\;x\in\left[x_{2},x_{3}\right]\\
\vdots & \quad\vdots\\
S_{q-1}\left(x\right) & =y_{q-1}+\theta_{q-1,1}\Delta x_{q-1}+\theta_{q-1,2}\Delta x_{q-1}^{2}+\theta_{q-1,3}\Delta x_{q-1}^{3}\quad\textrm{for}\;x\in\left[x_{q-1},x_{q}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
with 
\begin_inset Formula $\Delta x_{i}=x-x_{i}.$
\end_inset

 
\end_layout

\begin_layout Standard
This univariate spline has 
\begin_inset Formula $3\left(q-1\right)$
\end_inset

 coefficients, which can be determined with the following conditions.
 At the interior points the function needs to be continuous, which gives
 us 
\begin_inset Formula $q-1$
\end_inset

 conditions:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
S_{i}\left(x_{i+1}\right) & =y_{i+1}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
In addition the first and second derivative have to be continuous at the
 interior points, which gives us two times 
\begin_inset Formula $q-2$
\end_inset

 conditions:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
S_{i}^{'}\left(x_{i+1}\right) & =S_{i+1}^{'}\left(x_{i+1}\right)\\
S_{i}^{''}\left(x_{i+1}\right) & =S_{i+1}^{''}\left(x_{i+1}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The not-a-knot end conditions require that the third derivative is also
 continuous at the gridpoints 
\begin_inset Formula $x_{2}$
\end_inset

 and 
\begin_inset Formula $x_{q-1}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
S_{1}^{'''}\left(x_{2}\right) & =S_{2}^{'''}\left(x_{2}\right)\\
S_{q-2}^{'''}\left(x_{q-1}\right) & =S_{q-1}^{'''}\left(x_{q-1}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
This yields a linear system of 
\begin_inset Formula $3\left(q-1\right)$
\end_inset

 equations in the univariate case.
 With multi-dimensional interpolation each dimension is treated independently,
 and sequential one-dimensional interpolation is carried out
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Matlab does not specify the algorithm for multi-dimensional interpolation,
 but the results are equivalent to sequential one dimensional interpolation.
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection*
Spline with Direct Computation
\end_layout

\begin_layout Standard
The algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_dir'}
\end_layout

\end_inset

 uses Direct Computation as discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Solutaion_at_grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The objective is equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DIR_objective"
plural "false"
caps "false"
noprefix "false"

\end_inset

: solve the residual 
\begin_inset Formula $R$
\end_inset

 at each gridpoint by adjusting the policy variable at the gridpoints.
 We need to numerically approximate the full Jacobian matrix, because a
 change in the policy variable at one gridpoint will change the spline,
 and therewith affect the solution at other gridpoints.
 With multiple policy variables the Jacobian of the system of equations
 will be an 
\begin_inset Formula $dm\times dm$
\end_inset

  matrix, where 
\begin_inset Formula $m$
\end_inset

 is the total number of gridpoints, and 
\begin_inset Formula $d$
\end_inset

 the number of policy variables.
\end_layout

\begin_layout Subsection*
Spline with Time Iteration
\end_layout

\begin_layout Standard
The algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_tmi'}
\end_layout

\end_inset

 uses Time Iteration as discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Solutaion_at_grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We solve the residual function at each gridpoint by choosing the period
 
\begin_inset Formula $t$
\end_inset

 policy variable, holding the period 
\begin_inset Formula $t+1$
\end_inset

 policy function constant.
 For a single policy variable the solution at each gridpoint does not affect
 the solution at other gridpoints, and the Jacobian matrix will only have
 entries on the diagonal.
 With multiple variables the Jacobian matrix consists of repeated blocks
 of diagonal matrices.
 
\end_layout

\begin_layout Section
General: construction of polynomials
\begin_inset CommandInset label
LatexCommand label
name "sec:General-polynomial_constr"

\end_inset


\end_layout

\begin_layout Standard
For 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smolyak'}
\end_layout

\end_inset

 the polynomials are constructed with a similar procedure.
 The multivariate polynomial 
\begin_inset Formula $\Omega$
\end_inset

 (
\begin_inset Formula $m\times p$
\end_inset

 matrix) is constructed with three elements: the initial grid 
\begin_inset Formula $xx$
\end_inset

, the array 
\begin_inset Formula $\Phi$
\end_inset

 which consists of univariate polynomial terms, the matrix 
\begin_inset Formula $LL$
\end_inset

 which compiles the polynomial.
 
\end_layout

\begin_layout Standard
The following dimensions are used:
\end_layout

\begin_layout Itemize
\begin_inset Formula $m$
\end_inset

 the total number of gridpoints;
\end_layout

\begin_layout Itemize
\begin_inset Formula $n$
\end_inset

 the number of state variables;
\end_layout

\begin_layout Itemize
\begin_inset Formula $p$
\end_inset

 the total number of (multivariate) polynomial terms;
\end_layout

\begin_layout Itemize
\begin_inset Formula $k$
\end_inset

 the maximum degree of a (univariate) polynomial.
\end_layout

\begin_layout Subsubsection*
Initial grid 
\begin_inset Formula $x$
\end_inset


\end_layout

\begin_layout Standard
The initial grid 
\begin_inset Formula $x$
\end_inset

 is an 
\begin_inset Formula $m\times n$
\end_inset

 matrix, where each column 
\begin_inset Formula $j$
\end_inset

 is a state variable 
\begin_inset Formula $x_{j}$
\end_inset

 (
\begin_inset Formula $m\times1$
\end_inset

).
\end_layout

\begin_layout Subsubsection*
Univariate polynomials terms
\end_layout

\begin_layout Standard
We have to differentiate between monomials used for the algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

 and Chebyshev polynomials used for the algorithms with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smolyak'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For univariate monomial terms are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
T_{i}\left(x\right) & =x^{i}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
For Chebyshev polynomials (of the first kind) the univariate terms have
 the recurrent relation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
T_{0}\left(\tilde{x}\right) & =1\nonumber \\
T_{1}\left(\tilde{x}\right) & =\tilde{x}\nonumber \\
T_{v+1}\left(\tilde{x}\right) & =2\tilde{x}T_{v}\left(\tilde{x}\right)-T_{v-1}\left(\tilde{x}\right)\label{eq:Cheb_recursive-1}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\tilde{x}$
\end_inset

 is a scaled down variable to the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 The transformation is a function 
\begin_inset Formula $\tilde{x}\left(x\right)$
\end_inset

 (see equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:SCAL_DW"
plural "false"
caps "false"
noprefix "false"

\end_inset

) and this allows us to write 
\begin_inset Formula $T_{v+1}\left(x\right)=T_{v+1}\left(\tilde{x}\left(x\right)\right)$
\end_inset

.
 Using index 
\begin_inset Formula $j=1,\ldots,n$
\end_inset

 for the state variables we get:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
T_{i}\left(x_{j}\right) & =\begin{cases}
x_{j}^{i} & \textrm{for monomials}\\
T_{i}\left(\tilde{x}\left(x_{j}\right)\right) & \textrm{for Chebyshev polynomials}
\end{cases}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Note that each 
\begin_inset Formula $T_{i}\left(x_{j}\right)$
\end_inset

 is an 
\begin_inset Formula $m\times1$
\end_inset

 vector.
\end_layout

\begin_layout Subsubsection*
Matrix of univariate polynomial terms 
\begin_inset Formula $\Phi$
\end_inset


\end_layout

\begin_layout Standard
The array 
\begin_inset Formula $\Phi$
\end_inset

 consists of all univariate polynomial terms up to order 
\begin_inset Formula $k$
\end_inset

.
 The dimensions of 
\begin_inset Formula $\Phi$
\end_inset

 are 
\begin_inset Formula $m\times k\times n$
\end_inset

, where 
\begin_inset Formula $m$
\end_inset

 is the number of nodes in the initial grid, 
\begin_inset Formula $k$
\end_inset

 is the degree of the polynomial, and 
\begin_inset Formula $n$
\end_inset

 is the number of state variables.
\end_layout

\begin_layout Standard
For state variable 
\begin_inset Formula $j$
\end_inset

 the polynomial terms are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\Phi^{j} & =\left[T_{1}\left(x_{j}\right),\ldots,T_{k}\left(x_{j}\right)\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
which is an 
\begin_inset Formula $m\times k$
\end_inset

 matrix.
 Note that we omit 
\begin_inset Formula $T_{0}=1$
\end_inset

.
 We concatenate each 
\begin_inset Formula $\Phi^{j}$
\end_inset

 in the third dimension.
\end_layout

\begin_layout Subsubsection*
Element index 
\begin_inset Formula $LL$
\end_inset


\end_layout

\begin_layout Standard
The matrix 
\begin_inset Formula $L$
\end_inset

 (
\begin_inset Formula $p\times n$
\end_inset

) consists of indices that refer to the elements in 
\begin_inset Formula $\Phi$
\end_inset

.
 The element 
\begin_inset Formula $l_{i,j}$
\end_inset

 refers to 
\begin_inset Formula $T_{l_{i,j}}\left(x_{j}\right)$
\end_inset

, meaning the order 
\begin_inset Formula $l_{i,j}$
\end_inset

 polynomial for state variable 
\begin_inset Formula $j$
\end_inset

.
 The elements in row 
\begin_inset Formula $i$
\end_inset

 are multiplied by each other to form column 
\begin_inset Formula $i$
\end_inset

 of the polynomial matrix 
\begin_inset Formula $\Omega$
\end_inset

, meaning 
\begin_inset Formula $\Omega_{i}=\prod_{j=1}^{n}T_{l_{i,j}}\left(x_{j}\right)$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
Polynomial
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $m\times p$
\end_inset

 matrix 
\begin_inset Formula $\Omega$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\Omega\left(x\right) & =\left[\begin{array}{ccc}
\Omega_{1}\left(x_{1}\right) & \cdots & \Omega_{p}\left(x_{1}\right)\\
\vdots & \ddots & \vdots\\
\Omega_{1}\left(x_{m}\right) & \cdots & \Omega_{p}\left(x_{m}\right)
\end{array}\right]\label{eq:OMG_Matrix}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
In our code we use the names 
\begin_inset Formula $XX\textrm{\_}poly$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Or 
\begin_inset Formula $XX\textrm{\_}poly\textrm{\_}dw$
\end_inset

 for scaled down variables.
\end_layout

\end_inset

 for 
\begin_inset Formula $\Omega$
\end_inset

, and 
\begin_inset Formula $poly\textrm{\_}elem$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
For the Smolyak algorithm 
\begin_inset Formula $smol\textrm{\_}el\textrm{\_}ani$
\end_inset

 is 
\begin_inset Formula $L+1$
\end_inset

 and 
\begin_inset Formula $\Phi$
\end_inset

 also contains 
\begin_inset Formula $T_{0}=1$
\end_inset

.
\end_layout

\end_inset

 for 
\begin_inset Formula $L$
\end_inset

.
 The matrix 
\begin_inset Formula $\Omega$
\end_inset

 is constructed as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

XX_poly = ones(mm,pp);%initiate with ones
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for ii = 1:pp
\end_layout

\begin_layout Plain Layout

  for jj = 1:nn
\end_layout

\begin_layout Plain Layout

	if LL(ii,jj)>0%omit T_0=1 terms
\end_layout

\begin_layout Plain Layout

    	XX_poly(:,ii) = XX_poly(:,ii) .* Phi(:,poly_elem(ii,jj),jj);
\end_layout

\begin_layout Plain Layout

	end
\end_layout

\begin_layout Plain Layout

  end
\end_layout

\begin_layout Plain Layout

end
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Complete polynomials
\end_layout

\begin_layout Standard
For the algorithms 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 we use complete polynomials.
 A complete polynomial of degree 
\begin_inset Formula $k$
\end_inset

 in 
\begin_inset Formula $n$
\end_inset

 dimensions consists of all possible combinations with 
\begin_inset Formula $\sum_{j=1}^{n}l_{j}\leq k$
\end_inset

.
 Using short-hand notation 
\begin_inset Formula $T_{i}^{j}=T_{i}\left(x_{j}\right)$
\end_inset

 a complete polynomial of degree 
\begin_inset Formula $k$
\end_inset

 in 
\begin_inset Formula $n$
\end_inset

 dimensions is 
\begin_inset CommandInset citation
LatexCommand citep
key "judd1998numerical"
literal "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\mathscr{P}_{k}^{n} & \equiv\left\{ T_{l_{1}}^{1}\cdots T_{l_{n}}^{n}\mid\sum_{j=1}^{n}l_{j}\leq k,0\leq l_{1},\ldots,l_{n}\right\} \label{eq:Compl_polynomial}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The toolbox allows for asymmetric polynomials where state variable 
\begin_inset Formula $j$
\end_inset

 has a maximum degree 
\begin_inset Formula $k_{j}$
\end_inset

 polynomial
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\noindent
The field 
\begin_inset Formula $ord\textrm{\_}vec$
\end_inset

 in the input argument 
\begin_inset Formula $meth\textrm{\_}spec$
\end_inset

 is the 
\begin_inset Formula $1\times n$
\end_inset

 vector 
\begin_inset Formula $\left[k_{1},\ldots,k_{n}\right]$
\end_inset

.
\end_layout

\end_inset

, ie.
 the restriction 
\begin_inset Formula $l_{j}\leq k_{j}$
\end_inset

.
 
\end_layout

\begin_layout Standard
We use complete polynomials for the algorithms 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

, because they achieve almost the same accuracy as a tensor product, despite
 having a lower number of coefficients 
\begin_inset CommandInset citation
LatexCommand citep
key "judd1992projection"
literal "false"

\end_inset

.
 For a complete polynomial the number of coefficients grows polynomially
 in the number of dimensions, while tensor product grow exponentially 
\begin_inset CommandInset citation
LatexCommand citep
key "judd1998numerical"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Subsection*
Example with two dimensions
\end_layout

\begin_layout Standard
To illustrate the construction of a complete polynomial we use a two dimensional
 example, which is also used in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Assume we have two state variables with bounds 
\begin_inset Formula $\left[1,3\right]$
\end_inset

 for 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $\left[10,25\right]$
\end_inset

 for 
\begin_inset Formula $x_{2}$
\end_inset

.
\end_layout

\begin_layout Standard
We start with the monomial case, and use 3 and 4 gridpoints for 
\begin_inset Formula $x_{1}$
\end_inset

 and for 
\begin_inset Formula $x_{2}$
\end_inset

, respectively.
 With equidistant nodes the resulting fields are 
\begin_inset Formula $gridVecs\{1,1\}=\left[\begin{array}{ccc}
1 & 2 & 3\end{array}\right]$
\end_inset

 for 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $gridVecs\{1,2\}=\left[\begin{array}{cccc}
10 & 15 & 20 & 25\end{array}\right]$
\end_inset

 for 
\begin_inset Formula $x_{2}$
\end_inset

.
 The initial grid (
\begin_inset Formula $12\times2$
\end_inset

) is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
xx & =\left[\begin{array}{cccccccccccc}
1 & 2 & 3 & 1 & 2 & 3 & 1 & 2 & 3 & 1 & 2 & 3\\
10 & 10 & 10 & 15 & 15 & 15 & 20 & 20 & 20 & 25 & 25 & 25
\end{array}\right]^{\intercal}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We want to construct a complete polynomial of degree 
\begin_inset Formula $k=2$
\end_inset

.
 We construct the matrix 
\begin_inset Formula $\Phi^{j}$
\end_inset

 (
\begin_inset Formula $m\times k)$
\end_inset

 for 
\begin_inset Formula $j=1,2$
\end_inset

 consisting of the univariate monomials up to order 2:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\Phi^{j} & =\left[x_{j},x_{j}^{2}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We construct the polynomial with the matrix 
\begin_inset Formula $LL$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
LL & =\left[\begin{array}{cccccc}
0 & 0 & 1 & 0 & 1 & 2\\
0 & 1 & 0 & 2 & 1 & 0
\end{array}\right]^{\intercal}
\end{align*}

\end_inset

Each element 
\begin_inset Formula $l_{i,j}$
\end_inset

 in 
\begin_inset Formula $LL$
\end_inset

 refers to a polynomial term in the column vector 
\begin_inset Formula $\Phi^{j}\left(:,i\right)$
\end_inset

 with 
\begin_inset Formula $\Phi^{j}\left(:,0\right)=1$
\end_inset

.
 The polynomial terms in row 
\begin_inset Formula $i$
\end_inset

 are multiplied by each other to form column 
\begin_inset Formula $i$
\end_inset

 of the polynomial matrix 
\begin_inset Formula $\Omega$
\end_inset

.
 For example, row four of 
\begin_inset Formula $LL$
\end_inset

 is 
\begin_inset Formula $\left[2,0\right]$
\end_inset

, meaning 
\begin_inset Formula $x_{1}^{2}x_{2}^{0}=x_{1}^{2}$
\end_inset

, which is the entry in the fourth column of 
\begin_inset Formula $\Omega$
\end_inset

.
 The complete polynomial 
\begin_inset Formula $\Omega\left(x\right)$
\end_inset

 (dimension 
\begin_inset Formula $12\times6$
\end_inset

) is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\Omega\left(x\right) & =\left[\begin{array}{cccccc}
1 & x_{1} & x_{2} & x_{1}^{2} & x_{1}x_{2} & x_{2}^{2}\end{array}\right]\label{eq:OMG_ex_mono}
\end{align}

\end_inset


\end_layout

\begin_layout Section
Monomials
\begin_inset CommandInset label
LatexCommand label
name "sec:Monomials"

\end_inset


\end_layout

\begin_layout Standard
With monomials the policy function is approximated with a complete polynomial.
 The grid with monomial basis functions consists of equidistant nodes.
 Monomials are simple to use, but have three disadvantages compared to Chebyshev
 polynomials.
 The first is that monomials are collinear.
 For example, 
\begin_inset Formula $x^{2}$
\end_inset

 and 
\begin_inset Formula $x^{4}$
\end_inset

are very close to each other around 
\begin_inset Formula $0$
\end_inset

.
 The second disadvantage is that monomials are not scaled.
 For example, the term 
\begin_inset Formula $x^{4}$
\end_inset

 will have a complete different magnitude than the term 
\begin_inset Formula $x$
\end_inset

.
 The third disadvantage is known as Runge's phenomenon, which results in
 oscillation at the edges of an interval for polynomials of high degree
 when equidistant nodes are used.
 
\end_layout

\begin_layout Standard
To construct complete polynomials we use the procedure described above in
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-polynomial_constr"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For example, the approximation with a complete polynomial of degree two
 with two state variables 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{Y}\left(x;\theta\right) & =\theta_{1}+\theta_{2}x_{1}+\theta_{3}x_{2}+\theta_{4}x_{1}^{2}+\theta_{5}x_{1}x_{2}+\theta_{6}x_{2}^{2}\label{eq:Mono_2nd_ord}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Using the notation 
\begin_inset Formula $\Omega_{i}\left(x\right)$
\end_inset

 to refer to multivariate polynomial term 
\begin_inset Formula $i$
\end_inset

 we may also write:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\hat{Y}\left(x;\theta\right) & =\sum_{i=1}^{p}\theta_{i}\Omega_{i}\left(x\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $p$
\end_inset

 is the total number of polynomial terms.
 Using the matrix notation as in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:OMG_ex_mono"
plural "false"
caps "false"
noprefix "false"

\end_inset

 this is equivalent to:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\hat{Y}\left(x;\theta\right) & =\Omega\left(x\right)\theta
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection*
Monomials with Minimization of Squared Errors
\end_layout

\begin_layout Standard
The algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

 minimizes the squared errors at the gridpoints by setting the coefficients
 
\begin_inset Formula $\theta.$
\end_inset

 Assume we have a residual function 
\begin_inset Formula $R\left(x;\theta\right)$
\end_inset

, which is evaluated at gridpoints 
\begin_inset Formula $i=1,\ldots,m$
\end_inset

.
 The objective is to minimize the sum of the square residuals: 
\begin_inset Formula 
\begin{align}
\min_{\theta} & \sum_{i=1}^{m}R\left(x_{i};\theta\right)^{2}\label{eq:Mono_MSE_obj}
\end{align}

\end_inset

where 
\begin_inset Formula $m$
\end_inset

 is the total number of gridpoints.
 To minimize 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Mono_MSE_obj"
plural "false"
caps "false"
noprefix "false"

\end_inset

 the default algorithm is Matlab's 
\family typewriter
lsqnonlin
\family default
 with a `trust-region' algorithm.
\end_layout

\begin_layout Section
Complete Chebyshev polynomials
\begin_inset CommandInset label
LatexCommand label
name "sec:Complete-Chebyshev-polynomials"

\end_inset


\end_layout

\begin_layout Standard
The most commonly used basis functions are Chebyshev polynomials.
 Chebyshev polynomials are superior to monomial basis functions for three
 reasons.
 The first is that Chebyshev polynomials of the first kind have the discrete
 orthogonality property:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\sum_{k=0}^{N-1}T_{i}\left(x_{k}\right)T_{j}\left(x_{k}\right) & =0\quad\textrm{if}\;i\neq j
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $N$
\end_inset

 is any integer greater than 
\begin_inset Formula $\max\left(i,j\right)$
\end_inset

, and 
\begin_inset Formula $x_{k}$
\end_inset

 are the Chebyshev nodes (see below), and 
\begin_inset Formula $T_{i}\left(x\right)$
\end_inset

 is given by the recursive relation in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Cheb_recursive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Note that this orthogonality is defined for the one dimensional case.
 
\end_layout

\begin_layout Standard
The second reason for the superiority of Chebyshev polynomials is that they
 are scaled such that the absolute value of the extrema never exceeds 1.
 The third reason is that they are very effective at reducing Runge's phenomenon.
 Runge's phenomenon is that polynomial interpolation results in oscillation
 at the edges of an interval for polynomials of high degree when equidistant
 nodes are used.
 This phenomenon is avoided with Chebyshev nodes.
\end_layout

\begin_layout Standard
To make use of the favorable properties of Chebyshev polynomials it is necessary
 to linearly map variables from the interval 
\begin_inset Formula $\left[\underline{x},\overline{x}\right]$
\end_inset

 to 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 This transformation is given by:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\tilde{x}\left(x\right) & =2\frac{x-\underline{x}}{\overline{x}-\underline{x}}-1\label{eq:SCAL_DW}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
which we call the scaling down of variables.
 The inverse of this map, which we call scaling up, is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
x\left(\tilde{x}\right) & =\frac{\left(\tilde{x}+1\right)\left(\overline{x}-\underline{x}\right)}{2}+\underline{x}\label{eq:SCAL_UP}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where subscripts are the degree of the polynomial.
 
\end_layout

\begin_layout Standard
To construct complete polynomials we use the procedure described above in
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-polynomial_constr"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For example, the complete Chebyshev polynomial of degree two with two variables
 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

 is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{Y}\left(x;\theta\right) & =\theta_{1}+\theta_{2}\tilde{x}\left(x_{1}\right)+\theta_{3}\tilde{x}\left(x_{2}\right)+\theta_{4}\left(2\tilde{x}\left(x_{1}\right)^{2}-1\right)+\theta_{5}\tilde{x}\left(x_{1}\right)\tilde{x}\left(x_{2}\right)+\theta_{6}\left(2\tilde{x}\left(x_{2}\right)^{2}-1\right)\label{eq:Cheb_2nd_ord}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\theta$
\end_inset

 are the coefficients on the polynomial terms 
\begin_inset Formula $i=1,\ldots,p$
\end_inset

.
 Alternatively we can write:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{Y}\left(x;\theta\right) & =\sum_{i=1}^{p}\theta_{i}\Omega_{i}\left(x\right)\label{eq:Cheb_approx_pol}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\Omega_{i}\left(x\right)$
\end_inset

 refers to the multivariate polynomial term in column 
\begin_inset Formula $i$
\end_inset

 of 
\begin_inset Formula $\Omega$
\end_inset

, and 
\begin_inset Formula $p$
\end_inset

 is the total number of polynomial terms.
 In matrix notation this becomes:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\hat{Y}\left(x;\theta\right) & =\Omega\left(x\right)\theta\label{eq:Cheb_Matrix}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
To construct the initial grid we use the Chebyshev nodes, which are in the
 interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 These nodes are determined by the formula:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\tilde{x}_{i} & =\cos\left(\frac{2i-1}{2q}\pi\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
for 
\begin_inset Formula $i=1,\ldots,q$
\end_inset

.
 The 
\begin_inset Formula $q$
\end_inset

 nodes are the roots of the polynomial 
\begin_inset Formula $T_{q}\left(x\right)$
\end_inset

.
 For example for 
\begin_inset Formula $q=2$
\end_inset

 the nodes are the roots of 
\begin_inset Formula $T_{2}\left(x\right)=2\tilde{x}^{2}-1$
\end_inset

, which are 
\begin_inset Formula $\pm\frac{1}{2}\sqrt{2}$
\end_inset

.
 Note that these roots never include the bounds 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 
\end_layout

\begin_layout Subsection*
Chebyshev with Galerkin's method
\end_layout

\begin_layout Standard
With the algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

 we use Galerkin's method to obtain the coefficients 
\begin_inset Formula $\theta$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Cheb_approx_pol"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We calculate the product of the residual function 
\begin_inset Formula $R\left(x;\theta\right)$
\end_inset

 and each polynomial term 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Omega_{j}\left(x\right)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 at all gridpoints 
\begin_inset Formula $i=1,\ldots,m$
\end_inset

.
 The objective for each coefficient 
\begin_inset Formula $\theta_{j}$
\end_inset

 is to set the sum of these products to zero:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
0 & =\sum_{i=1}^{m}R\left(x_{i};\theta\right)\Omega_{j}\left(x_{i}\right)\label{eq:OBJ_galerkin}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
As there are 
\begin_inset Formula $j=1,\ldots,p$
\end_inset

 coefficients this is a system of 
\begin_inset Formula $p$
\end_inset

 equations in 
\begin_inset Formula $p$
\end_inset

 unknowns.
 This system is solved using a non-linear equation solver, based on a Newton-typ
e of algorithm.
 By default we use Matlab's 
\family typewriter
fsolve
\family default
 with the `trust-region-dogleg' algorithm.
 If multiple policy variables need to be solved each policy variable has
 its own residual function.
 With 
\begin_inset Formula $d$
\end_inset

 policy variables this is a system of 
\begin_inset Formula $dp$
\end_inset

 equations.
 For a large number of coefficients it is more efficient to use Time Iteration.
 
\end_layout

\begin_layout Subsection*
Chebyshev with Time Iteration
\end_layout

\begin_layout Standard
The algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_tmi'}
\end_layout

\end_inset

 solves the residual function at the gridpoints with Time Iteration as explained
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Solutaion_at_grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Given the solution at the gridpoints the coefficients 
\begin_inset Formula $\theta$
\end_inset

 are obtained by solving a least squares problem.
 The solution at the gridpoints is a 
\begin_inset Formula $m\times1$
\end_inset

 vector 
\begin_inset Formula $\hat{Y}\left(x\right)$
\end_inset

, and the 
\begin_inset Formula $m\times p$
\end_inset

 matrix 
\begin_inset Formula $\Omega$
\end_inset

 is defined in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Cheb_Matrix"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The coefficients 
\begin_inset Formula $\theta$
\end_inset

 are determined using Matlab's 
\family typewriter
mldivide
\family default
, which gives the least squares solution of a linear system of equations
 
\begin_inset Formula $\hat{Y}=\Omega\theta$
\end_inset

 when it is overidentified.
 
\end_layout

\begin_layout Subsection*
Chebyshev with Minimization of Squared Error
\end_layout

\begin_layout Standard
The algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_mse'}
\end_layout

\end_inset

 minimizes the squared errors at the gridpoints by setting the coefficients
 as with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

.
 The objective is the same and given by equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Mono_MSE_obj"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The differences are the scaling down of variables, the polynomial itself,
 and the nodes.
 To solve the objective we use Matlab's 
\family typewriter
lsqnonlin
\family default
 with a `trust-region' algorithm by default.
\end_layout

\begin_layout Section
Smolyak's algorithm
\begin_inset CommandInset label
LatexCommand label
name "sec:Smolyak"

\end_inset


\end_layout

\begin_layout Standard
Smolyak's algorithm can be implemented in various ways.
 We use the method described by 
\begin_inset CommandInset citation
LatexCommand citet
key "judd2014smolyak"
literal "false"

\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We implemented the provided Matlab code: Rafa Valero (2021), Smolyak Anisotropic
 Grid (
\begin_inset CommandInset href
LatexCommand href
target "https://www.mathworks.com/matlabcentral/fileexchange/50963-smolyak-anisotropic-grid"

\end_inset

), MATLAB Central File Exchange.
 Retrieved November, 2021.
\begin_inset CommandInset label
LatexCommand label
name "fn:Smolyak_code"

\end_inset


\end_layout

\end_inset

.
 The algorithm constructs a sparse grid consisting of Chebyshev extrema.
 The solution at the gridpoints determines the coefficients of a sparse
 Chebyshev polynomial.
 The (sparse) gridpoints are concentrated on the axis and the corners of
 the grid
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
See for example Figure 11 in 
\begin_inset CommandInset citation
LatexCommand citet
key "fernandez2016solution"
literal "false"

\end_inset

.
\end_layout

\end_inset

.
 The solution at the gridpoints is computed with Direct Computation or Time
 Iteration.
 With Direct Computation we use the coefficients 
\begin_inset Formula $\theta$
\end_inset

 as choice variables.
 With Time Iteration we solve the policy variable at the gridpoints, and
 obtain the coefficients by solving a linear system of equations.
\end_layout

\begin_layout Standard
For the construction of the isotropic sparse grid
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The toolbox allows for the construction of an anisotropic grid as described
 by 
\begin_inset CommandInset citation
LatexCommand citet
key "judd2014smolyak"
literal "false"

\end_inset

.
 The procedure is very similar, where the accuracy parameter 
\begin_inset Formula $\mu$
\end_inset

 is specified for each dimension.
\end_layout

\end_inset

 we largely follow the exposition by 
\begin_inset CommandInset citation
LatexCommand citet
key "fernandez2016solution"
literal "false"

\end_inset

.
 First we choose the accuracy parameter 
\begin_inset Formula $\mu$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In the notation of 
\begin_inset CommandInset citation
LatexCommand citet
key "fernandez2016solution"
literal "false"

\end_inset

: 
\begin_inset Formula $\mu=q-n$
\end_inset

.
\end_layout

\end_inset

.
 The degree of the Chebyshev polynomial will be 
\begin_inset Formula $2^{\mu}$
\end_inset

.
 For accuracy 
\begin_inset Formula $\mu>0$
\end_inset

 there are 
\begin_inset Formula $q_{\mu}=2^{\mu}+1$
\end_inset

 number of nodes in each dimension, and for 
\begin_inset Formula $\mu=0$
\end_inset

 there is one node 
\begin_inset Formula $q_{0}=1$
\end_inset

.
 
\end_layout

\begin_layout Standard
The extrema of a univariate Chebyshev polynomial (also called Gauss-Lobotto
 nodes) for given 
\begin_inset Formula $\mu$
\end_inset

 with 
\begin_inset Formula $j=1,\ldots,q_{\mu}$
\end_inset

 are 
\begin_inset CommandInset citation
LatexCommand citep
key "judd2014smolyak"
literal "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\zeta_{j}^{\mu} & =\begin{cases}
0 & \textrm{for}\:\mu=0\\
-\cos\left(\frac{j-1}{q_{\mu}-1}\pi\right) & \textrm{for}\:\mu>0
\end{cases}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
We define the nested sets:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathcal{G}^{\mu} & =\left\{ \zeta_{1}^{\mu},\ldots,\zeta_{q_{\mu}}^{\mu}\right\} 
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\mathcal{G}^{\mu}\subset\mathcal{G}^{\mu+1}$
\end_inset

.
 The first three sets are: 
\begin_inset Formula $\mathcal{G}^{0}=\left\{ 0\right\} $
\end_inset

, 
\begin_inset Formula $\mathcal{G}^{1}=\left\{ -1,0,1\right\} $
\end_inset

, and 
\begin_inset Formula $\mathcal{G}^{2}=\left\{ -1,-\frac{\sqrt{2}}{2},0,\frac{\sqrt{2}}{2},1\right\} $
\end_inset

.
 We introduce the notation 
\begin_inset Formula $T_{k}^{i}=T_{k}\left(\tilde{x}_{i}\right)$
\end_inset

, which is the univariate Chebyshev basis function of degree 
\begin_inset Formula $k$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
in dimension 
\begin_inset Formula $i$
\end_inset

 as defined in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Cheb_recursive-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The nodes 
\begin_inset Formula $\mathcal{G}^{\mu}$
\end_inset

 correspond to the extrema of the basis functions 
\begin_inset Formula $T_{0},\ldots,T_{2^{\mu}}$
\end_inset

, with the extremum of 
\begin_inset Formula $T_{0}$
\end_inset

 set to 
\begin_inset Formula $0$
\end_inset

.
 
\end_layout

\begin_layout Standard
The multivariate sparse grid is a union of the Cartesian products
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "fernandez2016solution"
literal "false"

\end_inset

 include Cartesian products with 
\begin_inset Formula $\sum\mu_{n}<\mu$
\end_inset

, but since 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathcal{G}^{\mu}\subset\mathcal{G}^{\mu+1}$
\end_inset

 these lower ranked Cartesian products are redundant.
 For example 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\mathcal{G}^{1}\times\mathcal{G}^{0}\subset\mathcal{G}^{2}\times\mathcal{G}^{0}$
\end_inset


\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\mathbb{G}\left(\mu,n\right) & =\bigcup_{\sum\mu_{n}=\mu}\left(\mathcal{G}^{\mu_{1}}\times\ldots\times\mathcal{G}^{\mu_{n}}\right)\label{eq:Union_Smolyak_grid}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
For example with 
\begin_inset Formula $n=2$
\end_inset

 dimensions and 
\begin_inset Formula $\mu=1$
\end_inset

 (meaning a degree 
\begin_inset Formula $2^{\mu}=2$
\end_inset

 polynomial) we get:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathbb{G}\left(1,2\right) & =\bigcup_{\sum\mu_{n}=1}\left(\mathcal{G}^{\mu_{1}}\times\mathcal{G}^{\mu_{2}}\right)\\
 & =\left(\mathcal{G}^{1}\times\mathcal{G}^{0}\right)\cup\left(\mathcal{G}^{0}\times\mathcal{G}^{1}\right)\\
 & =\left\{ \left(-1,0\right),\left(0,0\right),\left(1,0\right)\right\} \cup\left\{ \left(0,-1\right),\left(0,0\right),\left(0,1\right)\right\} \\
 & =\left\{ \left(0,0\right),\left(-1,0\right),\left(1,0\right),\left(0,-1\right),\left(0,1\right)\right\} 
\end{align*}

\end_inset

Similarly with 
\begin_inset Formula $n=2$
\end_inset

 dimensions and 
\begin_inset Formula $\mu=2$
\end_inset

 (meaning a degree 
\begin_inset Formula $2^{\mu}=4$
\end_inset

 polynomial) we get:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathbb{G}\left(2,2\right) & =\bigcup_{\sum\mu_{n}=2}\left(\mathcal{G}^{\mu_{1}}\times\mathcal{G}^{\mu_{2}}\right)\\
 & =\left(\mathcal{G}^{2}\times\mathcal{G}^{0}\right)\cup\left(\mathcal{G}^{0}\times\mathcal{G}^{2}\right)\cup\left(\mathcal{G}^{1}\times\mathcal{G}^{1}\right)\cup\left(\mathcal{G}^{1}\times\mathcal{G}^{1}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Note that 
\begin_inset Formula $\mathcal{G}^{1}\times\mathcal{G}^{0}\subset\mathcal{G}^{2}\times\mathcal{G}^{0}$
\end_inset

, so 
\begin_inset Formula $\mathbb{G}\left(1,2\right)\subset\mathbb{G}\left(2,2\right)$
\end_inset

 .
\end_layout

\begin_layout Standard
The sparse grid exactly identifies the coefficients of a polynomial, and
 we can infer from the grid, which polynomial terms are included.
 For example, for a two dimensional grid (
\begin_inset Formula $n=2$
\end_inset

) and an accuracy 
\begin_inset Formula $\mu=1$
\end_inset

 we get a degree 
\begin_inset Formula $2^{\mu}=2$
\end_inset

 polynomial.
 The grid consists of the sets
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $\left(\mathcal{G}^{1}\times\mathcal{G}^{0}\right)\cup\left(\mathcal{G}^{0}\times\mathcal{G}^{1}\right)$
\end_inset

.
 This corresponds to a polynomial consisting of
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 only univariate terms 
\begin_inset Formula $T_{0}$
\end_inset

, 
\begin_inset Formula $T_{1}^{i}$
\end_inset

, and 
\begin_inset Formula $T_{2}^{i}$
\end_inset

 for 
\begin_inset Formula $i=1,2$
\end_inset

.
 The degree 2 bivariate terms 
\begin_inset Formula $T_{1}^{i}T_{1}^{j}$
\end_inset

 for 
\begin_inset Formula $i\neq j$
\end_inset

 are omitted.
\end_layout

\begin_layout Standard
To generalize this we define the set of univariate Chebyshev polynomials
 up to order 
\begin_inset Formula $k$
\end_inset

 as 
\begin_inset Formula $\mathcal{T}_{i}^{k}=\left\{ T_{0}^{i},T_{1}^{i},\ldots,T_{k}^{i}\right\} $
\end_inset

.
 Note that for accuracy 
\begin_inset Formula $\mu$
\end_inset

 the degree of the polynomial is 
\begin_inset Formula $2^{\mu}$
\end_inset

.
 For example, in two dimensions with 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mu_{1}=2$
\end_inset

 and 
\begin_inset Formula $\mu_{2}=1$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 the Cartesian product 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathcal{G}^{2}\times\mathcal{G}^{1}$
\end_inset

 defines 15 gridpoints.
 The corresponding tensor product 
\begin_inset Formula $\mathcal{T}_{1}^{2^{\mu_{1}}}\otimes\mathcal{T}_{2}^{2^{\mu_{2}}}$
\end_inset

 is a set of 15 bivariate polynomials:
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula 
\begin{align}
\mathcal{T}_{1}^{4}\otimes\mathcal{T}_{2}^{2} & =\left\{ \begin{array}{ccc}
T_{0}^{1}T_{0}^{2}, & \ldots & ,T_{4}^{1}T_{0}^{2}\\
T_{0}^{1}T_{1}^{2}, & \ldots & ,T_{4}^{1}T_{1}^{2}\\
T_{0}^{1}T_{2}^{2}, & \ldots & ,T_{4}^{1}T_{2}^{2}
\end{array}\right\} \label{eq:Chebyshev_tensor_sets}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
This sparse grid and sparse set of polynomials is very effective at tackling
 the curse of the dimensionality.
 A standard Cartesian product with 
\begin_inset Formula $q$
\end_inset

 nodes in 
\begin_inset Formula $n$
\end_inset

 dimensions consists of a total of 
\begin_inset Formula $q^{n}$
\end_inset

 nodes.
 We would need at least 5 gridpoints in each dimension to estimate a degree
 4 complete polynomial.
 For 8 dimensions this would result in 
\begin_inset Formula $5^{8}=390,625$
\end_inset

 gridpoints to estimate a total of 495 coefficients.
 
\end_layout

\begin_layout Standard
The Smolyak algorithm with a sparse degree 4 polynomial (ie.
 
\begin_inset Formula $\mu=2$
\end_inset

) in 8 dimensions results in only 145 nodes and coefficients.
 The resulting polynomial consists of the univariate terms 
\begin_inset Formula $T_{0}$
\end_inset

, 
\begin_inset Formula $T_{1}^{i}$
\end_inset

, 
\begin_inset Formula $T_{2}^{i}$
\end_inset

, 
\begin_inset Formula $T_{3}^{i}$
\end_inset

, and 
\begin_inset Formula $T_{4}^{i}$
\end_inset

 for 
\begin_inset Formula $i=1,\ldots,8$
\end_inset

, and all possible combinations of the bivariate terms 
\begin_inset Formula $T_{1}^{i}T_{1}^{j}$
\end_inset

, 
\begin_inset Formula $T_{2}^{i}T_{1}^{j}$
\end_inset

, and 
\begin_inset Formula $T_{2}^{i}T_{2}^{j}$
\end_inset

 for 
\begin_inset Formula $i\neq j$
\end_inset

.
 Compared to a complete polynomial 350 terms are omitted by the Smolyak
 algorithm: the degree 3 terms 
\begin_inset Formula $T_{1}^{i}T_{1}^{j}T_{1}^{l}$
\end_inset

, and the degree 4 terms 
\begin_inset Formula $T_{1}^{i}T_{1}^{j}T_{1}^{l}T_{1}^{m}$
\end_inset

, 
\begin_inset Formula $T_{2}^{i}T_{1}^{j}T_{1}^{l}$
\end_inset

 and 
\begin_inset Formula $T_{3}^{i}T_{1}^{j}$
\end_inset

 for all possible combination with 
\begin_inset Formula $i\neq j\neq l\neq m$
\end_inset

.
 In general, a degree 4 Smolyak polynomial does not contain polynomial terms
 consisting of more than 2 variables.
 
\end_layout

\begin_layout Standard
Following the explanation by 
\begin_inset CommandInset citation
LatexCommand citet
key "judd2014smolyak"
literal "false"

\end_inset

 the polynomial results in the approximation of the policy variable:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\hat{Y}\left(x;\theta\right) & =\sum_{i=1}^{p}\theta_{i}\Omega_{i}\left(x\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $p$
\end_inset

 is the total number of polynomial terms, equal to the number of gridpoints
 
\begin_inset Formula $m$
\end_inset

, and 
\begin_inset Formula $\Omega_{i}\left(x\right)$
\end_inset

 are the multivariate polynomial terms as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-polynomial_constr"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 We can write in matrix notation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\hat{Y}\left(x;\theta\right) & =\Omega\left(x\right)\theta
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection*
Smolyak with Direct Computation
\end_layout

\begin_layout Standard
The algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_dir'}
\end_layout

\end_inset

 directly solves the residuals at the gridpoints by setting the coefficients
 
\begin_inset Formula $\theta$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This contrasts with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_dir'}
\end_layout

\end_inset

, where we solve for the policy variable, and then determine the coefficients
 using equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Coefficient_Function"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

.
 The objective is to solve:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
0 & =R\left(x;\theta\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
which is a system of 
\begin_inset Formula $m$
\end_inset

 equations in 
\begin_inset Formula $m$
\end_inset

 unknowns as the number of coefficients is equal to the number of gridpoints.
 The Jacobian matrix of this system is 
\begin_inset Formula $m\times m$
\end_inset

 because each coefficient affects the solution at all gridpoints.
 For more details on Direct Computation see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Solutaion_at_grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection*
Smolyak with Time Iteration
\end_layout

\begin_layout Standard
The algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_tmi'}
\end_layout

\end_inset

 solves the residual function by choosing the period 
\begin_inset Formula $t$
\end_inset

 policy variable with Time Iteration as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Solutaion_at_grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Given the period 
\begin_inset Formula $t$
\end_inset

 policy variable at the gridpoints 
\begin_inset Formula $\hat{Y}\left(x\right)$
\end_inset

, and the matrix with polynomial terms 
\begin_inset Formula $\Omega$
\end_inset

 (as in equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:OMG_Matrix"
plural "false"
caps "false"
noprefix "false"

\end_inset

 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-polynomial_constr"
plural "false"
caps "false"
noprefix "false"

\end_inset

) we determine the coefficients 
\begin_inset Formula $\theta$
\end_inset

 by solving a linear system of equations:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\theta & =\Omega^{-1}\hat{Y}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
In practice we solve this linear system with Matlab's 
\family typewriter
mldivide
\family default
.
\end_layout

\begin_layout Part
Technical descriptions of functions 
\begin_inset CommandInset label
LatexCommand label
name "part:Function-descriptions"

\end_inset


\end_layout

\begin_layout Chapter
Model file
\begin_inset CommandInset label
LatexCommand label
name "chap:Model-file"

\end_inset


\end_layout

\begin_layout Standard
The model should be a function that takes the grid and the policy functions
 as inputs and gives the Euler residuals as output.
 One has to create a handle to this model function, which only takes the
 structure with the policy function 
\begin_inset Formula $POL$
\end_inset

 as input.
 To evaluate the policy function we use 
\family typewriter
get_pol_var
\family default
 (described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function_get_pol_var"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The function 
\family typewriter
get_pol_var
\family default
 takes the state variables 
\begin_inset Formula $xx$
\end_inset

 as input, which is an 
\begin_inset Formula $m\times n$
\end_inset

 matrix where each column vector represents a state variable, and each row
 a datapoint.
 The output is an 
\begin_inset Formula $m\times d$
\end_inset

 matrix, where each column represents a policy variable.
 One has to use an algorithm specific format to evaluate the policy function
 as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Formats-for-evaluation"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For examples of model functions see Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_mod}
\end_layout

\end_inset

 and Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The model function itself can include any amount of input fields, but needs
 to include at least:
\end_layout

\begin_layout Itemize
\begin_inset Formula $GRID$
\end_inset

: a structure with all necessary properties of the grid as assigned by the
 function 
\family typewriter
prepgrid
\family default
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`prepgrid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

);
\end_layout

\begin_layout Itemize
\begin_inset Formula $POL$
\end_inset

: a structure that needs to contain the algorithm 
\begin_inset Formula $algo$
\end_inset

, and the policy function (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-'solve_proj'"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 Note that the policy function will be assigned to 
\begin_inset Formula $POL$
\end_inset

 by the function 
\family typewriter
solve_proj
\family default
, based on the algorithm and the initial guess.
\end_layout

\begin_layout Standard
The output of the function needs to be:
\end_layout

\begin_layout Itemize
\begin_inset Formula $RES$
\end_inset

: residuals in a 
\begin_inset Formula $dm\times1$
\end_inset

 vector, where 
\begin_inset Formula $m$
\end_inset

 is the total number of gridpoints, and 
\begin_inset Formula $d$
\end_inset

 the number of policy functions.
 When multiple policy variables are used (
\begin_inset Formula $d>1$
\end_inset

) the residuals vectors should be stacked vertically as explained below.
\end_layout

\begin_layout Subsection*
Vertical concatenation of residuals
\end_layout

\begin_layout Standard
The residuals vectors need to be stacked vertically.
 An example of this ordering can be found in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Multiple-policy-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 To explain the ordering we assume there are two policy variables (
\begin_inset Formula $d=2$
\end_inset

), and the total number of gridpoints is 
\begin_inset Formula $m$
\end_inset

.
 As 
\begin_inset Formula $d=2$
\end_inset

 there are two residuals functions 
\begin_inset Formula $R_{1}$
\end_inset

 and 
\begin_inset Formula $R_{2}$
\end_inset

, which are both column vectors with length 
\begin_inset Formula $m$
\end_inset

.
 These vectors need to be stacked vertically such that the model function
 returns a 
\begin_inset Formula $2m\times1$
\end_inset

 residual vector 
\begin_inset Formula $R=\left[R_{1};R_{2}\right]$
\end_inset

.
 Grouping the residuals this way ensures that row 
\begin_inset Formula $j$
\end_inset

 and row 
\begin_inset Formula $j+m$
\end_inset

 in 
\begin_inset Formula $R$
\end_inset

 refer to the same gridpoint.
 This format is necessary, because the sparse Jacobian for Time Iteration
 is constructed based on this format.
\end_layout

\begin_layout Standard
In addition the order of the residual vectors should correspond to the order
 of the policy variables.
 In the example of Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Multiple-policy-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we had an Euler equation for capital and an Euler equation for consumption.
 The complete residual vector is constructed as 
\begin_inset Formula $R=\left[R_{1};R_{2}\right]$
\end_inset

.
 As capital is the first policy variable the Euler residuals for capital
 should be in 
\begin_inset Formula $R_{1}$
\end_inset

 and the other Euler residuals in 
\begin_inset Formula $R_{2}$
\end_inset

.
 
\end_layout

\begin_layout Section
Formats for policy function evaluation
\begin_inset CommandInset label
LatexCommand label
name "sec:Formats-for-evaluation"

\end_inset


\end_layout

\begin_layout Standard
To evaluate the policy function in the model file we need to differentiate
 between two formats.
 There is a standard format and a format specific to Time Iteration algorithms
 (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

).
 Examples of these formats are shown in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_mod}
\end_layout

\end_inset

 and Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

.
 In this section we assume there are 
\begin_inset Formula $i=1,\ldots,d$
\end_inset

 policy variables 
\begin_inset Formula $y^{i}$
\end_inset

.
 Each policy variable is a function of the two state variables 
\begin_inset Formula $X1$
\end_inset

 and 
\begin_inset Formula $X2$
\end_inset

.
 
\end_layout

\begin_layout Subsection*
Standard Format
\end_layout

\begin_layout Standard
With the standard format the same policy function is used for current period's
 choices and next period's choices.
 To evaluate policy variable 
\begin_inset Formula $i$
\end_inset

 (index 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

) in period 
\begin_inset Formula $t$
\end_inset

 use:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

y_t = get_pol_var(POL,[X1_t,X2_t],GRID,i_pol);
\end_layout

\end_inset

 We can use the same format to evaluate the policy function in period 
\begin_inset Formula $t+1$
\end_inset

.
\end_layout

\begin_layout Standard
For algorithms with polynomials not using Time Iteration
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
These are the algorithms 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_mse'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_dir'}
\end_layout

\end_inset

.
\end_layout

\end_inset

 we can save computation time by evaluating the policy function at the initial
 grid, which is stored in the structure 
\begin_inset Formula $GRID$
\end_inset

.
 We have to set the input argument 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt='ini_grid'}
\end_layout

\end_inset

 of 
\family typewriter
get_pol_var
\family default
 to achieve this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
\noindent

spec_opt = 'ini_grid';  
\end_layout

\begin_layout Plain Layout

y_t = get_pol_var(POL,[X1_t,X2_t],GRID,i_pol,spec_opt);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
For the polynomial algorithms this option will ignore the inputs arguments
 
\begin_inset Formula $\left[X1_{t},X2_{t}\right]$
\end_inset

, and the policy function will be evaluated using the initial grid 
\begin_inset Formula $GRID.xx$
\end_inset

.
 When the option 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt='ini_grid'}
\end_layout

\end_inset

 is used in combination with a spline 
\family typewriter
get_pol_var
\family default
 ignores the option, and inputs 
\begin_inset Formula $\left[X1_{t},X2_{t}\right]$
\end_inset

 are used to evaluate the policy function.
\end_layout

\begin_layout Subsection*
Time Iteration
\end_layout

\begin_layout Standard
With Time Iteration we solve for the period 
\begin_inset Formula $t$
\end_inset

 policy variable, given the policy function in period 
\begin_inset Formula $t+1$
\end_inset

 as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Solutaion_at_grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 With Time Iteration the solver 
\family typewriter
solve_proj
\family default
 assigns the period 
\begin_inset Formula $t$
\end_inset

 policy variable at the gridpoints to the field 
\begin_inset Formula $POL.YY$
\end_inset

, which is an 
\begin_inset Formula $m\times d$
\end_inset

 matrix where 
\begin_inset Formula $d$
\end_inset

 is the number of policy variables, and 
\begin_inset Formula $m$
\end_inset

 the number of gridpoints.
 To evaluate the period 
\begin_inset Formula $t$
\end_inset

 policy variable with index 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 we call: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

y_t = POL.YY(:,i_pol);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For next period's choices we use the policy function of the previous iteration
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\noindent
The old policy function is assigned to 
\begin_inset Formula $POL.pp\textrm{\_}y\textrm{\_}old$
\end_inset

 for splines, and to 
\begin_inset Formula $POL.theta\textrm{\_}old$
\end_inset

 for polynomials.
\end_layout

\end_inset

.
 To evaluate this policy function we set 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt='old_pol'}
\end_layout

\end_inset

 as input argument for 
\family typewriter
get_pol_var
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout
\noindent

spec_opt_next = 'old_pol';
\end_layout

\begin_layout Plain Layout

y_n = get_pol_var(POL,[X1_n,X2_n],GRID,i_pol,spec_opt_next);
\end_layout

\end_inset


\end_layout

\begin_layout Section
Function 
\family typewriter
get_pol_var
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:Function_get_pol_var"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
get_pol_var
\family default
 takes the policy function in 
\begin_inset Formula $POL$
\end_inset

, the state variables in matrix 
\begin_inset Formula $xx$
\end_inset

, and the grid structure 
\begin_inset Formula $GRID$
\end_inset

 as input and gives the policy variable as output.
 When multiple policy variables are used one needs to specify the index
 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 of the policy variable.
\end_layout

\begin_layout Standard
The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $POL$
\end_inset

: a structure which contains the field 
\begin_inset Formula $algo$
\end_inset

 (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Specific-Algorithms"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and a field containing the appropriate policy function.
 For splines this is the field 
\begin_inset Formula $pp\textrm{\_}y$
\end_inset

 and for polynomials this is the field 
\begin_inset Formula $theta$
\end_inset

.
 For solution method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 there are two special cases of the policy function.
 The period 
\begin_inset Formula $t$
\end_inset

 policy function evaluated at the initial grid is the field 
\begin_inset Formula $YY$
\end_inset

, and the policy function of the previous iteration is the field 
\begin_inset Formula $pp\textrm{\_}y\textrm{\_}old$
\end_inset

 for splines and 
\begin_inset Formula $theta\textrm{\_}old$
\end_inset

 for polynomials;
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: a matrix with the state variables in column vectors stacked behind each
 other (
\begin_inset Formula $m\times n$
\end_inset

  matrix, where 
\begin_inset Formula $m$
\end_inset

 is the number of points to be evaluated, and 
\begin_inset Formula $n$
\end_inset

 is the number of state variables) as shown in Listings 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_mod}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

 for a model file, and in Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_sim}
\end_layout

\end_inset

 for a simulation.
 When 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt='ini_grid'}
\end_layout

\end_inset

 the input 
\begin_inset Formula $xx$
\end_inset

 is ignored for polynomials
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
For polynomials in combination with Time Iteration the option 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt='ini_grid'}
\end_layout

\end_inset

 will throw an error.
 
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $GRID$
\end_inset

: structure with the necessary grid properties, which are assigned by 
\family typewriter
prepgrid
\family default
 (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

);
\end_layout

\begin_layout Itemize
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 (optional if 
\begin_inset Formula $d=1$
\end_inset

): the index of the policy variable to be evaluated.
 The total number of policy variables is 
\begin_inset Formula $d$
\end_inset

.
 The index 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

 is determined by the column index in the initial guess 
\begin_inset Formula $Y0$
\end_inset

 (see Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Multiple-policy-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for an example);
\end_layout

\begin_layout Itemize
\begin_inset Formula $spec\textrm{\_}opt$
\end_inset

 (optional): there are two options for this field, either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt='ini_grid'}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt='old_pol'}
\end_layout

\end_inset

.
 Other values are ignored.
 If 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt='ini_grid'}
\end_layout

\end_inset

 and the algorithm is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_mse'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_dir'}
\end_layout

\end_inset

, or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

 the initial grid (either 
\begin_inset Formula $XX\textrm{\_}poly$
\end_inset

 or 
\begin_inset Formula $XX\textrm{\_}poly\textrm{\_}dw$
\end_inset

) is used to evaluate the policy function
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This will save computation time as the polynomial of the initial grid does
 not have to be reconstructed.
\end_layout

\end_inset

.
 Note that the input argument 
\begin_inset Formula $xx$
\end_inset

 will be ignored in this case.
 The option 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt='ini_grid'}
\end_layout

\end_inset

 is ignored when used in combination with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_dir'}
\end_layout

\end_inset

, and will result in an error when used in combination with Time Iteration
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
With Time Iteration the policy function at the initial grid is assigned
 to 
\begin_inset Formula $POL.YY$
\end_inset

.
\end_layout

\end_inset

.
 If 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{spec_opt='old_pol'}
\end_layout

\end_inset

 the old policy function is used.
 For splines this is the field 
\begin_inset Formula $pp\textrm{\_}y\textrm{\_}old$
\end_inset

, and for polynomials 
\begin_inset Formula $theta\textrm{\_}old$
\end_inset

.
 These fields will be assigned to 
\begin_inset Formula $POL$
\end_inset

 when solving the model with Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Chapter
Solving the model
\begin_inset CommandInset label
LatexCommand label
name "chap:Solving-the-model"

\end_inset


\end_layout

\begin_layout Standard
The model is solved using the function 
\family typewriter
solve_proj
\family default
, which is explained in the following section.
 
\end_layout

\begin_layout Section
Function 
\family typewriter
solve_proj
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:Function-'solve_proj'"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
solve_proj
\family default
 solves for the policy function that minimizes the Euler residuals.
 To solve the model one calls the function 
\family typewriter
solve_proj
\family default
 with inputs:
\end_layout

\begin_layout Itemize
\begin_inset Formula $GRID$
\end_inset

: the structure with the grid properties assigned by 
\family typewriter
prepgrid
\family default
 as described in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Grid"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $POL$
\end_inset

: a structure with the required field 
\begin_inset Formula $algo$
\end_inset

, that defines the algorithm.
 There are several optional fields, which are listed in the Subsection Optional
 Fields below;
\end_layout

\begin_layout Itemize
\begin_inset Formula $fun\textrm{\_}res$
\end_inset

: the function handle to the model function as described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Model_file"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and the examples Listing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:BM_mod}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{pl:RBC_mod}
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $Y0$
\end_inset

: the initial guess of the policy functions evaluated at the initial grid
 
\begin_inset Formula $GRID.xx$
\end_inset

.
 
\begin_inset Formula $Y0$
\end_inset

 should be a 
\begin_inset Formula $m\times d$
\end_inset

  matrix with 
\begin_inset Formula $m$
\end_inset

 the total number of gridpoints, and 
\begin_inset Formula $d$
\end_inset

 the number of policy variables.
 The column index of a variable in 
\begin_inset Formula $Y0$
\end_inset

 determines the index 
\begin_inset Formula $i\textrm{\_}pol$
\end_inset

, which is used to evaluate the policy function with 
\family typewriter
get_pol_var
\family default
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function_get_pol_var"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and for an example Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Multiple-policy-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

 );
\end_layout

\begin_layout Itemize
\begin_inset Formula $options$
\end_inset

 (optional): a structure which can replace fields of the 
\begin_inset Formula $optimoptions$
\end_inset

 structure of the solvers (either 
\family typewriter
lsqnonlin
\family default
 or 
\family typewriter
fsolve)
\family default
.
 If 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'options.override_all = 1'}
\end_layout

\end_inset

 then 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $options.optimoptions$
\end_inset

 is used as the 
\begin_inset Formula $options$
\end_inset

 input argument of the solver.
 If 
\begin_inset Formula $options.Algorithm$
\end_inset

 is set than the 
\begin_inset Formula $optimoptions$
\end_inset

 structure will be created using the specified algorithm.
 Otherwise only the fields specified in 
\begin_inset Formula $options$
\end_inset

 will be used to replace their standard values.
 See below for some details
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Or see the subfunction 
\family typewriter
set_default_opt_solver
\family default
 inside 
\family typewriter
solve_proj
\family default
.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $POL$
\end_inset

: a structure to which the policy function is added.
 For polynomial algorithms the policy functions are assigned to the field
 
\begin_inset Formula $theta$
\end_inset

.
 This is a 
\begin_inset Formula $p\times d$
\end_inset

 matrix with the polynomial coefficients, where 
\begin_inset Formula $d$
\end_inset

 is the number of policy variables, and 
\begin_inset Formula $p$
\end_inset

 the number of polynomial terms.
 For spline algorithms the policy function is 
\begin_inset Formula $pp\textrm{\_}y$
\end_inset

, which is 
\begin_inset Formula $1\times d$
\end_inset

 cell array.
 Each cell contains a spline for a policy variable.
 The splines are created using Matlab's 
\family typewriter
griddedInterpolant
\family default
.
 The interpolation method is specified in 
\begin_inset Formula $POL.spl\textrm{\_}meth$
\end_inset

 for which 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset

 is the default option.
\end_layout

\begin_layout Standard
The solver uses the following functions from Matlab's 
\family typewriter
Optimization Toolbox
\family default
:
\end_layout

\begin_layout Itemize

\family typewriter
lsqnonlin
\family default
 for algorithms 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_mse'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize

\family typewriter
fsolve
\family default
 for all other algorithms.
 Note that for Time Iteration this solver is only used to solve for the
 period 
\begin_inset Formula $t$
\end_inset

 policy variable.
\end_layout

\begin_layout Standard
We use default options for 
\family typewriter
fsolve
\family default
 and 
\family typewriter
lsqnonlin
\family default
 with two exceptions.
 The first exception is for Time Iteration.
 For this solution method the algorithm of 
\family typewriter
fsolve
\family default
 is set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'trust-region'}
\end_layout

\end_inset

, which allows for a sparse Jacobian matrix.
 The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'JacobPattern'}
\end_layout

\end_inset

 is set to sparse identity matrix
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In case of multiple policy variables the pattern consists of repeated blocks
 of identity matrices.
\end_layout

\end_inset

.
 The second exception is the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'Display'}
\end_layout

\end_inset

 option, which is set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'off'}
\end_layout

\end_inset

 by default.
 
\end_layout

\begin_layout Subsection*
Algorithms
\begin_inset CommandInset label
LatexCommand label
name "subsec:Algorithms"

\end_inset


\end_layout

\begin_layout Standard
We repeat the overview of the algorithms in Table 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{table:algo_overview-2}
\end_layout

\end_inset

.
 For recommendations we refer to Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Algorithms"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The details of each algorithm are discussed in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Specific-Algorithms"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{table}[h] 
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{threeparttable}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Overview of algorithms}                     
\end_layout

\begin_layout Plain Layout


\backslash
label{table:algo_overview-2}  
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{llll} 
\end_layout

\begin_layout Plain Layout

Algorithm & Basis function & Proj.
 Cond.
 & Solution Meth.
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'spl_dir'$ & Spline & Collocation & Direct Comp.
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'spl_tmi' $ & Spline & Collocation & Time Iteration
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'cheb_gal'$ & Compl.
 Chebyshev polyn.
 & Galerkin & Newton type 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'cheb_tmi'$ & Compl.
 Chebyshev polyn.
 & Min.
 Sq.
 Err.
 & Time Iteration
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'cheb_mse'$ & Compl.
 Chebyshev polyn.
 &  Min.
 Sq.
 Err.
 & Trust-Region
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'mono_mse'$ & Monomials (compl.
 polyn.) & Min.
 Sq.
 Err.
 & Trust-Region
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'smol_dir'$ & Smolyak-Chebyshev polyn.
 & Collocation & Direct Comp.
 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
lstinline$'smol_tmi'$ & Smolyak-Chebyshev polyn.
 & Collocation & Time Iteration 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tabular} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{threeparttable}  
\end_layout

\begin_layout Plain Layout


\backslash
end{table}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Optional fields
\end_layout

\begin_layout Standard
There are several optional fields in 
\begin_inset Formula $POL$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
Spline algorithms
\end_layout

\begin_layout Itemize
\begin_inset Formula $spl\textrm{\_}meth$
\end_inset

: for the algorithms 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_tmi'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_dir'}
\end_layout

\end_inset

 the interpolation method of the spline can be set in the optional field
 
\begin_inset Formula $POL.spl\textrm{\_}meth$
\end_inset

.
 The Matlab documentation for the function 
\family typewriter
griddedInterpolant
\family default
 describes the choices under `Method'.
 The default of the toolbox is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Time Iteration
\end_layout

\begin_layout Standard
For the solution method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 several options can be set in fields of the structure 
\begin_inset Formula $POL$
\end_inset

: 
\end_layout

\begin_layout Itemize
\begin_inset Formula $diff\textrm{\_}tol$
\end_inset

: the tolerance for the maximum absolute change in the the policy function
 between two iterations: 
\begin_inset Formula $\max\left|\hat{y}^{j}-\hat{y}^{j-1}\right|$
\end_inset

where 
\begin_inset Formula $\hat{y}^{j}$
\end_inset

 is the policy variable of iteration 
\begin_inset Formula $j$
\end_inset

.
 The default is 1e-8;
\end_layout

\begin_layout Itemize
\begin_inset Formula $res\textrm{\_}tol$
\end_inset

: the tolerance 
\begin_inset Formula $\epsilon_{\max}^{r}$
\end_inset

, which is the acceptance level for the maximum absolute value of the (Euler)
 residuals: 
\begin_inset Formula $\max\left|R\left(\hat{y}_{t}^{j};\theta^{j}\right)\right|$
\end_inset

.
 The default is 1e-8;
\end_layout

\begin_layout Itemize
\begin_inset Formula $max\textrm{\_}iter$
\end_inset

: the maximum number of iterations in the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'while'}
\end_layout

\end_inset

 loop.
 The default is 500;
\end_layout

\begin_layout Itemize
\begin_inset Formula $step\textrm{\_}acc$
\end_inset

: all tolerances are scaled with 
\begin_inset Formula $step\textrm{\_}acc$
\end_inset

 when the solver stalls
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
When 
\begin_inset Formula $output.iterations==0$
\end_inset

 indicating that the solver got stuck at the initial point.
\end_layout

\end_inset

.
 The default value is 0.1;
\end_layout

\begin_layout Itemize
\begin_inset Formula $mem\textrm{\_}Y$
\end_inset

: dampening (memory) parameter when updating the policy function 
\begin_inset Formula $Y$
\end_inset

, ie.
 
\begin_inset Formula $Y=\left(1-mem_{Y}\right)Y_{new}+mem_{Y}Y_{old}$
\end_inset

, where 
\begin_inset Formula $Y_{new}$
\end_inset

 is the solution at the gridpoints found in the current iteration.
 The default is 0.
 Only values between 0 and 1 are allowed.
\end_layout

\begin_layout Chapter
Construction of grid
\begin_inset CommandInset label
LatexCommand label
name "chap:Grid"

\end_inset


\end_layout

\begin_layout Standard
The grid parameters, and also the grid itself are stored in the structure
 
\begin_inset Formula $GRID$
\end_inset

.
 It is created with the function 
\family typewriter
prepgrid
\family default
, which takes the grid parameters, and the algorithm as inputs.
 The output is the structure 
\begin_inset Formula $GRID$
\end_inset

 which includes all the required fields.
\end_layout

\begin_layout Standard
The 
\family typewriter
prepgrid
\family default
 function is demonstrated in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Grid_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with the example script 
\family typewriter
grid_example
\family default
 in the folder `PROMES_v05.0.0/Examples', which shows all the output variables
 (and intermediate variables).
 All functions of this chapter except 
\family typewriter
prepgrid
\family default
 are found in the subfolders `PROMES_v05.0.0/grid_subfun' and `PROMES_v05.0.0/smolya
k_subfun'.
 The latter folder contains the code to construct the Smolyak grid.
 This code is provided by Rafa Valero
\begin_inset Foot
status open

\begin_layout Plain Layout
Rafa Valero (2021) Smolyak Anisotropic Grid, MATLAB Central File Exchange,
 Retrieved November 5, 2021 (
\begin_inset CommandInset href
LatexCommand href
target "https://www.mathworks.com/matlabcentral/fileexchange/50963-smolyak-anisotropic-grid"

\end_inset

).
\begin_inset CommandInset label
LatexCommand label
name "fn:Rafa-Valero2"

\end_inset


\end_layout

\end_inset

, and the underlying algorithm is described in 
\begin_inset CommandInset citation
LatexCommand citet
key "judd2014smolyak"
literal "false"

\end_inset

.
 The relevant subfolders need to be on the searchpath to construct the grid.
\end_layout

\begin_layout Section
Function 
\family typewriter
prepgrid
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:Function-`prepgrid'"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
prepgrid
\family default
 constructs structure 
\begin_inset Formula $GRID$
\end_inset

 with all the necessary fields.
 It mainly prepares the call to 
\begin_inset Formula $gridstruct$
\end_inset

 or 
\begin_inset Formula $gridstruct\textrm{\_}smolyak$
\end_inset

.
 The function 
\family typewriter
prepgrid
\family default
 has five input arguments:
\end_layout

\begin_layout Itemize
\begin_inset Formula $nn$
\end_inset

: the number of state variables;
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

: vector of lower bounds in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

: vector of upper bounds in each dimension (1 x 
\begin_inset Formula $nn$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $algo$
\end_inset

: the  algorithm, which should be assigned to 
\begin_inset Formula $POL.algo$
\end_inset

.
 See Subsection 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Algorithms"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for a list of options;
\end_layout

\begin_layout Itemize
\begin_inset Formula $algo\textrm{\_}spec$
\end_inset

 (optional): structure with algorithm specific fields.
 If this input is not specified the default values are used.
 For the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset

 algorithms this is the field 
\begin_inset Formula $qq$
\end_inset

, which is set to 
\begin_inset Formula $qq=5*ones(1,nn)$
\end_inset

 by default.
 For the algorithms with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 the specific fields are 
\begin_inset Formula $qq$
\end_inset

 and 
\begin_inset Formula $ord\textrm{\_}vec$
\end_inset

.
 For 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 the default values are 
\begin_inset Formula $qq=6*ones(1,nn)$
\end_inset

, and 
\begin_inset Formula $ord\textrm{\_}vec=5*ones(1,nn)$
\end_inset

.
 For 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 the default values are 
\begin_inset Formula $qq=4*ones(1,nn)$
\end_inset

, and 
\begin_inset Formula $ord\textrm{\_}vec=3*ones(1,nn)$
\end_inset

.
 For the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol'}
\end_layout

\end_inset

 algorithms only the field 
\begin_inset Formula $mu$
\end_inset

 has to be assigned, which is set to 
\begin_inset Formula $mu=2*ones(1,nn)$
\end_inset

 by default.
\end_layout

\begin_layout Standard
The function 
\family typewriter
prepgrid
\family default
 assigns the 
\begin_inset Formula $grid\textrm{\_}type$
\end_inset

, which is either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smolyak'}
\end_layout

\end_inset

.
 For the types 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 we call the function 
\family typewriter
gridstruct
\family default
.
 For the type 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smolyak'}
\end_layout

\end_inset

 we call the function 
\family typewriter
gridstruct_smolyak
\family default
.
 These two functions construct the structure 
\begin_inset Formula $GRID$
\end_inset

 and are explained in next two sections.
\end_layout

\begin_layout Section
Function 
\family typewriter
gridstruct
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:gridstruct"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
gridstruct
\family default
 is used to create a structure that contains all the necessary properties
 of the grid when the 
\begin_inset Formula $grid\_type$
\end_inset

 is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

, or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

.
 The necessary properties include the gridvectors, the full grid, and if
 required the complete polynomial of the grid.
\end_layout

\begin_layout Standard
The input arguments are: 
\end_layout

\begin_layout Itemize
\begin_inset Formula $nn$
\end_inset

: the number of state variables
\end_layout

\begin_layout Itemize
\begin_inset Formula $qq$
\end_inset

: vector of number of gridpoints in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

: vector of lower bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

: vector of upper bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $grid\_type$
\end_inset

: either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 for a complete Chebyshev polynomial with Chebyshev nodes, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 for a complete polynomial based on monomials with equidistant nodes, or
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset

 for an equidistant grid;
\end_layout

\begin_layout Itemize
\begin_inset Formula $ord\textrm{\_}vec$
\end_inset

: the maximum order of the polynomial in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector).
 This input is only required for 
\begin_inset Formula $grid\_type$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
gridstruct
\family default
 adds the input arguments 
\begin_inset Formula $nn$
\end_inset

, 
\begin_inset Formula $qq$
\end_inset

, 
\begin_inset Formula $lb$
\end_inset

, 
\begin_inset Formula $ub$
\end_inset

, and 
\begin_inset Formula $grid\textrm{\_}type$
\end_inset

 as fields to 
\begin_inset Formula $GRID$
\end_inset

.
 Several additional fields are added, which are best explained with the
 example in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Grid_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The additional fields are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $mm$
\end_inset

 which is the total number of gridpoints;
\end_layout

\begin_layout Itemize
\begin_inset Formula $gridVecs$
\end_inset

, and 
\begin_inset Formula $xx$
\end_inset

 which contain the initial gridvectors (see Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_vecs'"
plural "false"
caps "false"
noprefix "false"

\end_inset

), and the initial grid (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

), respectively;
\end_layout

\begin_layout Itemize
\begin_inset Formula $poly\textrm{\_}elem$
\end_inset

 which is a 
\begin_inset Formula $p\times n$
\end_inset

 matrix which is used to construct a multivariate polynomial as in Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-polynomial_constr"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The element 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $l_{i,j}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 refers to the univariate polynomial 
\begin_inset Formula $T_{l_{i,j}}\left(x_{j}\right)$
\end_inset

.
 The multiplication of the polynomial terms in a row construct a multivariate
 polynomial (either 
\begin_inset Formula $XX\textrm{\_}poly$
\end_inset

 or 
\begin_inset Formula $XX\textrm{\_}poly\textrm{\_}dw$
\end_inset

, see the example in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Grid_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

);
\end_layout

\begin_layout Itemize
\begin_inset Formula $XX\textrm{\_}poly$
\end_inset

 if the 
\begin_inset Formula $grid\_type$
\end_inset

 is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

, which is the complete polynomial of the full grid 
\begin_inset Formula $xx$
\end_inset

 (see Section
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-polybase_ani"
plural "false"
caps "false"
noprefix "false"

\end_inset

);
\end_layout

\begin_layout Itemize
\begin_inset Formula $gridVecs\_dw$
\end_inset

, 
\begin_inset Formula $xx\_dw$
\end_inset

, and 
\begin_inset Formula $XX\textrm{\_}poly\_dw$
\end_inset

 if the 
\begin_inset Formula $grid\_type$
\end_inset

 is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

.
 These are the scaled down versions of 
\begin_inset Formula $gridVecs$
\end_inset

, 
\begin_inset Formula $xx$
\end_inset

, and 
\begin_inset Formula $XX\textrm{\_}poly$
\end_inset

, respectively.
 The scaling down maps the variables linearly from 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

 to 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 The nodes are the Chebyshev nodes.
 For more details see Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_vecs'"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-polybase_ani"
plural "false"
caps "false"
noprefix "false"

\end_inset

, respectively.
\end_layout

\begin_layout Section
Function 
\family typewriter
gridstruct_smolyak
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:gridstruct_Smolyak"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
gridstruct_smolyak
\family default
 is used to create a structure that contains all the necessary properties
 of the grid when the 
\begin_inset Formula $grid\_type$
\end_inset

 is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smolyak'}
\end_layout

\end_inset

.
 The necessary properties include the gridvectors, the full grid, the Smolyak
 polynomial, and the matrix inverse of the polynomial.
 This function makes calls to the code provided by Rafa Valero
\begin_inset Foot
status open

\begin_layout Plain Layout
See Footnote 
\begin_inset CommandInset ref
LatexCommand ref
reference "fn:Rafa-Valero2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

.
 The algorithm underlying this code is originally described in 
\begin_inset CommandInset citation
LatexCommand citet
key "judd2014smolyak"
literal "false"

\end_inset

, and also found in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Smolyak"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 This manual does not further explain the code by Rafa Valero, which can
 be found in the subfolder `smolyak_subfun'.
\end_layout

\begin_layout Standard
The input arguments are: 
\end_layout

\begin_layout Itemize
\begin_inset Formula $nn$
\end_inset

: the number of state variables
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

: vector of lower bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

: vector of upper bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $mu\_vec$
\end_inset

: vector of the accuracy 
\begin_inset Formula $mu$
\end_inset

 in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector).
\end_layout

\begin_layout Standard
The function 
\family typewriter
gridstruct_smolyak
\family default
 adds the input arguments 
\begin_inset Formula $nn$
\end_inset

, 
\begin_inset Formula $lb$
\end_inset

, 
\begin_inset Formula $ub$
\end_inset

, and 
\begin_inset Formula $grid\textrm{\_}type$
\end_inset

 as fields to 
\begin_inset Formula $GRID$
\end_inset

.
 Several additional fields are added, which are best explained with the
 example in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Grid_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The additional fields are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $mm$
\end_inset

 which is the total number of gridpoints;
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

 which is the initial grid (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Smolyak"
plural "false"
caps "false"
noprefix "false"

\end_inset

);
\end_layout

\begin_layout Itemize
\begin_inset Formula $smol\textrm{\_}elem\_ani$
\end_inset

 which is a 
\begin_inset Formula $p\times n$
\end_inset

 matrix used to construct a multivariate polynomial as in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-polynomial_constr"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The element 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $l_{i,j}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 refers to the univariate polynomial 
\begin_inset Formula $T_{l_{i,j}-1}\left(x_{j}\right)$
\end_inset

.
 The multiplication of the polynomial terms in a single row give a multivariate
 polynomial 
\begin_inset Formula $XX\textrm{\_}pol\textrm{\_}dw$
\end_inset

, see the example in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Grid_example"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx\_dw$
\end_inset

, and 
\begin_inset Formula $XX\textrm{\_}pol\_dw$
\end_inset

, which are the scaled down initial grid, and the Smolyak polynomial of
 this grid.
 The scaling down maps the variables linearly from 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

 to 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 The nodes are the Chebyshev extrema.
 For more details see Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Smolyak"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Example
\family typewriter
 grid_example
\begin_inset CommandInset label
LatexCommand label
name "sec:Grid_example"

\end_inset


\end_layout

\begin_layout Standard
We demonstrate the fields of the structure 
\begin_inset Formula $GRID$
\end_inset

 with the file 
\family typewriter
grid_example
\family default
, which prints some of the properties of the grid on screen.
 The function 
\family typewriter
grid_example
\family default
 can be found in the folder `PROMES_v05.0.0/Examples'.
 That example prints the various grid variables on screen, and plots the
 initial grid.
 The code (excluding the printing commands) is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

% Add relevant folders of Promes toolbox: 
\end_layout

\begin_layout Plain Layout

addpath ('..'); 
\end_layout

\begin_layout Plain Layout

addpath ('..
\backslash
grid_subfun'); 
\end_layout

\begin_layout Plain Layout

addpath ('..
\backslash
smolyak_subfun');
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%% Initializtion of grid parameters: 
\end_layout

\begin_layout Plain Layout

gin.nn = 2;%number of state variables 
\end_layout

\begin_layout Plain Layout

gin.lb = [1,10];%lower bounds for [x1,x2] 
\end_layout

\begin_layout Plain Layout

gin.ub = [3,25];%upper bounds for [x1,x2]     
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Set solution method 
\end_layout

\begin_layout Plain Layout

% 'cheb_gal','cheb_tmi','cheb_mse', 
\end_layout

\begin_layout Plain Layout

% 'spl_tmi','spl_tmi', 
\end_layout

\begin_layout Plain Layout

% 'smol_tmi','smol_tmi', 
\end_layout

\begin_layout Plain Layout

% 'mono_mse'; 
\end_layout

\begin_layout Plain Layout

algo = 'cheb_gal'; 
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

if strncmp(algo,'cheb',4) || strncmp(algo,'mono',4)
\end_layout

\begin_layout Plain Layout

  meth_spec.ord_vec = 2*ones(1,gin.nn);%order in each dim.
\end_layout

\begin_layout Plain Layout

  meth_spec.qq = [3,4];%number of nodes in each dim.
       
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

elseif strncmp(algo,'spl',3)      
\end_layout

\begin_layout Plain Layout

  meth_spec.qq       = [3,4];%number of nodes in each dim.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

elseif strncmp(algo,'smol',4)      
\end_layout

\begin_layout Plain Layout

  meth_spec.mu_vec = [2,2];%accuracy in each dim.
 
\end_layout

\begin_layout Plain Layout

end    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% Construct structure with grid: 
\end_layout

\begin_layout Plain Layout

[GRID] = prepgrid(gin.nn,gin.lb,gin.ub,algo,meth_spec);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
All algorithms except Smolyak
\end_layout

\begin_layout Standard
The grid example is discussed for all algorithms except the Smolyak algorithm.
 The other algorithms use an initial grid based on a Cartesian product.
 The grid for these algorithms is constructed with the function 
\family typewriter
gridstruct
\family default
.
 The Smolyak grid is constructed differently.
 
\end_layout

\begin_layout Subsubsection*
Gridvectors
\end_layout

\begin_layout Standard
The function 
\family typewriter
gridstruct
\family default
 first constructs the gridvectors 
\begin_inset Formula $gridVecs$
\end_inset

, plus the scaled down versions in 
\begin_inset Formula $gridVecs\textrm{\_}dw$
\end_inset

 in case the 
\begin_inset Formula $grid\textrm{\_}type$
\end_inset

 is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

.
 These gridvectors consist of either equidistant or Chebyshev nodes with
 the specified amount of gridpoints, and on the interval determined by the
 lower and upper bound.
 The gridvectors are constructed using the function 
\family typewriter
constr_vecs
\family default
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_vecs'"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The gridvectors will be added as fields to the structure 
\begin_inset Formula $GRID$
\end_inset

.
 
\end_layout

\begin_layout Standard
In the example we have specified that the state variables have 3 and 4 gridpoint
s, with bounds 
\begin_inset Formula $\left[1,3\right]$
\end_inset

 for 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $\left[10,25\right]$
\end_inset

 for 
\begin_inset Formula $x_{2}$
\end_inset

.
 If the 
\begin_inset Formula $grid\textrm{\_}type$
\end_inset

 is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset

 the function 
\family typewriter
gridstruct
\family default
 will use equidistant nodes for the gridvectors.
 With equidistant nodes the resulting fields are 
\begin_inset Formula $gridVecs\{1,1\}=\left[\begin{array}{ccc}
1 & 2 & 3\end{array}\right]$
\end_inset

 for 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $gridVecs\{1,2\}=\left[\begin{array}{cccc}
10 & 15 & 20 & 25\end{array}\right]$
\end_inset

 for 
\begin_inset Formula $x_{2}$
\end_inset

, which are linearly spaced vectors from lower to upper bound with the specified
 amount of gridpoints.
 
\end_layout

\begin_layout Standard
For the algorithms using Chebyshev polynomials 
\family typewriter
prepgrid
\family default
 sets the 
\begin_inset Formula $grid\textrm{\_}type$
\end_inset

 to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

, which means Chebyshev nodes are used.
 These nodes in the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

 are added as 
\begin_inset Formula $gridVecs\textrm{\_}dw$
\end_inset

.
 Scaled down variables are computed using the linear mapping from the lower
 and upper bounds 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

 to 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 The linear map is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\tilde{x} & =\frac{2x}{ub-lb}-\frac{lb+ub}{ub-lb}\label{eq:Cheb_scal_dw-1}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\tilde{x}$
\end_inset

 denotes the scaled down variable 
\begin_inset Formula $x$
\end_inset

 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_dw"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 
\end_layout

\begin_layout Standard
The scaled down nodes correspond to the roots of the Chebyshev polynomials.
 If there are 
\begin_inset Formula $q$
\end_inset

 nodes, then these nodes are the roots of the order 
\begin_inset Formula $q$
\end_inset

 polynomial.
 For example, for 
\begin_inset Formula $q=2$
\end_inset

 the nodes are the roots of the second order polynomial 
\begin_inset Formula $2\tilde{x}_{1}^{2}-1$
\end_inset

.
 These roots are 
\begin_inset Formula $\pm\frac{1}{2}\sqrt{2}$
\end_inset

.
 The minimum number of nodes in each dimension is therefore the order of
 the polynomial plus 1
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Otherwise the complete polynomial will contain a column vector with zeros.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
In our case we have 
\begin_inset Formula $q=3$
\end_inset

 and 
\begin_inset Formula $q=4$
\end_inset

, which results in:
\begin_inset Formula 
\begin{align*}
gridVecs\textrm{\_}dw\{1,1\} & =\left[\begin{array}{ccc}
-0.866 & 0 & 0.866\end{array}\right]\\
gridVecs\textrm{\_}dw\{1,2\} & =\left[\begin{array}{cccc}
-0.924 & -0.383 & 0.383 & 0.924\end{array}\right]
\end{align*}

\end_inset

for 
\begin_inset Formula $\tilde{x}_{1}$
\end_inset

 and for 
\begin_inset Formula $\tilde{x}_{2}$
\end_inset

, respectively.
 To scale up these vectors into the interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

 we use the inverse of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Cheb_scal_dw-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_up"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 These scaled up vectors are stored in the field 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $gridVecs$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Grid
\end_layout

\begin_layout Standard
After the gridvectors are constructed the function 
\family typewriter
gridstruct
\family default
 will construct the initial grid 
\begin_inset Formula $xx$
\end_inset

 using the function 
\family typewriter
constr_grid
\family default
 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

), which takes the gridvectors as input.
 The function 
\family typewriter
constr_grid
\family default
 constructs the initial grid using Matlab's 
\family typewriter
ndgrid
\family default
, which computes the Cartesian product of the gridvectors.
 For each state variable the output of 
\family typewriter
ndgrid
\family default
 is transformed into a 
\begin_inset Formula $m\times1$
\end_inset

 column vector with 
\begin_inset Formula $m$
\end_inset

 being the total number of nodes.
 These column vectors are stacked next to each other to form the 
\begin_inset Formula $m\times n$
\end_inset

  matrix 
\begin_inset Formula $xx$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the number of state variables.
 In our code:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[x1,x2] = ndgrid(gridvecs{1,1},gridvecs{1,2});          
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

xx	= NaN(mm,nn);
\end_layout

\begin_layout Plain Layout

xx(:,1) = reshape(x1,[],1);     
\end_layout

\begin_layout Plain Layout

xx(:,2) = reshape(x2,[],1);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With the gridvectors 
\begin_inset Formula $gridVecs\{1,1\}=\left[\begin{array}{ccc}
1 & 2 & 3\end{array}\right]$
\end_inset

 and 
\begin_inset Formula $gridVecs\{1,2\}=\left[\begin{array}{cccc}
10 & 15 & 20 & 25\end{array}\right]$
\end_inset

 the result is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
xx & =\left[\begin{array}{cccccccccccc}
1 & 2 & 3 & 1 & 2 & 3 & 1 & 2 & 3 & 1 & 2 & 3\\
10 & 10 & 10 & 15 & 15 & 15 & 20 & 20 & 20 & 25 & 25 & 25
\end{array}\right]^{\intercal}\label{eq:initial_grid}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where each column (note the transpose) in 
\begin_inset Formula $x$
\end_inset

 represents a state variable, and each row a unique gridpoint.
 For the Chebyshev polynomials we construct a full grid for both the scaled
 up (
\begin_inset Formula $xx$
\end_inset

) and scaled down (
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

) variables.
\end_layout

\begin_layout Subsubsection*
Complete polynomials
\end_layout

\begin_layout Standard
For the grid types using polynomials (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='cheb'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='mono'}
\end_layout

\end_inset

) the function 
\family typewriter
gridstruct
\family default
 will construct complete polynomials as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-polynomial_constr"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 It first constructs the field 
\begin_inset Formula $poly\textrm{\_}elem$
\end_inset

 with the function 
\family typewriter
poly_elem_ani
\family default
, and then calls the function 
\family typewriter
get_poly_ani
\family default
.
 The complete polynomial with monomial basis functions of order two in both
 dimensions is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
XX\textrm{\_}poly & =\left[\begin{array}{cccccc}
1 & x_{1} & x_{2} & x_{1}^{2} & x_{1}x_{2} & x_{2}^{2}\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $x_{1}=xx\left(:,1\right)$
\end_inset

 and 
\begin_inset Formula $x_{2}=xx\left(:,2\right)$
\end_inset

 are the state variables in 
\begin_inset Formula $m\times1$
\end_inset

 column vectors.
 The resulting complete polynomial 
\begin_inset Formula $XX\textrm{\_}poly$
\end_inset

 is printed on screen when the algorithm is set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono_mse'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
For Chebyshev polynomials only the scaled down grid 
\begin_inset Formula $\tilde{x}$
\end_inset

 (
\begin_inset Formula $GRID.xx\textrm{\_}dw$
\end_inset

) is used.
 A second order complete Chebyshev polynomial with two variables consists
 of the terms:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
XX\textrm{\_}poly\textrm{\_}dw & =\left[\begin{array}{cccccc}
1 & \tilde{x}_{1} & \tilde{x}_{2} & 2\tilde{x}_{1}^{2}-1 & \tilde{x}_{1}\tilde{x}_{2} & 2\tilde{x}_{2}^{2}-1\end{array}\right]\label{eq:Cheb_X_dw_2nd}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The scaled down complete polynomial with Chebyshev nodes will be printed
 on screen when algorithm is set to either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_gal'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_tmi'}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mse'}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
constr_vecs
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:Function-`constr_vecs'"

\end_inset


\end_layout

\begin_layout Standard
This function constructs a cell array 
\begin_inset Formula $gridVecs$
\end_inset

, where each cell contains a vector of gridpoints (for state variable 
\begin_inset Formula $i$
\end_inset

 this is a 
\begin_inset Formula $1\times q\left(i\right)$
\end_inset

 vector).
 This function allows for either equidistant nodes (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{nod_type='equi'}
\end_layout

\end_inset

) or Chebyshev nodes (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{nod_type='cheb'}
\end_layout

\end_inset

).
 In addition, one can choose for scaled up or scaled down variables, where
 scaled up variables are in the interval 
\begin_inset Formula $\left[lb\left(i\right),ub\left(i\right)\right]$
\end_inset

 and scaled down variables in the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 
\end_layout

\begin_layout Standard
This function is called by 
\family typewriter
gridstruct
\family default
.
 When 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='equi'}
\end_layout

\end_inset

 scaled up vectors with equidistant nodes are constructed, and when 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='cheb'}
\end_layout

\end_inset

 both scaled down and scaled up vectors are constructed.
\end_layout

\begin_layout Standard
The inputs of the function are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $qq$
\end_inset

: vector of number of gridpoints in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $nod\_type$
\end_inset

: a string set to either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'equi'}
\end_layout

\end_inset

 for equidistant nodes, or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 for Chebyshev nodes;
\end_layout

\begin_layout Itemize
\begin_inset Formula $scale\_type$
\end_inset

 (optional): a string which is either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'up'}
\end_layout

\end_inset

 (default for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{nod_type='equi'}
\end_layout

\end_inset

) or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dw'}
\end_layout

\end_inset

 (default for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{nod_type='cheb'}
\end_layout

\end_inset

), referring to scaled up variables (taking values between 
\begin_inset Formula $lb$
\end_inset

 and 
\begin_inset Formula $ub$
\end_inset

) or scaled down variables (taking values between 
\begin_inset Formula $-1$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

), respectively;
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

 (required for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{scale_type='up'}
\end_layout

\end_inset

): vector of lower bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

 (required for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{scale_type='up'}
\end_layout

\end_inset

): vector of upper bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector).
\end_layout

\begin_layout Standard
The output of the function is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $gridVecs$
\end_inset

: 
\begin_inset Formula $1\times n$
\end_inset

 cell array containing the grid vector (either scaled up or scale down,
 depending on the 
\begin_inset Formula $scale\_type$
\end_inset

) in each dimension (the 
\begin_inset Formula $i$
\end_inset

-th cell contains a row vector of length 
\begin_inset Formula $q$
\end_inset


\begin_inset Formula $\left(i\right)$
\end_inset

).
 
\end_layout

\begin_layout Standard
Note that when 
\family typewriter
gridstruct
\family default
 calls this function with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{scale_type='dw'}
\end_layout

\end_inset

 then the output will assigned to 
\begin_inset Formula $GRID.gridVecs\_dw$
\end_inset

.
\end_layout

\begin_layout Standard
The function 
\family typewriter
constr_vecs
\family default
 uses the functions:
\end_layout

\begin_layout Itemize

\family typewriter
chebnodes
\family default
 (for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='cheb'}
\end_layout

\end_inset

), which returns the Chebyshev nodes (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-chebnodes"
plural "false"
caps "false"
noprefix "false"

\end_inset

);
\end_layout

\begin_layout Itemize

\family typewriter
sc_cheb_dw 
\family default
(for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{scale_type='dw'}
\end_layout

\end_inset

): see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_dw"
plural "false"
caps "false"
noprefix "false"

\end_inset

;
\end_layout

\begin_layout Itemize

\family typewriter
sc_cheb_up
\family default
 (for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{grid_type='cheb'}
\end_layout

\end_inset

 in combination with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{scale_type='up'}
\end_layout

\end_inset

): see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_up"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
constr_grid
\family default

\begin_inset CommandInset label
LatexCommand label
name "sec:Function-`constr_grid'"

\end_inset


\end_layout

\begin_layout Standard
This function constructs a grid, based on the Cartesian product of the 
\begin_inset Formula $n$
\end_inset

 gridvectors in the cell array 
\begin_inset Formula $gridVecs$
\end_inset

.
 The output is an 
\begin_inset Formula $m\times n$
\end_inset

  matrix 
\begin_inset Formula $xx$
\end_inset

, where each column vector is a state variable, and each row represents
 a unique gridpoint.
 The function constructs the grid with Matlab's 
\family typewriter
ndgrid
\family default
, where each grid vector is expanded into a 
\begin_inset Formula $n$
\end_inset

 dimensional array.
 These arrays are reshaped into column vectors, which are stacked next to
 each other.
\end_layout

\begin_layout Standard
The inputs of the function is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $gridVecs$
\end_inset

: a  
\begin_inset Formula $1\times n$
\end_inset

 cell array, as described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_vecs'"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 It should be noted that 
\begin_inset Formula $gridVecs$
\end_inset

 can contain either scaled up or scaled down variables.
\end_layout

\begin_layout Standard
The output of the function is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: an 
\begin_inset Formula $m\times n$
\end_inset

 matrix where each column represents a state variable, and each row represents
 a unique gridpoint.
 Note that 
\begin_inset Formula $xx$
\end_inset

 can be either scaled up or down 
\begin_inset Foot
status open

\begin_layout Plain Layout
The labeling as either 
\begin_inset Formula $xx$
\end_inset

 or 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

 is done in the function 
\family typewriter
gridstruct
\family default
.
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
poly_elem_ani
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-poly_elem_ani"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
poly_elem_ani
\family default
 constructs the matrix 
\begin_inset Formula $poly\textrm{\_}elem$
\end_inset

 as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-polynomial_constr"
plural "false"
caps "false"
noprefix "false"

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
The matrix 
\begin_inset Formula $poly\textrm{\_}elem$
\end_inset

 is called 
\begin_inset Formula $LL$
\end_inset

 in that section
\end_layout

\end_inset

.
 Each element 
\begin_inset Formula $l_{i,j}$
\end_inset

 in 
\begin_inset Formula $poly\textrm{\_}elem$
\end_inset

 refers to the univariate polynomial term 
\begin_inset Formula $T_{i}\left(x_{j}\right)$
\end_inset

 of order 
\begin_inset Formula $i$
\end_inset

 for state variable 
\begin_inset Formula $j$
\end_inset

.
 These univariate polynomial terms 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $T_{i}\left(x_{j}\right)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 are found in the matrix 
\begin_inset Formula $\Phi^{j}$
\end_inset

 (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-constr_univar_basis"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The matrix 
\begin_inset Formula $poly\textrm{\_}elem$
\end_inset

 and the array 
\begin_inset Formula $\Phi$
\end_inset

 are used to construct the complete in the function 
\family typewriter
get_poly_ani
\family default
.
\end_layout

\begin_layout Standard
The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $nn$
\end_inset

: the number of state variables;
\end_layout

\begin_layout Itemize
\begin_inset Formula $ord\textrm{\_}vec$
\end_inset

: the maximum order of the polynomial in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector).
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $poly\textrm{\_}elem$
\end_inset

: an 
\begin_inset Formula $p\times n$
\end_inset

 matrix which is used to construct a complete polynomial.
 Each element 
\begin_inset Formula $l_{i,j}$
\end_inset

 refers to the univariate polynomial term 
\begin_inset Formula $T_{i}\left(x_{j}\right)$
\end_inset

 of order 
\begin_inset Formula $i$
\end_inset

 for state variable 
\begin_inset Formula $j$
\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
constr_univar_basis
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-constr_univar_basis"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
constr_univar_basis
\family default
 constructs the univariate polynomial in matrix 
\begin_inset Formula $\Phi^{j}$
\end_inset

 up to order 
\begin_inset Formula $k$
\end_inset

, taking a vector 
\begin_inset Formula $x_{j}$
\end_inset

 as input, as explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-polynomial_constr"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: an 
\begin_inset Formula $m\times1$
\end_inset

 vector of datapoints;
\end_layout

\begin_layout Itemize
\begin_inset Formula $order$
\end_inset

: the order of the univariate polynomial;
\end_layout

\begin_layout Itemize
\begin_inset Formula $poly\textrm{\_}type$
\end_inset

: either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 for Chebyshev polynomials of the first kind, or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

 for monomials.
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $PHI$
\end_inset

: an 
\begin_inset Formula $m\times order$
\end_inset

 matrix, where each column 
\begin_inset Formula $i$
\end_inset

 is the polynomial term 
\begin_inset Formula $T_{i}\left(x\right)$
\end_inset

.
 Note that 
\begin_inset Formula $T_{0}\left(x\right)$
\end_inset

 is not included.
\end_layout

\begin_layout Section
Function 
\family typewriter
get_poly_ani
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-polybase_ani"

\end_inset


\end_layout

\begin_layout Standard
The function 
\family typewriter
get_poly_ani
\family default
 constructs a complete polynomial of the grid, using either Chebyshev polynomial
s (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{poly_type='cheb'}
\end_layout

\end_inset

) or monomials (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{poly_type='mono'}
\end_layout

\end_inset

).
 The procedure is explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:General-polynomial_constr"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where 
\begin_inset Formula $\Omega$
\end_inset

 is the output 
\begin_inset Formula $XX\textrm{\_}poly$
\end_inset

 of the function 
\family typewriter
get_poly_ani
\family default
.
\end_layout

\begin_layout Standard
The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: an 
\begin_inset Formula $m\times n$
\end_inset

 matrix of gridpoints (either scaled up or scaled down);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ord\textrm{\_}vec$
\end_inset

: the maximum order of the polynomial in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $poly\textrm{\_}type$
\end_inset

: a string either 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb'}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'mono'}
\end_layout

\end_inset

, which is an input for the function 
\family typewriter
constr_univar_basis
\family default
.
 For 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{type='cheb'}
\end_layout

\end_inset

 the Chebyshev polynomials of the first kind are used, for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{type='mono'}
\end_layout

\end_inset

 monomials are used;
\end_layout

\begin_layout Itemize
\begin_inset Formula $poly\textrm{\_}elem$
\end_inset

: a 
\begin_inset Formula $p\times n$
\end_inset

 matrix to construct an anisotropic polynomial (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-poly_elem_ani"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $XX\textrm{\_}poly$
\end_inset

: 
\begin_inset Formula $m\times p$
\end_inset

 matrix of the complete polynomial of 
\begin_inset Formula $poly\textrm{\_}type$
\end_inset

 for the grid 
\begin_inset Formula $xx$
\end_inset

.
\end_layout

\begin_layout Subsection*
Complete polynomials
\end_layout

\begin_layout Standard
An example of complete polynomials with two variables, 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

, is as follows.
 For monomials the third order polynomial is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
XX\textrm{\_}poly & =\left[\begin{array}{cccccccccc}
1 & x_{1} & x_{2} & x_{1}^{2} & x_{1}x_{2} & x_{2}^{2} & x_{1}^{3} & x_{1}^{2}x_{2} & x_{1}x_{2}^{2} & x_{2}^{3}\end{array}\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $x_{1}$
\end_inset

 and 
\begin_inset Formula $x_{2}$
\end_inset

 are column vectors (see function 
\family typewriter
constr_grid
\family default
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The complete Chebyshev polynomial (of the first type) of order two is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
XX\textrm{\_}poly & =\left[\begin{array}{cccccc}
1 & \tilde{x}_{1} & \tilde{x}_{2} & 2\tilde{x}_{1}^{2}-1 & \tilde{x}_{1}\tilde{x}_{2} & 2\tilde{x}_{2}^{2}-1\end{array}\right]\label{eq:Cheb_poly}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\tilde{x}_{1}$
\end_inset

 and 
\begin_inset Formula $\tilde{x}_{2}$
\end_inset

 are column vectors of the scaled down variables (see function 
\family typewriter
constr_grid
\family default
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Section
Function 
\family typewriter
scal_mat_up
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-scal_mat_up"

\end_inset


\end_layout

\begin_layout Standard
The function takes a scaled down grid 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

 and scales it up to output 
\begin_inset Formula $xx$
\end_inset

, using 
\family typewriter
sc_cheb_up
\family default
.
 The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

: scaled down grid (
\begin_inset Formula $m\times n$
\end_inset

 matrix) (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-`constr_grid'"
plural "false"
caps "false"
noprefix "false"

\end_inset

)
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

: vector of lower bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

: vector of upper bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: a is scaled up grid ( 
\begin_inset Formula $m\times n$
\end_inset

 matrix), with each column 
\begin_inset Formula $i$
\end_inset

 in 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

 linearly transformed using 
\family typewriter
sc_cheb_up
\family default
, using bounds 
\begin_inset Formula $lb\left(i\right)$
\end_inset

 and 
\begin_inset Formula $ub\left(i\right)$
\end_inset

.
\end_layout

\begin_layout Standard
The function uses:
\end_layout

\begin_layout Itemize

\family typewriter
sc_cheb_up
\family default
, which is explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_up"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
sc_cheb_up
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-sc_cheb_up"

\end_inset


\end_layout

\begin_layout Standard
This function uses a linear transformation of a variable of the form 
\begin_inset Formula $xx=(xx\textrm{\_}dw+1)(ub-lb)/2+lb$
\end_inset

.
 This means a variable 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

 with the basis interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

 is linearly mapped to the interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Values can be outside the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

, which results in 
\begin_inset Formula $xx$
\end_inset

 also being outside 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

.
\end_layout

\end_inset

.
 This is the inverse transformation of the function 
\family typewriter
sc_cheb_dw
\family default
.
 The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

 and 
\begin_inset Formula $ub$
\end_inset

: the lower and upper bound (both scalars) of variable 
\begin_inset Formula $xx$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

: an array of gridpoints for one variable on the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: an array of one variable with the same dimensions as 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

 and scaled up to the interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
scal_mat_dw
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-scal_mat_dw"

\end_inset


\end_layout

\begin_layout Standard
The function takes a scaled up grid (
\begin_inset Formula $xx$
\end_inset

 ) and scales it down (output 
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

) using 
\family typewriter
sc_cheb_dw
\family default
.
 The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: scaled up grid (
\begin_inset Formula $m\times n$
\end_inset

 matrix) (see Section
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_dw"
plural "false"
caps "false"
noprefix "false"

\end_inset

)
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

: vector of lower bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Itemize
\begin_inset Formula $ub$
\end_inset

: vector of upper bounds in each dimension (
\begin_inset Formula $1\times n$
\end_inset

 vector);
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

: a is scaled down grid (
\begin_inset Formula $m\times n$
\end_inset

 matrix) with each column in 
\begin_inset Formula $xx\left(i\right)$
\end_inset

 linearly transformed using 
\family typewriter
sc_cheb_dw
\family default
, using bounds 
\begin_inset Formula $lb\left(i\right)$
\end_inset

 and 
\begin_inset Formula $ub\left(i\right)$
\end_inset

.
\end_layout

\begin_layout Standard
The function uses:
\end_layout

\begin_layout Itemize

\family typewriter
sc_cheb_dw
\family default
, which is explained in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Function-sc_cheb_dw"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
sc_cheb_dw
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-sc_cheb_dw"

\end_inset


\end_layout

\begin_layout Standard
This function linearly transforms a variable with the formula 
\begin_inset Formula $xx\textrm{\_}dw=2xx/(ub-lb)-(lb+ub)/(ub-lb)$
\end_inset

.
 A variable 
\begin_inset Formula $xx$
\end_inset

 based on the interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

 is linearly mapped to interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Values can be outside the interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

, which results in 
\begin_inset Formula $xx$
\end_inset

 also being outside 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
\end_layout

\end_inset

.
 This is the inverse transformation of the function 
\family typewriter
sc_cheb_up
\family default
.
 The inputs are:
\end_layout

\begin_layout Itemize
\begin_inset Formula $lb$
\end_inset

 and 
\begin_inset Formula $ub$
\end_inset

: the lower and upper bound (both scalars) of variable 
\begin_inset Formula $xx$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx$
\end_inset

: an array (of any dimension) of gridpoints for one variable based on the
 interval 
\begin_inset Formula $\left[lb,ub\right]$
\end_inset

.
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $xx\textrm{\_}dw$
\end_inset

: an array of one variable with the same dimensions as 
\begin_inset Formula $xx$
\end_inset

 and scaled down to the interval 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
\end_layout

\begin_layout Section
Function 
\family typewriter
chebnodes
\begin_inset CommandInset label
LatexCommand label
name "sec:Function-chebnodes"

\end_inset


\end_layout

\begin_layout Standard
This function constructs a column vector of the Chebyshev nodes in the range
 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
 The input is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $dd$
\end_inset

: the number of nodes.
\end_layout

\begin_layout Standard
The output is:
\end_layout

\begin_layout Itemize
\begin_inset Formula $x$
\end_inset

: a column vector (
\begin_inset Formula $dd$
\end_inset

 x 1) of the Chebyshev nodes in the range 
\begin_inset Formula $\left[-1,1\right]$
\end_inset

.
\end_layout

\begin_layout Chapter
Update to v05.0.0 from v04.3
\begin_inset CommandInset label
LatexCommand label
name "chap:Update-to-v05.0.0"

\end_inset


\end_layout

\begin_layout Standard
As mentioned before the update from 
\family typewriter
Promes v04.3
\family default
 to 
\family typewriter
Promes v05.0.0
\family default
 is not backwards compatible.
 In 
\family typewriter
Promes v05.0.0
\family default
 it is not be possible to evaluate a policy function obtained with 
\family typewriter
Promes v04.3
\family default
.
 The changes necessary to run code written for v04.3 with v05.0.0 are however
 minimal and discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Updating-your-code"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Some default values changed, and these are discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Changes-in-default"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The added options are discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Added-options"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and other changes in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Other-changes"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Section
Updating your code
\begin_inset CommandInset label
LatexCommand label
name "sec:Updating-your-code"

\end_inset


\end_layout

\begin_layout Standard
To update your code to v05.0.0 you need to account for the following changes:
\end_layout

\begin_layout Paragraph*
Function 
\family typewriter
prepgrid
\end_layout

\begin_layout Itemize

\family typewriter
prepgrid
\family default
 changed its name (was 
\family typewriter
prep_grid
\family default
);
\end_layout

\begin_layout Itemize
Input arguments changed.
 For splines and complete polynomials the inputs 
\begin_inset Formula $qq$
\end_inset

 and 
\begin_inset Formula $ord\_vec$
\end_inset

 (was 
\begin_inset Formula $order$
\end_inset

 in v04.3) have to be set as fields of the fifth argument 
\begin_inset Formula $algo\textrm{\_}spec$
\end_inset

.
 (They were individual input arguments in v04.3).
 In addition 
\begin_inset Formula $ord\_vec$
\end_inset

 has to be vector (
\begin_inset Formula $order$
\end_inset

 was scalar in v04.3).
\end_layout

\begin_layout Paragraph*
Function 
\family typewriter
get_pol_var
\end_layout

\begin_layout Itemize
The input 
\begin_inset Formula $spec\_opt$
\end_inset

 changed.
 The input 
\begin_inset Formula $spec\_opt$
\end_inset

 has to be set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'ini_grid'}
\end_layout

\end_inset

 to use the initial grid (was 
\begin_inset Formula $spec\_opt=1$
\end_inset

 in v04.3).
 The input 
\begin_inset Formula $spec\_opt$
\end_inset

 has to be set to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'old_pol'}
\end_layout

\end_inset

 to evaluate the old policy for Time Iteration (was 
\begin_inset Formula $spec\_opt=2$
\end_inset

 in v04.3).
\end_layout

\begin_layout Paragraph
Function 
\family typewriter
solve_proj
\end_layout

\begin_layout Itemize
The last input argument is changed to 
\begin_inset Formula $options$
\end_inset

 (was 
\begin_inset Formula $opt\textrm{\_}display$
\end_inset

 in v04.3), which determines the 
\begin_inset Formula $optimoptions$
\end_inset

 structure for 
\family typewriter
fsolve
\family default
 and 
\family typewriter
lsqnonlin
\family default
 (
\begin_inset Formula $opt\textrm{\_}display$
\end_inset

 only determined the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'Display'}
\end_layout

\end_inset

 option of 
\family typewriter
fsolve
\family default
 and 
\family typewriter
lsqnonlin
\family default
 in v04.3).
\end_layout

\begin_layout Paragraph*
Algorithm names in 
\begin_inset Formula $POL$
\end_inset


\end_layout

\begin_layout Itemize
The algorithms changed names.
 Table 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{tab:algo_changes}
\end_layout

\end_inset

 shows the new and the old names;
\end_layout

\begin_layout Itemize
Algorithms have to be set in 
\begin_inset Formula $POL.algo$
\end_inset

 (was 
\begin_inset Formula $POL.sol\textrm{\_}meth$
\end_inset

 in v04.3).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{table}
\end_layout

\begin_layout Plain Layout


\backslash
centering  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{threeparttable}
\end_layout

\begin_layout Plain Layout


\backslash
centering    
\end_layout

\begin_layout Plain Layout


\backslash
caption{Algorithm name changes}
\end_layout

\begin_layout Plain Layout


\backslash
label{tab:algo_changes}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{lll} 
\end_layout

\begin_layout Plain Layout


\backslash
hline         
\end_layout

\begin_layout Plain Layout

                  
\end_layout

\begin_layout Plain Layout

Algorithm & Name &  Old name 
\backslash

\backslash
   
\end_layout

\begin_layout Plain Layout


\backslash
hline     
\end_layout

\begin_layout Plain Layout

Spline with Time Iteration & 
\backslash
lstinline$'spl_tmi'$&  
\backslash
lstinline$'tmi'$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Spline with Direct Computation & 
\backslash
lstinline$'spl_dir'$ & 
\backslash
lstinline$'dir'$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Chebyshev with Galerkin's method  & 
\backslash
lstinline$'cheb_gal'$ & 
\backslash
lstinline$'gal '$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Chebyshev, Min.
 of Sq.
 Errors  & 
\backslash
lstinline$'cheb_mse'$ & 
\backslash
lstinline$'mse'$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

Monomials, Min.
 of Sq.
 Errors  & 
\backslash
lstinline$'mono_mse'$ & 
\backslash
lstinline$'mono'$
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
hline     
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}          
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       
\end_layout

\begin_layout Plain Layout


\backslash
end{threeparttable}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{table}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Changes in default settings
\begin_inset CommandInset label
LatexCommand label
name "sec:Changes-in-default"

\end_inset


\end_layout

\begin_layout Itemize
For algorithms 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_tmi'}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_tmi'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_tmi'}
\end_layout

\end_inset

 the default tolerance 
\begin_inset Formula $diff\textrm{\_}tol$
\end_inset

 is 
\begin_inset Formula $10^{-8}$
\end_inset

 (was 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $10^{-6}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
 for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 in v04.3).
 The parameter 
\begin_inset Formula $step\text{\_}acc$
\end_inset

 is set to 0.1 by default (was 0.01 for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

 in v04.3);
\end_layout

\begin_layout Itemize
Algorithms 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_tmi'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spl_dir'}
\end_layout

\end_inset

 use interpolation method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'spline'}
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
See Matlab documentation on 
\family typewriter
griddedInterpolant
\family default
.
\end_layout

\end_inset

 by default (was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cubic'}
\end_layout

\end_inset

 for algorithms 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'tmi'}
\end_layout

\end_inset

, and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'dir'}
\end_layout

\end_inset

 in v04.3).
\end_layout

\begin_layout Section
Added options
\begin_inset CommandInset label
LatexCommand label
name "sec:Added-options"

\end_inset


\end_layout

\begin_layout Itemize
Smolyak algorithms (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_dir'}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'smol_tmi'}
\end_layout

\end_inset

) added;
\end_layout

\begin_layout Itemize
Algorithm with complete Chebyshev polynomial and Time Iteration (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinline{'cheb_tmi'}
\end_layout

\end_inset

) added;
\end_layout

\begin_layout Itemize
Option to use asymmetric polynomials added, by setting the maximum order
 of the polynomial in each dimension in the input 
\begin_inset Formula $algo\textrm{\_}spec.ord\textrm{\_}vec$
\end_inset

 of the function 
\family typewriter
prepgrid
\family default
.
\end_layout

\begin_layout Section
Other changes
\begin_inset CommandInset label
LatexCommand label
name "sec:Other-changes"

\end_inset


\end_layout

\begin_layout Itemize
Complete polynomials: different procedure to construct the grid, using the
 field 
\begin_inset Formula $GRID.poly\textrm{\_}elem$
\end_inset

;
\end_layout

\begin_layout Itemize

\family typewriter
prepgrid
\family default
: all algorithms have default settings for the grid.
 The only required inputs are 
\begin_inset Formula $nn$
\end_inset

, 
\begin_inset Formula $lb$
\end_inset

, 
\begin_inset Formula $ub$
\end_inset

, and 
\begin_inset Formula $algo$
\end_inset

;
\end_layout

\begin_layout Itemize
\begin_inset Formula $GRID$
\end_inset

: several fields are changed or added.
 The most important changes are for complete polynomials: the fields 
\begin_inset Formula $XX\_poly$
\end_inset

 (was 
\begin_inset Formula $XX$
\end_inset

) and 
\begin_inset Formula $XX\_poly\_dw$
\end_inset

 (was 
\begin_inset Formula $XX\_dw$
\end_inset

) are renamed, and the field 
\begin_inset Formula $poly\_elem$
\end_inset

 is added;
\end_layout

\begin_layout Itemize
Grid subfunctions: several names of functions, and their arguments changed.
\end_layout

\begin_layout Part
Example models
\begin_inset CommandInset label
LatexCommand label
name "part:Example-models"

\end_inset


\end_layout

\begin_layout Chapter
Deterministic Brock-Mirman model
\begin_inset CommandInset label
LatexCommand label
name "chap:Description-det-BM"

\end_inset


\end_layout

\begin_layout Standard
The Brock-Mirman model was used in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:The-Basics"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as a simple example.
 In this chapter we describe the derivation of the equations used there.
 The Brock-Mirman model is interesting, because the optimal solution can
 be derived analytically, even for the stochastic version.
 We used the deterministic version for simplicity reasons.
 
\end_layout

\begin_layout Standard
The agent in the Brock-Mirman model maximizes his discounted utility :
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\max & \sum_{t=1}^{\infty}\beta^{t-1}\log\left(C_{t}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
subject to:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
K_{t+1}+C_{t} & =K_{t}^{\alpha}\label{eq:BM-budget2}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $C_{t}$
\end_inset

 is consumption in period 
\begin_inset Formula $t$
\end_inset

, 
\begin_inset Formula $\beta$
\end_inset

 is the discount factor, 
\begin_inset Formula $K_{t}$
\end_inset

 is the capital stock 
\shape italic
at the beginning
\shape default
 of the period, and 
\begin_inset Formula $K_{t}^{\alpha}$
\end_inset

 is the production function.
\end_layout

\begin_layout Standard
We rewrite the maximization problem in a infinite horizon Lagrangian:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\mathcal{L} & =\sum_{t=1}^{\infty}\beta^{t-1}\left\{ \log\left(C_{t}\right)+\lambda_{t}\left[K_{t}^{\alpha}-K_{t+1}-C_{t}\right]\right\} 
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\lambda_{t}$
\end_inset

 is the Lagrangian multiplier on the resource constraint.
 The solution is an infinite series for 
\begin_inset Formula $C_{t}$
\end_inset

, 
\begin_inset Formula $K_{t+1}$
\end_inset

, and 
\begin_inset Formula $\lambda_{t}$
\end_inset

.
 The sufficient First Order Conditions with respect to 
\begin_inset Formula $C_{t}$
\end_inset

, and 
\begin_inset Formula $K_{t+1}$
\end_inset

 are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\frac{1}{C_{t}} & =\lambda_{t}\label{eq:BM-FOC_c}\\
\lambda_{t} & =\beta\lambda_{t+1}\alpha K_{t+1}^{\alpha-1}\nonumber 
\end{align}

\end_inset


\end_layout

\begin_layout Standard
The second equation is referred to as the Euler equation, and characterizes
 the dynamic solution.
 We can substitute out 
\begin_inset Formula $\lambda$
\end_inset

 using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM-FOC_c"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and obtain: 
\begin_inset Formula 
\begin{align}
\frac{1}{C_{t}} & =\beta\frac{1}{C_{t+1}}\alpha K_{t+1}^{\alpha-1}\label{eq:BM-Eul}
\end{align}

\end_inset


\end_layout

\begin_layout Subsection*
Analytical solution
\end_layout

\begin_layout Standard
The model has an analytical solution, which is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
C_{t} & =\left(1-\alpha\beta\right)K_{t}^{\alpha}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
With this policy function next period's capital stock is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
K_{t+1} & =K_{t}^{\alpha}-\left(1-\alpha\beta\right)K_{t}^{\alpha}\\
 & =\left(\alpha\beta\right)K_{t}^{\alpha}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
Substituting this into the The Euler equation yields:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\frac{1}{\left(1-\alpha\beta\right)K_{t}^{\alpha}} & =\beta\frac{1}{\left(1-\alpha\beta\right)\left[\left(\alpha\beta\right)K_{t}^{\alpha}\right]^{\alpha}}\alpha\left[\left(\alpha\beta\right)K_{t}^{\alpha}\right]^{\alpha-1}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
which proofs that both equations are satisfied for the given solution.
\end_layout

\begin_layout Subsection*
Steady state
\end_layout

\begin_layout Standard
From the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM-Eul"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we derive steady state capital:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overline{K} & =\left[\alpha\beta\right]^{\frac{1}{1-\alpha}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
and from the resource constraint 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:BM-budget2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we derive steady state consumption:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overline{C} & =\overline{K}^{\alpha}-\delta\overline{K}
\end{align*}

\end_inset


\end_layout

\begin_layout Chapter
Standard RBC model
\begin_inset CommandInset label
LatexCommand label
name "chap:Standard_RBC_model"

\end_inset


\end_layout

\begin_layout Standard
In Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:RBC-example"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we used a standard Real Business Cycle (RBC) as an example.
 In this chapter we derive the equations used in that chapter.
 This includes the computation of the expected value using Gauss-Hermite
 quadrature.
\end_layout

\begin_layout Section
Model
\begin_inset CommandInset label
LatexCommand label
name "sec:Full-model-description"

\end_inset


\end_layout

\begin_layout Standard
A standard Real Business Cycle (RBC) model with a representative agent is
 a dynamic model where the agent has to determine how much to work, consume
 and invest.
 Hours worked gives disutility, consumption gives instant positive utility,
 while investment increases future capital income.
\end_layout

\begin_layout Standard
The objective function of the agent is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\max\: & E_{1}\underset{{\scriptstyle t=1}}{\overset{{\scriptstyle \infty}}{\sum}}\beta^{t-1}\left\{ \frac{C_{t}^{1-\nu}}{1-\nu}-\chi\frac{H_{t}^{1+\frac{1}{\eta}}}{1+\frac{1}{\eta}}\right\} 
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $C_{t}$
\end_inset

 is period 
\begin_inset Formula $t$
\end_inset

 consumption, and 
\begin_inset Formula $H_{t}$
\end_inset

 is period 
\begin_inset Formula $t$
\end_inset

 labor supply.
 The real budget constraint is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{t}+K_{t+1} & =Z_{t}K_{t}^{\alpha}H_{t}^{1-\alpha}+\left(1-\delta\right)K_{t}\label{eq:Budget_constraint}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $K_{t}$
\end_inset

 is the capital stock at the beginning of period 
\begin_inset Formula $t$
\end_inset

, and 
\begin_inset Formula $\delta$
\end_inset

 is the depreciation rate of capital.
 Total Factor Productivity (TFP) 
\begin_inset Formula $Z_{t}$
\end_inset

 evolves by an exogenous process:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
z_{t} & =\rho_{z}z_{t-1}+\sigma_{z}\epsilon_{t}\label{eq:TFP_process}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $z_{t}=\log\left(Z_{t}\right)$
\end_inset

, 
\begin_inset Formula $\rho_{z}$
\end_inset

 is the autocorrelation coefficient, and 
\begin_inset Formula $\sigma_{z}$
\end_inset

 is the standard deviation of the shocks.
 The shocks 
\begin_inset Formula $\epsilon_{t}$
\end_inset

 are standard normally distributed (
\begin_inset Formula $\epsilon_{t}\sim\mathcal{N}\left(0,1\right)$
\end_inset

).
\end_layout

\begin_layout Standard
The optimization problem can be written with an infinite Lagrangian:
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{L}=E\overset{{\scriptscriptstyle \infty}}{\underset{{\scriptscriptstyle t=1}}{\sum}}\beta^{t}\left\{ \frac{C_{t}^{1-\nu}}{1-\nu}-\chi\frac{H_{t}^{1+\frac{1}{\eta}}}{1+\frac{1}{\eta}}+\lambda_{t}\left[Z_{t}K_{t}^{\alpha}H_{t}^{1-\alpha}+\left(1-\delta\right)K_{t}-C_{t}-K_{t+1}\right]\right\} $
\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $\lambda_{t}$
\end_inset

 is the shadow price of the budget constraint, and 
\begin_inset Formula $K_{1}$
\end_inset

 is given.
 Maximization of this Lagrangian with respect to hours 
\begin_inset Formula $H_{t}$
\end_inset

, consumption 
\begin_inset Formula $C_{t}$
\end_inset

 and capital in next period 
\begin_inset Formula $K_{t+1}$
\end_inset

 yields the following First Order Conditions:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
C_{t}^{-\nu} & =\lambda_{t}\\
\chi H_{t}^{\frac{1}{\eta}} & =\lambda_{t}Z_{t}\left(1-\alpha\right)K_{t}^{\alpha}H_{t}^{-\alpha}\\
\lambda_{t} & =\beta\lambda_{t+1}\left[F_{k}\left(K_{t},H_{t}\right)+1-\delta\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Substituting out 
\begin_inset Formula $\lambda$
\end_inset

 gives:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\chi H_{t}^{\frac{1}{\eta}} & =C_{t}^{-\nu}Z_{t}\left(1-\alpha\right)K_{t}^{\alpha}H_{t}^{-\alpha}\label{eq:Lab_supply}\\
C_{t}^{-\nu} & =\beta E_{t}\left\{ C_{t+1}^{-\nu}\left[Z_{t+1}\alpha K_{t+1}^{\alpha-1}H_{t+1}^{1-\alpha}+1-\delta\right]\right\} \label{eq:Euler_eq}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
We can derive an analytical expression for labor supply, given capital,
 TFP and consumption using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Lab_supply"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
H_{t} & =\left[\frac{1-\alpha}{\chi}C_{t}^{-\nu}Z_{t}K_{t}^{\alpha}\right]^{\frac{\eta}{1+\alpha\eta}}\label{eq:RBC_lab_sol}
\end{align}

\end_inset


\end_layout

\begin_layout Section
Gauss-Hermite quadrature
\begin_inset CommandInset label
LatexCommand label
name "sec:RBC_quadrature"

\end_inset


\end_layout

\begin_layout Standard
The general rule for Gaussian-Hermite approximation is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
\intop_{-\infty}^{\infty}\exp\left(-z^{2}\right)g\left(z\right)dz & \approx\sum_{j=1}^{J}\omega_{j}g\left(\zeta_{j}\right)\label{eq:Gauss-Hermite-gen}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
with Gauss-Hermite nodes 
\begin_inset Formula $j=1,...,J$
\end_inset

, roots 
\begin_inset Formula $\zeta_{j}$
\end_inset

 and weights 
\begin_inset Formula $\omega_{j}$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
before "see"
key "judd1998numerical"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Assume we have a function 
\begin_inset Formula $f\left(z_{t+1},x\right)$
\end_inset

 with exogenous variable 
\begin_inset Formula $z_{t+1}$
\end_inset

.
 This variable evolves according to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:TFP_process"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with standard normally distributed shocks 
\begin_inset Formula $\epsilon_{t+1}\sim\mathcal{N}\left(0,1\right)$
\end_inset

.
 The expected value of this function is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
E_{t}f\left(z_{t+1},x\right) & =\intop_{-\infty}^{\infty}f\left(\rho_{z}z_{t}+\sigma_{z}\epsilon_{t+1},x\right)\frac{1}{\sqrt{2\pi}}\exp\left(-\epsilon_{t+1}^{2}/2\right)d\epsilon_{t+1}\label{eq:GH_gen2}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
To write 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:GH_gen2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 in the same form as 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Gauss-Hermite-gen"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we need a change of variable 
\begin_inset Formula $\phi=\frac{\epsilon_{t+1}}{\sqrt{2}}$
\end_inset

, such that 
\begin_inset Formula $\exp\left(-\epsilon_{t+1}^{2}/2\right)=\exp\left(-\phi^{2}\right)$
\end_inset

.
 The approximation of the integral is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{multline*}
\intop_{-\infty}^{\infty}f\left(\rho_{z}z_{t}+\sigma_{z}\sqrt{2}\phi,x\right)\frac{1}{\sqrt{2\pi}}\exp\left(\phi\right)\sqrt{2}d\phi\\
\approx\sum_{j=1}^{J}\frac{\omega_{j}}{\sqrt{\pi}}f\left(\rho_{z}z_{t}+\sigma_{z}\sqrt{2}\zeta_{j},x\right)
\end{multline*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where the extra term
\begin_inset Formula $\sqrt{2}$
\end_inset

 (before 
\begin_inset Formula $d\phi$
\end_inset

) follows from integration by substitution.
\end_layout

\begin_layout Section
Steady state
\begin_inset CommandInset label
LatexCommand label
name "sec:RBC_steady-state"

\end_inset


\end_layout

\begin_layout Standard
To derive the analytical steady state we start with the Euler equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Euler_eq"
plural "false"
caps "false"
noprefix "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overline{C}^{-\nu} & =\beta\left\{ \overline{C}^{-\nu}\left[\overline{Z}\alpha\overline{K}^{\alpha-1}H^{1-\alpha}+1-\delta\right]\right\} \\
\overline{H} & =\left[\frac{1-\beta\left(1-\delta\right)}{\overline{Z}\alpha\beta}\right]^{\frac{1}{1-\alpha}}\overline{K}=\Omega^{\frac{1}{1-\alpha}}\overline{K}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
with 
\begin_inset Formula $\Omega=\frac{1-\beta\left(1-\delta\right)}{\alpha\beta\overline{Z}}$
\end_inset

.
\end_layout

\begin_layout Standard
Substituting this into the resource constraint 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Budget_constraint"
plural "false"
caps "false"
noprefix "false"

\end_inset

 yields:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overline{C}+\overline{K} & =\overline{Z}\overline{K}^{\alpha}\overline{H}^{1-\alpha}+\left(1-\delta\right)\overline{K}\\
\overline{C} & =\overline{Z}\overline{K}^{\alpha}\left[\Omega^{\frac{1}{1-\alpha}}\overline{K}\right]^{1-\alpha}-\delta\overline{K}\\
 & =\left(\overline{Z}\Omega-\delta\right)\overline{K}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Substituting the expressions for 
\begin_inset Formula $\overline{H}$
\end_inset

 and 
\begin_inset Formula $\overline{C}$
\end_inset

 into the labor supply function 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Lab_supply"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and solving for 
\begin_inset Formula $\overline{K}$
\end_inset

 yields:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overline{K} & =\left[\left(\frac{1-\alpha}{\chi}\overline{Z}\left[\overline{Z}\Omega-\delta\right]^{-\nu}\right)^{\eta}\Omega^{\frac{\alpha\eta+1}{\alpha-1}}\right]^{\frac{1}{1+\eta\nu}}
\end{align*}

\end_inset


\end_layout

\begin_layout Chapter
Housing model
\begin_inset CommandInset label
LatexCommand label
name "chap:Housing-model"

\end_inset


\end_layout

\begin_layout Standard
In Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Multiple-policy-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we used an RBC model with housing to demonstrate how to solve a model with
 two policy variables.
 In this chapter we describe the model and the derivations of the equations.
 
\end_layout

\begin_layout Subsection*
Model
\end_layout

\begin_layout Standard
The objective of the agent is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\max\: & E_{1}\sum_{t=1}^{\infty}\beta^{t-1}\left[U\left(C_{t}\right)+V\left(D_{t}\right)\right]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset Formula $C$
\end_inset

 is consumption, and 
\begin_inset Formula $D$
\end_inset

 is housing.
 The agent maximizes the objective subject to the budget constraint:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
C_{t}+K_{t+1}+D_{t+1} & \leq Z_{t}K_{t}^{\alpha}+\left(1-\delta_{k}\right)K_{t}+\left(1-\delta_{d}\right)D_{t}\label{eq:HOUS_budget}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The First Order Conditions for 
\begin_inset Formula $C_{t}$
\end_inset

, 
\begin_inset Formula $K_{t+1}$
\end_inset

, and 
\begin_inset Formula $D_{t+1}$
\end_inset

 are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align}
U'\left(C_{t}\right) & =\lambda_{t}\nonumber \\
\lambda_{t} & =\beta E_{t}\left\{ \lambda_{t+1}\left[Z_{t+1}\alpha K_{t+1}^{\alpha-1}+1-\delta_{k}\right]\right\} \label{eq:HOUS_eul_k}\\
\lambda_{t} & =\beta E_{t}\left\{ V'\left(D_{t+1}\right)+\lambda_{t+1}\left(1-\delta_{d}\right)\right\} \label{eq:HOUS_eul_h}
\end{align}

\end_inset


\end_layout

\begin_layout Standard
\noindent
We use the functional form: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
U\left(C_{t}\right) & =\frac{C_{t}^{1-\nu}-1}{1-\nu}\\
V\left(D_{t}\right) & =\varrho\frac{D_{t}^{1-\eta}-1}{1-\eta}
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection*
Steady state
\end_layout

\begin_layout Standard
The Euler equation for capital 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_eul_k"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is standard and yields:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
1 & =\beta\left(\overline{Z}\alpha\overline{K}^{\alpha-1}+1-\delta_{k}\right)\\
\overline{K} & =\left(\frac{\overline{Z}\alpha\beta}{1-\beta\left(1-\delta_{k}\right)}\right)^{\frac{1}{1-\alpha}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
From the Euler equation for housing 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HOUS_eul_h"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we derive:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
V'\left(\overline{D}\right) & =\overline{\lambda}\frac{1-\beta\left(1-\delta_{d}\right)}{\beta}\\
\varrho\overline{D}^{-\eta} & =\overline{C}^{-\nu}\frac{1-\beta\left(1-\delta_{d}\right)}{\beta}\\
\overline{D} & =\left(\frac{1-\beta\left(1-\delta_{d}\right)}{\varrho\beta}\right)^{\frac{1}{-\eta}}\overline{C}^{\frac{\nu}{\eta}}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
And finally from the budget constraint:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\overline{C}+\delta_{k}\overline{K}+\delta_{d}\overline{D} & =\overline{Z}\overline{K}^{\alpha}\\
\overline{C}+\delta_{d}\left(\frac{1-\beta\left(1-\delta_{k}\right)}{\varrho\beta}\right)^{\frac{1}{-\eta}}\overline{C}^{\frac{\nu}{\eta}} & =\overline{Z}\overline{K}^{\alpha}-\delta_{k}\overline{K}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\noindent
We solve for 
\begin_inset Formula $\overline{C}$
\end_inset

 and 
\begin_inset Formula $\overline{D}$
\end_inset

 numerically using a non-linear equation solver.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "C:/Users/sadui/Dropbox/RESEARCH/REFERENCES/Macro_refer"
options "bibtotoc"

\end_inset


\end_layout

\end_body
\end_document
